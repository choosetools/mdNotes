[TOC]

**不同版本中，Redis数据类型与数据结构之间的关系：**

**Redis 6与之前**

![image-20240724062016536](.\images\image-20240724062016536.png)



**Redis 7以后**

![image-20240724061730434](.\images\image-20240724061730434.png)







# 一、Redis数据类型与底层实现

### Redis数据类型与数据结构之间的关系

**Redis为什么那么快？**

除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis能高效地处理。

注意，Redis数据结构并不是指String（字符串）、List（列表）、Hash（哈希）、Set（集合）和ZSet（有序集合）对象，因为这些是Redis键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现方式使用了数据结构。

以下是Redis数据类型和底层数据结构的对应关系图，左边是Redis3.0版本，也就是《Redis设计与实现》这本书讲解的版本，右边是比较新的Redis版本：

![img](.\images\9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png)

可以看到，Redis数据类型的底层数据结构随着版本的更新也有所不同。（将在后面学习不同的数据类型所使用的底层数据结构）

这里，我们将去学习新旧版本的所有Redis数据结构，共有9种：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。



**不同版本中，Redis数据类型与数据结构之间的关系：**

**Redis 6与之前**

![image-20240724062016536](.\images\image-20240724062016536.png)

* `String` 使用 `SDS` 实现
* `List` 使用 `双向链表` + `ziplist` 实现
* `Hash` 使用 `hashtable` + `ziplist` 实现
* `Set` 使用 `hashtable` + `intset` 实现
* `SortedSet` 使用 `skiplist` + `ziplist` 实现



**Redis 7以后**

![image-20240724061730434](.\images\image-20240724061730434.png)

也就是说，在Redis7以后，压缩列表不再使用了，使用了其他数据结构来实现（但是这个数据结构还是保留了）：

* `String` 使用 `SDS` 实现。
* `List` 使用 `quicklist` 实现。
* `Hash` 使用 `hashtable` + `listpack` 实现。
* `Set` 使用 `hashtable` + `intset` 实现。
* `SortedSet` 使用 `skiplist` + `listpack` 实现。

Redis6和7版本，数据结构最大的不同就在于ziplist使用了listpack替代，并且List数据类型从原本使用双向链表+ziplist实现改成了使用quicklist实现。







### Redis源码如何查看？

Redis是一个开源的使用C语言编写的键值对存储数据库，提供了多种语言的API，Redis的源码位于Redis目录下的src目录中：

<img src=".\images\123412341234.png" alt="123412341234" style="zoom:67%;" /> 

有这么多源码文件，我们该如何看？

数据类型有关的源码文件：

* Redis对象：object.c
* 字符串：t_string.c
* 列表：t_list.c
* 字典：t_hash.c
* 集合及有序集合：t_set.c和t_zset.c

底层数据结构有关的源码文件：

* 简单动态字符串：sds.c
* 整数集合：intset.c
* 压缩列表：ziplist.c
* 快速链表：quicklist.c
* 紧凑链表：listpack.c
* 字典：dict.c

还有Redis数据库的实现：db.c

与持久化实现的源码：rdb.c和aof.c

Redis服务端和客户端的实现：

* 事件驱动：ae.c和ae_epoll.c
* 网络连接：anet.c和networking.c
* 服务端程序：server.c
* 客户端程序：redis-cli.c

主从复制实现的源码：replication.c

哨兵实现的源码：sentinel.c

集群实现的源码：cluster.c

其他数据结构，如hyperloglog.c、geo.c等等。





## 底层数据结构（:star:）

### 1、RedisObject

在开始讲数据结构之前，先给介绍一下Redis是怎样实现键值对（key-value）数据库的。

Redis的键值对中的**key就是字符串对象，而value可以是字符串对象，也可以是集合数据类型的对象**，比如List对象、Hash对象、Set对象和ZSet对象。

举个例子，我这里列出几种Redis新增键值对的命令：

```sh
> SET name "xiaolincoding"
OK

> HSET person name "xiaolincoding" age 18
0

> RPUSH stu "xiaolin" "xiaomei"
(integer) 4
```

这些命令代表着：

* 第一条命令：name是一个字符串键，因为键的值是一个字符串对象；
* 第二条命令：person是一个哈希表键，因为键的值是一个包含两个键值对的哈希表对象；
* 第三个命令：stu是一个列表键，因为键的值是一个包含两个元素的列表对象。

**这些键值对是如何保存在Redis中的呢？**

Redis是使用了一个**`哈希表`**来保存所有键值对，哈希表的最大好处就是让我们可以使用O(1)的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。

**Redis的哈希桶是怎么保存键值对数据的呢？**

哈希桶存放的是指向键值对数据的指针（`dictEntry*`），这样通过指针就能够找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构并不是直接保存值本身，而是分别保存了`void * key`和`void * value`指针，分别指向实际的键对象和值对象，这样一来，即使是集合数据，也可以通过`void * value`指针找到。

下面是Redis保存键值对时所涉及到的数据结构：

![img](.\images\f302fce6c92c0682024f47bf7579b44c.png)

大致说明：

* `redisDb`结构：表示Redis数据库的结构，在结构体中存放了指向dict结构的指针；
* `dict`结构，结构体里存放了两个哈希表，正常情况下都是使用哈希表1，哈希表2只有在rehash的时候才会使用，rehash将在哈希表数据结构中讲解。
* `dictht`结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向哈希表节点结构（dictEntry）的指针；
* `dictEntry`结构，表示哈希表节点的结构，结构里面存放了void * key和void * value指针。key指向的是String对象，而value可以指向String对象，也可以指向集合类型的对象，比如List、Hash、Set和ZSet，每一种对象都是由`redisObject`构成。





> **无论void * key指针和void * value指针指向的是哪一种数据类型对象，Redis中的每一个对象都是通过`redisObject`结构进行储存的，只不过是底层实现的数据结构不同。**

为了便于操作，Redis采用redisObject结构来统一五种不同的数据类型，这样所有的数据类型就都可以以相同的形式在函数间传递而不用使用特定的类型结构。同时，为了识别不同的数据类型，redisObject定义了type和encoding字段对不同的数据类型加以区别。简单来说，`redisObject就是string、hash、list、set、zset的父类`，可以在函数间传递时隐藏具体的类型信息，所以作者抽象了redisObject结构来达到同样的目的。

**redisObject的定义如下：**

```c
typedef struct redisObject {
　　unsigned type:4;
　　unsigned encoding:4;
　　unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */
　　int refcount;
　　void *ptr;
} robj;
```

一共有5个属性，其中的type、encoding和ptr是三个最重要的属性：

1. **`type`**

type字段表示**对象的类型**，占用4个bit，所有的取值包括：

```c
/*
 * 对象类型
 */
#define REDIS_STRING 0  // 字符串
#define REDIS_LIST 1    // 列表
#define REDIS_SET 2     // 集合
#define REDIS_ZSET 3    // 有序集
#define REDIS_HASH 4    // 哈希表
```

当我们执行type命令时，就是通过读取redisObject中的type字段来获取到对象的类型，如下图所示：

![img](.\images\1174710-20180327001214189-1733420705.png) 



2. **`encoding`**

encoding表示**对象的内部编码方式**，占用4个bit。

对于Redis支持的每种数据类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。

**通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。**

在Redis7及以后，encoding有11种取值：

![2384902380](.\images\2384902380.png)

这些encoding的取值，分别对应的数据结构为：

<img src=".\images\123097128903712.png" alt="123097128903712" style="zoom:80%;" /> 



通过`object encoding key`命令，可以查看对象采用的编码方式，如下图所示：

![img](.\images\1174710-20180327001228807-998910409.png) 



3. **lru**

lru这个必然是和内存回收相关的了，这里它记录的是当前的值对象最后一次被程序访问的时间。

通过这个时间我们可以得到该对象的空转时长，就是当前时间 - lru记录的时间，如果说redis服务器打开了 maxmemory 最大内存管理的选项，并且内存回收使用volatile-lru 或者 allkeys-lru算法，那么服务器就会优先释放这个空转时长比较长的对象，从而回收内存。



4. **refcount**

refcount记录的是当前这个值对象正在被多少数据结构所共享。



5. **`ptr`**

> **ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type属性和encoding属性决定。**



那么也就是说，redisObject类似于一个封装起来对象，这个对象实际是什么数据类型，是根据type来决定的，数据类型实际使用什么样的数据结构，实际上是根据ptr指针来决定的。

所以，redisObject结构可以表示为：

<img src=".\images\58d3987af2af868dca965193fb27c464.png" alt="img" style="zoom:67%;" /> 

 



那么，Redis键值对数据库全景图如下所示：

![img](.\images\3c386666e4e7638a07b230ba14b400fe.png)





---

### 2、SDS动态字符串

`SDS`：`Simple Dynamic String`，简单动态字符串。

字符串在Redis中是很常见的，键值对中的键是字符串类型，值有时也是字符串类型。

Redis是使用C语言编写的，但是它没有直接使用C语言的char*字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string）的数据结构来表示字符串，也就是Redis的String数据类型的底层数据结构是SDS。

既然Redis设计了SDS结构来表示字符串，肯定是C语言的char*数组存在一些缺陷，现在我们来看看C语言字符串存在哪些缺陷。



#### C语言字符串存在的缺陷（:star2:）

C语言的字符串其实就是一个字符数组，即数组中的每个元素是字符串中的一个字符。

比如，下图就是字符串"xiaolin"的char*字符数组结构：

![img](.\images\376128646c75a893ad47914858fa2131.png) 

没有学过C语言的同学，可能会好奇为什么最后一个字符是"\0"？

在C语言中，对字符串操作时，char*指针只是指向字符数组的起始位置，而**字符数组的结尾就用"\0"表示，意思是指字符串的结束。**

因此，C语言标准库中的字符串操作函数就是通过判断字符是不是"\0"来决定要不要停止操作，如果当前字符不是"\0"，说明字符还没有结束，可以继续操作，如果当前字符是"\0"则说明字符串结束，要停止操作了。

举个例子：C语言获取字符串长度的函数`strlen`，就是去遍历字符数组中的每一个字符，并进行计数，当遇到字符为"\0"后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下面显示了strlen函数的执行流程：

<img src="https://cdn.xiaolincoding.com//mysql/other/bcf6bde3b647bdc343efcbc1a8f10579.png" alt="img" style="zoom:67%;" /> 



很明显，**C语言中获取字符串长度函数的时间复杂度是O(N)，这是一个可以改进的地方**。

C语言字符串使用"\0"字符作为结尾有一个缺陷：假设字符串中包含"\0"字符，这时在操作这个字符串的时候就会**提早结束**。比如"xiao\0lin"字符串，计算字符串长度的时候则会是4，如下图：

<img src=".\images\6286480eb1840a8930e18fd215d82565.png" alt="img" style="zoom:67%;" /> 

因此，除了字符串的末尾之外，**字符串里面不能含有"\0"字符**，否则最先被程序读入的"\0"字符将被误认为是字符串结尾，这个限制使得C语言的字符串只能保存文本数据，**不能保存像图片、音频、视频这样的二进制数据**（这也是一个可以改进的地方）。

另外，C语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一个不注意，就会导致缓冲区溢出。

举个例子，strcat函数是可以将两个字符串拼接在一起：

```c
//将 src 字符串拼接到 dest 字符串后面
char *strcat(char *dest, const char* src);
```

**C语言的字符串是不会记录自身的缓冲区大小的**，所以strcat函数是假定程序员在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而**一旦这个假设不成立，就会发生缓冲区溢出并可能造成程序运行终止（这时一个可以改进的地方）。**

而且，strcat函数和strlen函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾，然后对于strcat函数来说，还需要遍历源字符串才能完成追加，**对字符串的操作效率不高**。



> 通过上面的分析，我们可以得知C语言的字符串不足之处以及可以改进的地方：
>
> 1. 获取字符串长度需要通过运算，时间复杂度为O(N)。
> 2. 字符串的结尾是以"\0"字符表示，字符串里面不能包含有"\0"字符，因此不能保存二进制数据，即非二进制安全的。
> 3. 字符串操作函数不高效且不安全，存在缓冲区溢出的风险，有可能会造成程序运行终止。

Redis实现的SDS结构就把上面这些问题解决了，接下来我们来一起看看Redis是如何解决的。



#### SDS结构

为了解决上述存在的问题，Redis构建了一种新的字符串结构，称为简单动态字符串（`Simple Dynamic String`），简称为**`SDS`**。

SDS数据结构：

<img src=".\images\516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom: 80%;" /> 

结构中的每个成员变量介绍如下：

1. **`len`：记录了字符串的长度**。这样获取字符串长度的时候，只需要返回这个成员变量值即可，时间复杂度为O(1)。

   

2. **`alloc`：分配给字符数组的空间长度**。也就是说，字符串不一定将buf[]数组申请的字节数全部占用。

   这样在修改字符串的时候，可以**通过`alloc - len`计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将SDS的空间扩展至执行修改所需的大小，然后再去执行修改操作，所以使用SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题**。

   **注意：**这里的**alloc值不包含\0结束标识所占用的空间**，是buf[]数组真正可以用来存放字符的长度。

   

3. **`flags`：用来表示不同类型的SDS**。一共设计了5种类型，分别是`sdshdr5`、`sdshdr8`、`sdshdr16`、`sdshdr32`和`sdshdr64`（由于sdshdr5能够表示的字符长度太小了，目前已经弃用），后面再说明区别之处。

   flags不同类型所对应的值：

   <img src=".\images\image-20240725201137821.png" alt="image-20240725201137821" style="zoom:67%;" /> 

   

4. **`buf[]`：字节数组，用来保存实际的数据**。不仅可以保存字符串，也可以保存二进制数据。

总的来说，Redis的SDS结构在原本字符数组的基础上，添加了三个元数据：len、alloc、flags，用来解决C语言字符串的缺陷。



例如，一个包含字符串"name"的SDS结构如下所示：

![image-20240725201031132](.\images\image-20240725201031132.png) 

SDS的内存空间是连续的。

因为我们的name是占用4个字节，所以可以使用sdshdr8类型（因为sdshdr5能表示的长度太小了，所以已经弃用），所以flags的值为1；

len表示字符串的长度，为4；

alloc表示buf[]数值申请的内存，第一次初始化时，申请的内存和占用的内存一致；

后面就是buf[]数组，最后会有一个\0的结束标识，SDS为了与C语言兼容，所以会保留\0这个结束标识。

但是，因为Redis中可以保存\0的二进制数据，不会根据\0这个标识来结束读取，而是根据SDS结构中的len字段值来读取相应的长度。





#### 使用SDS的好处

##### 获取字符串长度的时间复杂度为O(1)

C语言的字符串长度获取strlen函数，需要通过遍历的方式来统计字符串长度，时间复杂度是O(N)。

而Redis的SDS结构因为加入了len成员变量，那么**`获取字符串长度的时候，直接返回这个成员变量的值即可，时间复杂度是O(1)`**。





##### 二进制安全

因为SDS不需要用"\0"字符来标识子字符串结尾了，而是**`有一个专门的len成员变量来记录长度，所以可存储包含"\0"的数据`**。**SDS为了兼容部分C语言标准库的函数，SDS字符串结尾还是会加上"\0"字符。**

因此，SDS的API都是以处理二进制的方式来处理SDS存放在buf[]里的数据，程序不会对其中的数据做任何的限制，数据写入时是什么样，读取时就是什么样。

通过使用二进制安全的SDS，而不是使用C语言字符串，使得Redis不仅可以保存文本数据，也可以保存任意格式的二进制数据。



##### 不会发生缓存区溢出（动态扩容）

C语言的字符串标准库提供的字符串操作函数，大多数（比如strcat追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否够用，当发生了缓冲区溢出就有可能造成程序异常结束。

所以，Redis的SDS结构里引入了alloc和len成员变量，这样SDS API通过`alloc - len`计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。

而且，**当判断出缓冲区大小不够用时，Redis会自动扩大SDS的空间大小，以满足修改所需的大小**。

也就是说，**SDS具备`动态扩容`的功能**。例如一个内容为"hi"的SDS：

<img src=".\images\image-20240725201913887.png" alt="image-20240725201913887" style="zoom: 80%;" /> 

假如说我们要给SDS追加一段字符串",Amy"，这里首先会申请新内存空间：

> * **如果新字符串`小于1MB`，则新空间为`扩展后字符串长度的两倍+1`；**
> * **如果新字符串`大于1MB`，则新空间为`扩展后字符串长度+1MB+1`。**
>
> 这里的+1，是给最后的结束标识\0存放的。

例如，上例追加",Amy"字符串后，新的字符串就是"hi,Amy"，占6个字节，小于1MB，此时申请的字符串长度就是2 * 6 + 1 = 13字节（这里的1是给\0结束标识所使用的），那么此时该SDS的len为6，alloc为12，flags为1（alloc不包含\0字符占用的空间）：

<img src=".\images\image-20240725203245837.png" alt="image-20240725203245837" style="zoom:80%;" />



这种申请新内存空间的流程，就称为**`内存预分配`**，即**实际使用的内存比申请的内存小一些，也就是会多申请一部分内存。**

这也就是SDS中存在两个字段len和alloc的原因，要分别去记录实际占用的内存和申请的全部内存，在第一次申请时也就是没有进行扩容时，len = alloc。

**为什么要给SDS扩容时，要多分配一部分内存呢？**

扩容操作，申请新内存特别消耗资源，如果我们进行扩容时，只申请了我们所需要的内存，在下次操作SDS时，就需要再次去申请新内存，此时就会消耗资源。但是我们在申请新内存时，提前申请多一点的内存给SDS，此时给SDS追加一部分内容，如果SDS空间足够的话，API就会直接使用"未使用空间"，无需再执行内存分配，就可以**`有效地减少了内存的分配次数，从而提高性能`**。



**SDS扩容规则代码如下所示：**

```c
hisds hi_sdsMakeRoomFor(hisds s, size_t addlen)
{
    ... ...
    // s目前的剩余空间已足够，无需扩展，直接返回
    if (avail >= addlen)
        return s;
    //获取目前s的长度
    len = hi_sdslen(s);
    sh = (char *)s - hi_sdsHdrSize(oldtype);
    //扩展之后 s 至少需要的长度
    newlen = (len + addlen);
    //根据新长度，为s分配新空间所需要的大小
    if (newlen < HI_SDS_MAX_PREALLOC)
        //新长度<HI_SDS_MAX_PREALLOC 则分配所需空间*2的空间
        newlen *= 2;
    else
        //否则，分配长度为目前长度+1MB
        newlen += HI_SDS_MAX_PREALLOC;
       ...
}
```

在扩容SDS空间之前，SDS API会优先检查未使用空间是否足够，如果不够的话，API不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的"`未使用空间`"。

所以，使用SDS既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出的问题。





##### 节省内存空间

SDS结构中有个flags成员变量，表示的是SDS类型。

Redis一共设计了5种类型，分别是`sdshdr5`、`sdshdr8`、`sdshdr16`、`sdshdr32`和`sdshdr64`。

这5种类型的主要区别就在于，它们**数据结构中的`len`和`alloc`变量的数据类型不同**。

比如，sdshdr16和sdshdr32这两个类型，它们的定义如下：

```c
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags; 
    char buf[];
};


struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc; 
    unsigned char flags;
    char buf[];
};
```

可以看到：

* sdshdr16类型的len和alloc数据类型都是uint16_t，表示字符数组长度和分配空间大小不能超过2的16次方。
* sdshdr32则都是uint32_t，表示字符数组长度和分配空间大小不能超过2的32次方。

比如：

当我们要去创建一个字节长度在2^8-1以内的字符串时，就会使用sdshdr8的结构，此时len字段和alloc字段只占用1个字节；

当我们要去创建一个字节长度在2^8 ~ 2^16-1范围内的字符串时，就会使用sdshdr16作为底层的数据结构，此时len字段和alloc字段占用2个字节；

...

所以，**SDS设计不同类型的结构，是为了能够灵活地保存不同大小的字符串，从而有效地节省内存空间**。比如，**在保存小字符串时，结构头len和alloc字段占用的空间也比较少**。

并且，我们可以看到在SDS类型的声明中，还使用到了`_attribute_((packed))`，它的作用是：**告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐**。

举个例子，假设下面这个结构体，它有两个成员变量，类型分别是char和int，如下图所示：

```c
#include <stdio.h>

struct test1 {
    char a;
    int b;
 } test1;
 
int main() {
     printf("%lu\n", sizeof(test1));
     return 0;
}
```

这个结构体占用的内存是8个字节：

![img](.\images\35820959e8cf4376391c427ed7f81495.png) 

因为在默认情况下，编译器使用的是`字节对齐`的方式分配内存，虽然char只占用了一个字节，但是由于成员变量中存在int类型，它占用了4个字节，所以在成员变量为char类型分配内存时，会分配4个字节，其中这多余的3个字节是为了字节对齐而分配的，相当于有3个字节被浪费了。

而SDS采用了`_attribute_((packed))`属性定义结构体，这样会按照实际占用的字节数分配内存空间。

比如，使用`_attribute_((packed))`属性定义下面的结构体，同样包含char和int两个类型的成员变量，代码如下所示：

```c
#include <stdio.h>

struct __attribute__((packed)) test2  {
    char a;
    int b;
 } test2;
 
int main() {
     printf("%lu\n", sizeof(test2));
     return 0;
}
```

这个时候，占用的内存空间就是5个字节：

![img](.\images\47e6c8fbc17fd6c89bdfcb5eedaaacff.png) 



可以看得出，SDS是按照实际占用字节数进行分配内存的，这样可以节省内存空间。





> **总结：SDS的优点**
>
> 1. 获取字符串长度的时间复杂度为O(1)
> 2. 支持动态扩容
> 3. 内存预分配，减少内存分配的次数
> 4. 二进制安全的
> 5. 节省内存空间









---

### 3、双向链表

大家最熟悉的结构除了数组以后，就是链表了。

在以前的版本中，Redis的List对象底层实现之一就是链表，C语言本身并没有链表这个数据结构，所以Redis自己设计了一个链表数据结构，就类似于Java中的LinkedList。

#### 节点结构设计

先来看看链表节点结构的设计：

```c
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```

存在前置节点和后置节点，可以看得出，这个是一个双向链表：

![img](.\images\4fecbf7f63c73ec284a4821e0bfe2843.png) 





#### 结构设计

Redis在listNode结构体的基础上，又封装了list这个数据结构，这样操作起来更加方便，链表结构如下：

```c
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```

list结构为链表提供了链表头指针head、链表尾指针tail、链表节点数量len、以及可以自定义实现的dup、free、match函数。

举个例子，下面是由list结构和3个listNode结构组成的链表：

![img](.\images\cadf797496816eb343a19c2451437f1e.png)





#### 优势与缺陷

Redis链表优势如下：

* listNode链表节点的结构里带有prev和next指针，**获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向NULL，所以是无环链表**；
* list结构因为提供了表头指针head和表尾指针tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需要O(1)**;
* list结构因为提供了链表节点数量len，所以**获取链表中节点数量的时间复杂度只需O(1)**；
* listNode链表节点使用void*指针保存节点值，并且可以通过list结构的dup、free、match函数指针节点设置该节点类型特定的函数，因此**链表节点可以保存各种不同类型的值**。

Redis链表也存在着缺陷：

* 链表每个节点之间的内存都是不连续的，意味着**`无法很好利用CPU缓存`**。能够很好利用CPU缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用CPU缓存来加速访问。
* 还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，**`内存开销较大`**。

因此，在Redis 3.2之前，List对象在数据量比较少的情况下，会采用"压缩列表"作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。

不过，压缩列表存在着性能问题，所以在Redis 3.2版本以后设计了新的数据结构quicklist，并将List对象的底层数据结构改为由quicklist实现。









---

### 4、压缩列表ziplist

压缩列表最大的特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅**可以利用CPU缓存**，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地**节省内存开销**。

但是，压缩列表的缺陷也存在：

* **不能保存过多的元素，否则查询效率就会降低；**
* **新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。**

因此，在listpack和quicklist未被使用的版本中，List对象、Hash对象、ZSet对象包含元素数量较少，或者元素值不大的情况下才会使用压缩列表作为底层数据结构。

现在，我们来详细聊一下压缩列表。



#### 结构设计

压缩列表Redis为了节约内存而开发的，它是**`由连续内存块组成的顺序数据结构`**，有点类似于数组。

![img](.\images\ab0b44f557f8b5bc7acb3a53d43ebfcb.png) 

压缩列表在表头有三个字段：

* **`zlbytes`**：记录整个压缩列表占用的内存字节数；
* **`zltail`**：记录压缩列表的尾部节点距离起始地址有多少字节，也就是列表尾的偏移量；
* **`zllen`**：记录压缩列表包含的节点数量；
* **`zlend`**：记录压缩列表的结束点，固定值0xFF（十进制255）。

> 在压缩列表中，如果我们要**查找定位第一个元素和最后一个元素**，可以通过表头三个字段直接定位，**时间复杂度是`O(1)`**。
>
> 而**查找其他元素时，就没有那么高效了，只能逐个查找，此时的复杂度就是`O(N)`了，因此`压缩列表不适合保存过多的元素`。**
>

另外，压缩列表节点（entry）的构成如下：

![img](.\images\a3b1f6235cf0587115b21312fe60289c.png) 

压缩列表节点包含三部分内容：

* **`prevlen`**：记录前一个节点的长度，目的是为了实现从后向前遍历；
* **`encoding`**：记录了当前节点实际数据的类型和长度，类型主要有两种：字符串和整数。
* **`data`**：记录了当前节点的实际数据。

当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的prevlen和encoding这两个元素里保存的信息。

**压缩列表会根据数据大小和类型进行不同的空间大小分配，正是Redis为了节省内存空间而实现的。**

分别说一下，prevlen和encoding是如何根据数据的大小和类型来进行不同的空间大小分配：

**prevlen**

压缩列表里的每个节点的prevlen属性都记录了前一个节点的长度，而且prevlen属性的空间大小跟前一个节点长度值有关：

* 如果**前一个节点的长度小于254字节**，那么prevlen属性需要用**1字节的空间**来保存这个长度值；
* 如果**前一个节点的长度大于等于254字节**，那么prevlen属性需要用**5字节的空间**来保存这个长度值。

**encoding**

encoding属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关，如下图（下图中的content表示的是实际数据，即本文的data字段）：

<img src=".\images\压缩列表编码.png" alt="img" style="zoom:67%;" /> 

* 如果**当前节点的数据是整数**，则encoding会使用**1字节的空间**。通过encoding确认了整数类型，就可以确认整数数据的实际大小了。比如如果encoding编码确认了数据是int16整数，那么data的长度就是int16的大小。
* 如果**当前节点的数据是字符串，根据字符串的长度大小**，encoding会使用**1字节/2字节/5字节的空间**进行编码，encoding编码的前两个bit表示数据的类型，后续的其他bit标识字符串数据的实际长度，即data的长度。





#### 连锁更新问题（:star2:）

压缩列表除了查找复杂度高的问题外，还存在一个问题：

> **压缩列表新增某个元素或者修改某个元素时，如果空间不够，压缩列表占用的内存空间就需要重新分配。而当插入的新元素较大时，可能会导致后续元素的`prevlen`占用空间都发生变化，从而引起`连锁更新`问题，导致每个元素的空间都要重新分配，造成访问压缩列表的性能下降。**

对于这个问题，我们来重现一下：

前面提到，压缩列表节点的prevlen属性会根据前一个节点的长度进行不同的空间大小分配：

* 如果前一个节点的长度小于254字节，那么prevlen属性需要用1字节的空间来保存这个长度值；
* 如果前一个节点的长度大于等于254字节，那么prevlen属性需要用5字节的空间来保存这个长度值。

那么，现在假设一个压缩列表中有多个连续的、长度在250~253之间的节点，如下图所示：

![img](.\images\462c6a65531667f2bcf420953b0aded9.png) 

因为这些节点的长度值都是小于254字节的，所以prevlen属性都是使用1字节空间来保存这个长度值。

此时，如果将一个长度值大于或等于254字节的新节点插入到压缩列表的表头节点，即新节点将成为e1的前置节点，如下图：

<img src=".\images\d1a6deff4672580609c99a5b06bf3429.png" alt="img" style="zoom:67%;" />

因为e1节点的prevlen属性只有1个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重新分配操作，并将e1节点的prevlen属性从原来的1字节大小扩展为5字节大小。

此时，就会发生多米诺骨牌效应，后续所有节点的prevlen都会变为5个字节，每个节点的空间都会重新进行分配：

<img src=".\images\1f0e5ae7ab749078cadda5ba0ed98eac.png" alt="img" style="zoom:67%;" />

e1原本的长度在250~253之间，因为插入了一个长度超过254字节的节点，此时e1的prevlen属性就会变成5字节长度，此时e1的长度就大于等于254字节了，因此原本e2保存e1的prevlen属性也必须从1字节扩展至5字节大小。

正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展，而扩展e3又会引发对e4的扩展...这样会一直持续到结尾。

**这种在特殊情况产生的连续多次空间扩展就叫做连锁更新，连锁更新导致每个元素的内存空间重新分配，影响压缩列表的访问性能。**



#### 压缩列表的优势和缺陷

压缩列表存在着优势：

* **节省内存开销；**
* **元素存放在一块连续的内存空间，可以利用CPU缓存。**

压缩列表也存在着缺陷：

* **查找元素时，时间复杂度为O(N)，效率较低；**
* **保存的元素增加了或者元素变大，会导致内存重新分配，有可能还会发生连锁更新问题。连锁更新一旦发生，就会导致压缩列表占用的内存空间需要多次重新分配，直接影响到压缩列表的访问性能。**

因此，**`压缩列表只会用于保存节点数量不多的场景`**，只要节点数量足够小，即使发生连锁更新，也是可以接收的。

在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2引入）和listpack（Redis 5.0引入），这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表存在的连锁更新问题。







---

### 5、快速列表quicklist

在Redis 3.2之前，List对象的底层数据结构是双向链表或压缩列表，然后在Redis 3.2时，List对象底层改由quicklist数据结构实现。

quicklist，其实就是**`双向链表+压缩列表`**的组合，因为一个quicklist就是一个链表，而链表中的每个元素又都是一个压缩列表。

在前面讲压缩列表时，提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会存在连锁更新的风险，一旦发生，会造成压缩列表性能的下降。

quicklist解决方法：

> **通过控制每个链表节点中压缩列表或者元素个数，来规避连锁更新的风险。因为压缩列表元素越少或者越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。**





#### quicklist结构设计

quicklist的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于quicklist的节点是quicklistNode：

```c
typedef struct quicklist {
    //quicklist的链表头
    quicklistNode *head;      //quicklist的链表头
    //quicklist的链表尾
    quicklistNode *tail; 
    //所有压缩列表中的总元素个数
    unsigned long count;
    //quicklistNodes的个数
    unsigned long len;       
    ...
} quicklist;
```

接下来看看，quicklistNode的结构定义：

```c
typedef struct quicklistNode {
    //前一个quicklistNode
    struct quicklistNode *prev;     //前一个quicklistNode
    //下一个quicklistNode
    struct quicklistNode *next;     //后一个quicklistNode
    //quicklistNode指向的压缩列表
    unsigned char *zl;              
    //压缩列表的的字节大小
    unsigned int sz;                
    //压缩列表的元素个数
    unsigned int count : 16;        //ziplist中的元素个数 
    ....
} quicklistNode;
```

可以看到，quicklistNode结构体里包含了前一个节点和后一个节点的指针，这样每个quicklistNode形成一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以quicklistNode结构体里有一个指向压缩列表的指针`*zl`。

下图就是一个quicklist的数据结构：

![img](.\images\f46cbe347f65ded522f1cc3fd8dba549.png)

当往quicklist中添加一个元素时，不会像普通的链表那样，直接新建一个链表节点，而是去检查插入位置的压缩列表是否能够容纳该元素，如果能容纳就直接保存到quicklistNode结构里的压缩列表，如果不能容纳，才会去新建一个quicklistNode结构，并且将元素存入到新的压缩列表中，让quicklistNode指向这个新的压缩列表中。

quicklist会控制quicklistNode结构里的压缩列表大小或者元素个数，来规避潜在的连锁更新风险，但是这样**`并没有完全解决连锁更新问题`**。



> * 在Redis 7以前，`quicklist = 双向链表 + ziplist；`
>
> * 在Redis 7及以后，`quicklist = 双向链表 + listpack。`





---

### 6、紧凑列表listpack

quicklist虽然通过控制quicklistNode结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新问题。

因为quicklistNode还是用来压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。

于是，在Redis 5.0中新设计了一个数据结构，叫做listpack，目的是替代压缩列表，它最大特点是listpack中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，才会存在连锁更新的隐患。

#### listpack结构设计

listpack采用了压缩列表的很多优秀设计，比如还是使用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack节点会采用不同的编码方式来保存不同大小的数据。

我们来看看listpack结构：

<img src=".\images\4d2dc376b5fd68dae70d9284ae82b73a.png" alt="img" style="zoom:67%;" />

listpack头包含两个元素，分别记录了listpack总字节数和元素个数，然后listpack末尾也有个结尾标识。图中的listpack entry就是listpack的节点了。

每个listpack节点结构如下：

<img src=".\images\c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img" style="zoom:67%;" /> 

主要包含三个方面内容：

* `encoding`：定义该元素的编码类型，会对不同长度的整数和字符串进行编码；
* `data`：实际存放的数据；
* `len`：encoding + data的总长度。

> 可以看到，**listpack没有压缩列表中记录前一个节点长度的字段了，listpack只记录当前节点的长度，当我们向listpack加入一个新的元素时，不会影响到其他节点的字段长度，从而避免出现压缩列表的连锁更新问题。**



**问：压缩列表的entry为什么要保存prevlen呢？listpack改成len之后不会影响功能吗？**

压缩列表的 entry 保存 prevlen 是为了实现节点从后往前遍历，知道前一个节点的长度，就可以计算前一个节点的偏移量。

listpack 一样可以支持从后往前遍历的。详细的算法可以看：https://github.com/antirez/listpack/blob/master/listpack.c 里的`lpDecodeBacklen`函数，`lpDecodeBacklen` 函数就可以从当前列表项起始位置的指针开始，向左逐个字节解析，得到前一项的 entry-len 值。









---

### 7、哈希表hashtable（:star:）

哈希表是一种保存键值对（key-value）的数据结构，如果不懂什么是哈希表，使用Java中的HashMap理解就行。

哈希表中的每一个key都是独一无二的，程序可以根据key查找到与之关联的value，或者通过key来更新value，又或者根据key来删除整个value等等。

在讲压缩列表时，提到过Redis的Hash对象底层实现之一就是压缩列表（最新的Redis代码已经将压缩列表替换成了listpack）。Hash对象的另一个底层实现就是哈希表。

哈希表的优点在于，它能以**O(1)的时间复杂度快速查找数据**。怎么做到的呢？将key通过Hash函数的计算，就能够定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。

但是存在的风险也是有的，在哈希表大小固定的情况下，随着数据不断增多，那么**哈希冲突**的可能性也会越来越高。

解决哈希冲突的方式有很多种，**Redis采用了`链式哈希`来解决哈希冲突**，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接，以便这些数据在表中仍然可以被查询到。





#### 哈希表结构设计

Redis的哈希表结构如下：

```c
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表的长度，也就是哈希桶的个数
    unsigned long size;  
    //哈希表大小掩码，用于计算索引值，总等于size - 1
    unsigned long sizemask;
    //该哈希表已有的节点数量，也就是entry的个数
    //由于链表的存在，entry的个数是有可能超过size大小的
    unsigned long used;
} dictht;
```

可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向哈希表节点（dictEntry）的指针。

![img](.\images\dc495ffeaa3c3d8cb2e12129b3423118.png)

哈希表节点的结构如下：

```c
typedef struct dictEntry {
    //键值对中的键
    void *key;
  
    //键值对中的值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

dictEntry结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针next，这个指针就是用来解决哈希冲突，类似于Java中HashMap出现哈希冲突时，使用单向链表来存放同一个hash值的元素。同样地，这个next指针可以将多个哈希值相同的键值对链接起来，以此来**`解决哈希冲突问题`**，这就是链式哈希。

另外，dictEntry结构里键值对中的值是一个**联合体v**定义的。联合体表示可以是定义中的任何一个类型，也就是类似于Java中的枚举。在上面的联合体v中，表示v可以为四种类型，可以是*val指针，也可以是uint64_t类型，也可以是int64_t类型，也可以是double类型。即，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的64位整数或有符号的64位整数或double类型的值。这么做的好处是可以**`节省内存空间`，因为当值是整数或者浮点数时，就可以将值的数据内嵌在dictEntry结构里，无需再使用一个指针指向实际的值，从而节省了内存空间**。



#### 什么是哈希冲突？

哈希表实际上是一个数组，数组中每一个元素就是一个哈希桶。

**计算存放地址的方式**

当一个键值对的值经过Hash函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果就是该key-value对应的数组元素位置，也就是第几个哈希桶。

**那什么是哈希冲突呢？**

举个例子，有一个可以存放8个哈希桶的哈希表。key1经过哈希函数计算后，再将哈希值 % 8 进行取模计算，结果值为1，那么就对应哈希桶1，类似的，key9和key10分别对应哈希桶1和桶6。

<img src=".\images\753724a072e77d139c926ecf1f049b29.png" alt="img" style="zoom:67%;" /> 

此时，key1和key9对应到了相同的哈希桶中，这就发生了哈希冲突。

因此，当有两个以上数量的key被分配到了哈希表中同一个哈希桶上时，此时就认为这些key发生了哈希冲突。





#### 使用链式哈希解决哈希冲突

链式哈希，也就与Java中HashMap使用链表的方式来解决哈希冲突的方式一样。

**链式哈希是怎么实现的？**

实现的方式就是每个哈希表节点都有一个next指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用next指针构成一个单向链表，**被分配到同一个哈希桶中的多个节点可以用这个单向链表连接起来**，这样就解决了哈希冲突。

还是使用前面哈希冲突的例子，key1和key9经过哈希计算后，都落在同一个哈希桶中，此时就会使用链式哈希，将key1使用next指针指向key9，形成一个单向链表：

![img](.\images\675c23857a36b2dab26ed2e6a7b94b5d.png)

**链式哈希存在着局限性，随着链表长度的增加，在查询这一位置上的数据耗时也会增加，因为链表查询的时间复杂度是`O(n)`**。（所以，在HashMap中，链表中元素达到一定数量后，会将链表转换成红黑树，但是Redis中没有这样实现）

要想解决这一问题，就需要进行`rehash`，也就是对哈希表的大小进行扩展，现在我们来看看Redis是如何实现rehash的。



#### rehash（:star2:）

##### 普通rehash

我们在上一节中，介绍了Redis使用dictht结构体来表示哈希表，不过，在实际使用哈希表时，Redis定义了一个dict结构体，在Redis键值保存流程中也有图示说明该结构体：

![image-20240725085830503](.\images\image-20240725085830503.png) 

这个结构体中，定义了**两个哈希表（ht[2]）**：

```c
typedef struct dict {
    …
    //两个Hash表，交替使用，用于rehash操作
    dictht ht[2]; 
    …
} dict;
```

之所以定义2个哈希表，是因为在进行rehash的时候，需要使用上两个哈希表：

<img src=".\images\2fedbc9cd4cb7236c302d695686dd478.png" alt="img" style="zoom:67%;" /> 

在正常服务请求阶段，插入的数据，都会写入到`哈希表1`，此时的`哈希表2`并没有被分配空间。

随着数据逐步增多，触发了rehash操作，这个过程分为三步：

1. 给哈希表2分配空间，一般是哈希表1的两倍；
2. 将哈希表1的数据迁移到数据表2中；
3. 迁移完成后，哈希表1的空间会被释放，并把哈希表2设置为哈希表1，然后在哈希表2新创建一个空的哈希表，为下次rehash做准备。

为了方便理解，将上面三个过程画在了下面这张图中：

![img](.\images\cabce0ce7e320bc9d9b5bde947b6811b.png) 

这个过程看起来简单，但是存在一个问题：

**如果哈希表1的数据量非常大，那么在迁移至哈希表2的时候，会涉及大量的数据拷贝，此时可能会对Redis造成阻塞，无法服务其他请求。**



##### 渐进式rehash

为了避免rehash在数据迁移过程中，因拷贝数据的耗时，影响Redis的性能，所以Redis采用了渐进式rehash，也就是数据迁移的过程不再是一次性完成，而是分多次进行迁移。

**渐进式rehash步骤如下所示：**

> * `给哈希表2分配空间；`
> * `在rehash进行期间，每次对哈希表进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作以外，还会按照顺序将哈希表1中索引位置上所有的key-value迁移到哈希表2中；`
> * `随着处理客户端发起的哈希表操作请求数量越多，最终某个时间点会把哈希表1的所有key-value都迁移到哈希表2，从而完成rehash操作。`

这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求过程中，避免了一次性rehash的耗时操作。

**注意：**

* **在进行渐进式rehash操作的过程中，数据分别存放在两个哈希表中，所以在渐进式rehash进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表中进行。**

  比如，去查找一个key的值的话，会先去哈希表1中进行查找，如果没有找到，再去哈希表2中进行查找。

* **在渐进式rehash进行期间，新增一个key-value时，会被保存到哈希表2中，而哈希表1则不再进行任何添加操作，这样保证了哈希表1的key-value数量只会减少，随着rehash操作的完成，最终哈希表1就会变成空表。**



##### rehash触发条件

rehash的触发条件跟`负载因子（load factor）`有关。

Redis负载因子的计算公式如下：

![img](.\images\85f597f7851b90d6c78bb0d8e39690fc.png)

也就是使用dictht结构中的used属性 / size属性：

> **`loadFactor = used / size`**

used属性表示哈希表中已有的节点数量，size表示哈希表的大小，也就是桶的数量。

触发rehash操作的条件，主要有两个：

> * **当`负载因子大于等于1`时，在Redis没有执行bgsave命令或者bgrewriteaof命令，也就是没有执行RDB快照或者AOF重写的时候，就会进行rehash操作**。
> * **当`负载因子大于等于5`时，此时说明哈希冲突非常严重了，不管有没有在执行RDB快照或AOF重写，都会强制进行rehash操作。**







---

### 8、整数集合intset

整数集合是Set对象的底层实现之一，**当一个`Set对象中只包含整数值元素，并且元素数量不大于512时`，就会使用整数集合这个数据结构作为底层实现。**

**特征：**

1. 长度可变
2. 有序
3. 元素唯一



#### 整数集合结构设计

整数集合本质上是一块连续内存空间，它的结构定义如下：

```c
typedef struct intset {
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
} intset;
```

可以看到，保存元素的容器是一个contents数组，虽然contents被声明成int8_t类型的数组，但是实际上**contents[]数组并不保存任何int8_t类型的元素，contents数组的真正类型取决于intset结构体里encoding属性的值**。比如：

- 如果 encoding 属性值为 `INTSET_ENC_INT16`，那么 contents 就是一个 `int16_t` 类型的数组，数组中每一个元素的类型都是 `int16_t`，范围类似于Java的short，存入的整数数值大小范围在`-2^15 ~ 2^15-1`都会使用该属性值；
- 如果 encoding 属性值为 `INTSET_ENC_INT32`，那么 contents 就是一个 `int32_t` 类型的数组，数组中每一个元素的类型都是 `int32_t`，范围类似于Java的int，存入的整数数值大小范围在`-2^31 ~ 2^31-1`都会使用该属性值。
- 如果 encoding 属性值为 `INTSET_ENC_INT64`，那么 contents 就是一个 `int64_t` 类型的数组，数组中每一个元素的类型都是 `int64_t`，范围类似于Java的long，存入的整数数值大小范围在`-2^63 ~ 2^63-1`都会使用该属性值。

不同类型的contents数组，意味着数组的大小也会不同。**encoding属性的值决定了整数数组中每个元素的大小，而不是由contents[]数组的类型int8_t来决定的**。

案例：

为了方便查找，Redis会将intset中所有的整数**按照`升序`进行排序**，依次保存在contents数组中，结构如图所示：

![image-20240725214905149](.\images\image-20240725214905149.png) 

在上例中，由于intset中的元素是5、10、20，数值大小在-2^15 ~ 2^15-1范围内，此时encoding属性使用的是INTSET_ENC_INT16，那么此时contents[]数组中国每个元素的类型名都是int16_t，类似于Java中的short，也就是每个元素都占用2个字节。每部分占用的字节数为：

* encoding：4个字节（uint32_t表示使用32位的无符号bit来表示该属性值，也就是4个字节）；
* length：4个字节；
* contents：2字节 * 3 = 6字节。





#### 整数集合的升级操作（:star:）

整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展contents数组的空间大小，然后才能将新元素加入到整数集合中，当然升级的过程中，也要维持整数集合的有序性。

整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后再将每个元素按照间隔类型大小分割，如果encoding属性为INTSET_ENC_INT16，则每个元素的间隔就是16位。

举个例子，假设有一个整数集合里有3个类型为int16_t的元素。

![img](.\images\5dbdfa7cfbdd1d12a4d9458c6c90d472.png) 

现在，往这个整数集合中加入一个新元素65535，超过了int16_t的范围（-2^15 ~ 2^15-1），这个新元素需要int32_t类型来保存，此时整数集合要进行升级操作。

**升级操作的流程如下**：

> 1. 升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式及元素个数扩容数组；
> 2. 倒序依次将数组中的元素拷贝到扩容后的正确位置；（如果使用顺序的话，前面扩容后可能会将原位置的数据进行覆盖）
> 3. 将待添加的元素加入到数组末尾；
> 4. 最后，将intset的encoding属性修改为INTSET_ENC_INT32，将length属性修改为4。



那么对于上面的案例，实际的升级流程如下所示：

首先需要为contents数组扩容，**在原本空间的大小之上再扩容多80位（4x32 - 3x16 = 80），这样就能够确保存下4个类型为int32_t的元素**。

![img](.\images\e2e3e19fc934e70563fbdfde2af39a2b.png) 

扩容完contents数组空间大小后，需要将之前的三个元素转换为int32_t类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：

![img](.\images\e84b052381e240eeb8cc97d6b729968b.png)

最后，会将该intset对象的length属性修改为4，表示实际存储了4个元素；encoding属性修改为INTSET_ENC_INT32，表示数组中的每个元素都是int32_t类型，也就是使用了4个字节来存储整数数据。



> **整数集合升级有什么好处呢？**

如果要让一个数组同时保存int16_t、int32_t、int64_t类型的元素，最简单的做法是直接使用int64_t类型的数组。不过这样的话，当元素都是int16_t类型的话，就会造成内存的浪费。

整数集合升级就能够避免出现这种情况，如果一直向整数集合添加int16_t类型的元素，那么整数集合的底层实现就一直是用int16_t类型的数组，只有在我们将int32_t类型或者int64_t类型的元素添加到集合中时，才会对数组进行升级操作。

因此，整数集合升级的好处是**`节省内存资源`**。



> **整数集合支持降级操作吗？**

**`不支持降级操作`**，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了65535元素，整数集合的数组还是int32_t类型的，不会因此降级成为int16_t类型。





**总结：**

1. Redis会确保IntSet中元素的唯一性、有序性
2. 具备类型升级机制，可以节省内存空间
3. 底层采用二分查找方式来进行查询





---

### 9、跳表skiplist（:star:）

#### 理解跳表

下图是一个简单的**有序单链表**，单链表的特性就是每个元素存放下一个元素的引用。即：通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。

![img](.\images\webp) 

现在有一个场景，想要快速找到上图表中10这个元素，只能从头开始遍历链表，直到我们找到需要找的元素。查找路径：1、3、4、5、7、8、9、10。这样的查找效率很低，平均时间复杂度是O(n)。那有没有办法提高链表的查找速度呢？如下图所示，我们从链表中每两个元素抽出去，加**一级索引**，一级索引指向了原始链表，即：通过一级索引7的down指针可以找到原始链表的7。那现在怎么查找10这个元素呢？

![img](.\images\2347989237.png)

先在索引找1、4、7、9，遍历到一级索引的9时，发现9的后继节点是13，比10大，于是不往后找了，而是通过9找到原始链表的9，然后再往后遍历找到我们要找的10，遍历结束。有没有发现，加了一级索引后，查找路径：1、4、7、9、10，查找节点需要遍历的元素相对少了，我们不需要对10之前的所有数据都遍历，查找的效率提升了。

那如果加二级索引呢？如下图所示，查找路径：1、7、9、10。是不是找10的效率更高了？这就是跳表的思想，用"空间换时间"，通过给链表建立索引，提高查找的效率。

![img](.\images\478923784932.png) 

可能同学们会想，从上面案例来看，提升的效率并不明显，本来要遍历8个元素，优化了半天，还需要遍历4个元素，其实是因为我们的数据量太少了，当数据量足够大时，效率提升会很大。如下图所示，假如有序单链表现在有1万个元素，分别是0~9999。现在我们建了很多级索引，最高级的索引，就两个元素0、5000，次高级索引四个元素0、2500、5000、7500，依次类推，当我们要去查找7890这个元素时，查找路径为0、5000、7500...7890，通过最高级索引直接跳过了5000个元素，次高级索引直接跳过了2500个元素，**从而使得链表能够实现二分查找**。由此可以看出，当元素数量较多时，索引提高的效率比较大，近似于二分查找。

![img](.\images\742378492389.png)

到这里大家应该已经明白了什么是跳表。**`跳表是可以实现二分查找的有序链表。`**

Redis只有ZSet对象的底层实现用到了跳表，跳表的优势是能**支持时间复杂度平均为`O(logN)`的节点查找**。

ZSet结构体里有两个数据结构：一个是跳表，一个是哈希表。这样做的好处是技能进行高效地范围查询，也能进行高效地单点查询。

```c
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```

ZSet对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新响应的数据，从而保证了跳表和哈希表中记录的信息一致。

ZSet对象能支持范围查询（如ZRANGEBYSCORE操作），这是因为它的数据结构采用了跳表，而又能以常数复杂度获取元素权重（如ZSCORE操作），这是因为它同时采用了哈希表进行索引。

可能很多人奇怪，为什么我说ZSET对象底层数据结构是listpack或者跳表，而没有说哈希表呢？

ZSET对象在使用跳表作为数据结构的时候，是使用由`哈希表+跳表`组成的struct zset，但是我们讨论的时候，都会说跳表是ZSet对象的底层数据结构，而不会提及哈希表，是因为struct zet中的哈希表只是用于获取元素权重的操作，该操作的时间复杂度是O(1)，大部分操作都是使用跳表来完成的。

那么，我们接下来详细地说说跳表。





#### 跳表结构设计

普通链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)。如果链表的元素非常多，此时要想去获取其中某一个元素时，就需要去遍历很多次，查询的性能就比较差。

为什么链表的查询性能慢？

原因就在于链表指针的跨度是1，也就是说每一个节点指向的都是下一个节点，那么我们在遍历时，就不得不先遍历到下一个节点，再遍历到下下一个节点，直到找到我们想要的节点，因此查询的效率就比较慢。

因此，如果我们想要去提升链表查询的效率，就不得不提升节点指针的跨度，也就是说如果我们从1号节点直接跳到后面的节点进行查询，那么查询性能就能够大大提升。这就是跳表名称的由来。

**跳表是在链表基础上进行改进得到的，实现了一种`多层`的有序链表**，这样做的好处是能够快速定位数据。

**skiplist（跳表）**首先是一个链表，但与传统链表相比有几点差距：

* 元素按照升序排列存储；
* 节点可能包含多个指针，指针跨度不同。

那跳表张什么样子呢？我们这里举一个例子，下图展示了一个层级为3的跳表：

![img](.\images\2ae0ed790c7e7403f215acb2bd82e884.png) 

图中头节点有L0~L2三个指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：

* L0层级共有5个节点，分别是节点1、2、3、4、5；
* L1层级共有3个节点，分别是节点2、3、5；
* L2层级只有1个节点，也就是节点3。

如果我们要在链表中，查找节点4这个元素，只能从头开始遍历链表，需要查找4次。而使用了跳表后，只需要查找2次就能够定位到节点4，因为可以从头节点直接从L2层级跳到节点3，然后再往前遍历找到节点4。

可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。

> **当数据很大时，跳表查找的时间复杂度是`O(logN)`**。

那跳表节点是如何实现多层级的呢？这就需要看跳表的数据结构了，如下所示：

**跳表本身结构**

```c
typedef struct zskiplist {
    //头尾节点
    struct zskiplistNode *header, *tail;
    
    //节点数量
    unsigned long length;
    
    //最大的索引层级，默认是1
    int level;
} zskiplist;
```





**跳表中节点的结构**

```c
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    
    //元素权重值
    double score;
    
    //后向指针，指向前一个节点
    struct zskiplistNode *backward;
  
    //节点的level数组
    //数组中的每一个元素，保存都是每一个level级别下每层的前向指针和跨度，也就是保存该节点在该对应级别的下一个节点
    struct zskiplistLevel {
        //*forward也就是当前级别下的下一个节点
        struct zskiplistNode *forward;
        //span表示的是跨度
        unsigned long span;
    } level[];
} zskiplistNode;
```

ZSet对象要同时保存元素和元素的权重，对应到跳表节点结构里就是SDS类型的ele变量和double类型的score变量。

每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时比较方便。

**跳表是一个带有层级关系的链表，而且每一个层级可以包含多个节点，每个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的`level[]数组`。**

level数组中的每一个元素都代表了当前节点所能够指向的跳表的一层。比如`level[0]`就表示第一层，`level[1]`就表示第二层。每一个元素的结构体中，又定义了`当前级别下指向下一个跳表节点的指针`和`跨度`。

比如，下面这一张图：

![img](.\images\3层跳表-跨度.png)

比如对于上面的3号节点来说，它其中的level数组就包含了三个元素：level[0]、level[1]和level[2]。level[0]中`*forward`指向的是4号节点，span为1；level[1]中`*forward`指向的是5号节点，span为2；level[2]中`*forward`指向的是NULL，span为3。

第一眼看到跨度的时候，以为和遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针*forward即可了。**`跨度实际上是用来计算这个节点在跳表中的排名的`**。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点到该节点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排名。

举个例子，查找图中节点3在跳表中的排名，从头节点开始查找节点3，查找的过程只经过一个层（L2），并且层的跨度是3，所以节点3在跳表中的排位是3。

另外，图中的头节点其实也是zskiplistNode跳表节点，只不过头节点的后续指针、权重、元素值都没有用到，所以图中省略了这部分。



> **skiplist的特点：**
>
> * 跳跃表是一个双向链表，每个节点都包含score和ele值；
> * 节点按照score值排序，score值一样则按照ele字典排序；
> * 每个节点都可以包含多层指针，层数是1到32之间的随机数；
> * 不同层指针到下一个节点的跨度不同，层级越高，跨度越大；
> * 增删改查效率与红黑树基本一致，实现却更简单。







#### 查找的时间复杂度

既然跳表可以提升链表查找元素的效率，那查找一个元素的时间复杂度到底是多少呢？查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。

所以，**`时间复杂度 = 索引的高度 * 每层索引遍历元素的个数`**

先来求跳表的索引高度。如下图所示，假设每两个节点会抽出一个节点作为上一级索引的节点，原始的链表有n个元素，则一级索引有n/2个元素、二级索引有n/4个元素、k级索引就有n/(2^k）个元素。最高级索引一般有2个元素，即：最高级索引h满足2 = n/(2^h)，即 h = log2n - 1，最高级索引h为索引层的高度加上原始数据一层，跳表的总高度 **`h = log2n`**。

![img](.\images\719824891238.png)

我们看上图中加粗的箭头，表示查找元素u的路径，那查找过程中每一层索引最多遍历几个元素呢？

图中所示，现在到达第k级索引，我们发现要查找的元素u比y大比z小，所以，我们需要从y处下降到k-1级索引继续查找，k-1级索引中比y大比z小的只有一个w，所以在k-1级索引中，我们遍历的元素最多就是y、w、z，发现u比w大比z小之后，再下降到k-2级索引。所以，k-2级索引最多遍历的元素为w、u、z。其实每级索引都是类似的道理，每级索引中都是两个节点抽出一个节点作为上一级索引的节点。现在我们得出结论：当每级索引都是两个节点抽出一个节点作为上一级索引的节点时，每一次层最多遍历3个节点。

**跳表的索引高度h = log2n，且每层索引最多遍历3个元素。所以跳表中查找一个元素的时间复杂度为O(3*logn)，省略常数即：`O(logn)`**。





#### 查询元素过程

> **查找一个跳表节点的过程时，跳表会从`头节点的最高层`开始，逐一遍历每一层。**在遍历某一层的跳表节点时，会用跳表节点中的SDS类型的元素和元素的权重来进行判断，共有两个判断条件：
>
> * **如果当前节点的权重`小于`要查找的权重时，跳表就会访问该层上的下一个节点。**
> * **如果当前节点的权重`等于`要查找的权重时，并且当前节点的SDS类型数据`小于`要查找的数据时，跳表就会访问该层上的下一个节点。**
>
> 如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的level数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。

由于跳表会将元素按照ele和score的值进行排序，先按照score值进行排序，如果一样再按照ele进行排序。

说明：

当我们去查找一个元素时，会先去头节点的最高层开始遍历，遍历第一个元素，判断与我们要查找的元素的ele和score值是否相同，如果都相同，则直接返回；

如果遍历元素的score值小于要查找元素的score值，则访问该层的下一个节点；

如果遍历元素的score值与要查找元素的socre值相同，则继续判断元素的ele与要查找元素的ele是否相同，如果小于要查找元素的ele值，则继续访问该层的下一个节点；

如果上述条件均不满足，说明遍历到的该元素大于要查找的元素，此时就会回到上一个节点的下一层level，继续查找。



**举个例子**，下图有3层级的跳表：

![img](.\images\3层跳表-跨度.drawio.png)

如果要查找：[`元素abcd，权重4`]的节点，查找的过程是这样的：

* 先从头节点的最高层开始，L2指向了[元素abc，权重3]的节点，这个节点的权重比要查找的节点小，所以要访问该层上的下一个节点；
* 但是该层的下一个节点是空节点（level[2]指向的是空节点），于是就会跳到[元素abc，权重3]节点的下一层去找，也就是level[1]；
* [元素abc，权重3]节点的level[1]的下一个指针指向了[元素abcde，权重4]的节点，然后将其和要查找的节点比较。虽然[元素abcde，权重4]的节点的权重和要查找权重相同，但是当前节点的SDS类型的元素值大于要查找的元素，此时就会跳回到[元素abc,权重3]节点的下一个level层级查找，也就是level[0]。
* [元素abc，权重3]节点的level[0]下一个指针指向了[元素abcd, 权重4]的节点，该节点正是我们要查找的节点，查询结束。





#### 空间复杂度

跳表通过建立索引，来提高查找元素的效率，就是典型的"空间换时间"的思想，所以空间上做出了一些牺牲，那空间复杂度到底是多少呢？

假如原始链表包含n个元素，则一级索引元素个数为n/2、二级索引元素个数为n/4、三级索引元素个数为n/8，以此类推。所以，索引节点的总数是：n/2 + n/4 + n/8 + ... + 8 + 4 + 2 = n-2，**空间复杂度是`O(n)`**。

如下图所示：如果每三个节点抽一个节点作为索引，索引总和数就是n/3 + n/9 + n/27 + ... + 9 + 3 + 1 = n / 2，减少了一半。所以我们可以通过较少索引数来减少空间复杂度，但是相应的肯定会造成查找效率有一定下降，我们可以根据应用场景来控制这个阈值，看我们更加注重时间还是空间。

![img](.\images\489237498273.png)

但是，索引节点往往只需要存储key和几个指针，并不需要存储完整的对象，所以当对象比索引节点大很多时，索引占用的额外空间就可以忽略了。举个例子：我们现在需要用跳表来给所有学生建立索引，学生有很多属性，包括：学号、性别、姓名、身份证号等等。学生的各种属性只需要在原始链表中存储一份即可，我们只需要用学生的学号建立索引，所以索引相对原始数据而言，占用的空间可以忽略。







---

#### 插入元素

**插入索引的大致过程**

插入数据看起来也很简单，跳表的是有序的，所以我们会像查找元素一样，找到元素应该插入的位置。

如下图所示，要插入数据6，整个过程类似于查找6，整个查找的路径为1、1、1、4、4、5。查找到底层原始链表的元素5时，发现5小于6但是后继节点7大于6，所以应该把6插入到5之后7之前。整个时间复杂度为查找元素的时间复杂度O(logn)。

<img src=".\images\4978327849.png" alt="img" style="zoom:67%;" />



**如何更新索引？**

如下图所示，假如一直往原始链表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，在这种极端情况下，跳表退化成了单向链表，从而使得查询效率从O(logn)退化为O(n)。

<img src=".\images\78939817283.png" alt="img" style="zoom:50%;" /> 

那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？

比较容易理解的做法就是完全重建索引，我们每次插入数据后，都把这个跳表的索引删除全部重建，重建索引的时间复杂度是多少呢？因为索引的空间复杂度是O(n)，即：索引节点的个数是O(n)级别，每次完全重新建一个O(n)级别的索引，时间复杂度也是O(n)。造成的后果是：为了维护索引，导致每次插入数据的时间复杂度变成了O(n)。

那有没有其他效率比较高的方式来维护索引呢？

**跳表的相邻索引节点数量比例会影响跳表的查询性能。**

比如跳表每一层的晋升概率是1/2，最理想的索引就是在原始链表中每隔一个元素抽取一个元素作为一级索引。换种说法，**我们在原始链表中随机的选取n/2个元素作为一级索引是不是也能通过索引提高查找的效率呢？**

当然可以，因为一般随机选的元素相对来说比较均匀的，如下图所示：

<img src=".\images\381290839012.png" alt="img" style="zoom:50%;" /> 

随机选择了n/2个元素作为一级索引，虽然不是每隔一个元素抽取一个，但是对于查找效率来讲，影响不大，比如我们想找元素16，仍然可以通过一级索引，使得遍历路径减少了将近一半。如果抽取的一级索引的元素恰好是前一半的元素1、3、4、5、7、8，那么查找的效率确实没有提升，但是这样的概率太小了。我们可以认为：**当原始链表中元素数量足够大时，且抽取足够随机的话，我们得到的索引是均匀的。**我们要清楚设计良好的数据结构是为了应对大数据量的场景，如果原设计链表只有5个元素，那么依次遍历5个元素也没有关系，因为数据量太少了。

> **`跳表的相邻两层索引的节点数量最理想的比例是2:1，查找复杂度可以降低到O(logn)。`**

下图的跳表就是相邻两层索引的节点数量比例就是2:1：

![img](.\images\cdc14698f629c74bf5a239cc8a611aeb.png) 

**那怎样才能维持两层的节点数量比例是2:1呢？**

我们可以维护这样一个索引：**随机选n/2个元素作为一级索引、随机选n/4个元素作为二级索引、随机选n/8个元素作为三级索引，依次类推，一直到最顶层索引。**这里每层索引的元素个数可以确定，且每层索引元素选取的足够随机，所以可以通过索引来提高跳表的查询效率。

那代码该如何实现，才能使跳表满足上述这个样子呢？

可以在每次新插入数据的时候，尽量让该元素有1/2的概率建立一级索引、1/4的几率建立二级索引、1/8的几率建立三级索引，以此类推，就能满足我们上面的条件。现在我们就需要一个概率算法帮助我们把控这个1/2、1/4、1/8...，**当每次有数据插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中，然后开始维护索引并把数据插入到原始链表中**。

下面开始讲解这个概率算法代码如何实现。

我们可以实现一个`randomLevel()`方法，该方法会随机生成一个`1 ~ MAX_LEVEL`之间的数据（MAX_LEVEL表示索引的最高层数，Redis 7.0之前是64，Redis 7.0之后是32），且该方法有**`1/2概率返回1、1/4的概率返回2、1/8的概率返回3`**，以此类推。

* `randomLevel()`方法返回1表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率1/2）
* `randomLevel()`方法返回2表示当前插入的该元素需要建一级索引（概率1/4）
* `randomLevel()`方法返回3表示当前插入的该元素需要建二级索引（概率1/8）
* `randomLevel()`方法返回4表示当前插入的该元素需要建三级索引（概率1/16）
* ...

所以，通过randomLevel()方法，我们可以控制整个跳表各级索引中元素的个数。

这里有一个问题：

randomLevel()方法返回2的时候会建立一级索引，我们想要一级索引中元素个数占原始数据的1/2，但是randomLevel()方法返回2的概念为1/4，那这样是不是存在矛盾呢？明明说好的1/2，一级索引元素个数怎么变成了原始链表的1/4？我们来看下图，就应该明白了：

<img src=".\images\482903849023.png" alt="img" style="zoom:50%;" /> 

比如我们要去插入一个元素6，randomLevel()方法返回1，则我们不会为6建立索引。插入元素7，此时randomLevel()方法返回3，所以我们需要为7建立二级索引。这里我们发现一个特点：当建立二级索引的时候，同时也会建立一个一级索引，当建立三级索引时，同时也会建立一级和二级索引。

所以：一级索引中元素的个数等于：`原始链表元素个数 * (randomLevel()返回值 > 1的概念)`。因为randomLevel()方法返回值大于1，就会去建立索引，所有建立的索引，无论是第几级的索引，都必然会去创建一个一级索引。所以：**一级索引中元素个数占原始数据个数的比率为randomLevel()方法返回值大于1的概率**。那randomLevel()方法返回值大于1的概率是多少呢？因为randomLevel()方法随机生成1~MAX_LEVEL的数字，且rrandomLevel()方法返回值为1的概率为1/2，则randomLevel()方法返回值大于1的概率为1 - 1/2 = 1/2。即通过上述流程，我们可以发现**`一级索引中元素个数占所有数据个数的1/2`。**



同理，当randomLevel()方法返回值 > 2时，会建立二级或二级以上索引，都会在二级索引中增加元素，因此**二级索引中元素个数占原始数据的比率为randomLevel()方法返回值 > 2的概率**。randomLevel()方法返回值大于2的概率为1 - (randomLevel()为1的概率 + randomLevel()为2的概率），即1 - 1/2 - 1/4 = 1/4，由此我们可以得知：**`二级索引中元素个数占原始数据的1/4`**。



以此类推，可以得出随机算法遵循以下两个条件：

> 在插入元素时，会使用`randomLevel()`方法去随机生成一个值，根据这个值去判断该元素是否建立索引以及建立几层索引。
>
> * `randomLevel()`方法，随机生成`1 ~ MAX_LEVEL`之间的数（MAX_LEVEL表示索引的最高层数，Redis 7.0之前是64，Redis 7.0是32），有1/2的概率返回1、1/4的概率返回2、1/8的概率返回3...
> * `randomLevel()`方法返回1时该元素不建立索引、返回2为该元素建立一级索引、返回3时为该元素建立二级索引...
>
> 就可以满足我们想要的结果，即：**一级索引中元素个数应该占全部数据的1/2，二级索引中元素个数应该占全部数据的1/4，三级元素中元素个数占全部数据的1/8，以此类推**。



**插入案例**

我们来通过一个例子来描述一下跳表插入数据的全流程：

如下图所示，现在我们要插入数据6到跳表中，首先randomLevel()返回3，表示需要建立二级索引。即：需要在一级索引和二级索引中添加元素6。

流程：

类似于查询的流程，插入时会从头节点的最高层开始，该跳表目前最高是三级索引，所以首先找到三级索引的1，发现6比1大然后比13小，所以从1下沉到二级索引。

<img src=".\images\4237987498123.png" alt="img" style="zoom:50%;" /> 

下沉到二级索引后，发现6比1大比7小，此时插入的6元素在二级索引中1和7之间加一个元素6，并从元素1继续下沉到一级索引：

<img src=".\images\42314123.png" alt="img" style="zoom:50%;" /> 

下沉到一级索引后，发现6比1大比4大，所以继续往后遍历，发现6比4大比7小，此时就需要在一级索引中的4和7之间加一个元素6。然后，从4继续下沉到原始链表：

<img src=".\images\74823789432.png" alt="img" style="zoom:50%;" /> 

下沉到原始链表后，发现4、5比6小，7比6大，所以将6插入到5和7之间即可，整个插入过程结束。

<img src=".\images\3249708127893487.png" alt="img" style="zoom:50%;" /> 

整个插入过程与查找元素类似，每层索引插入元素的时间复杂度是O(1)，所以整个插入的时间复杂度是O(logn)。







---

#### 删除元素

跳表删除数据时，要把索引中对应节点也要删除，如下图所示，如果要删除元素9，需要把原始链表中的9和第一级索引的9删除：

<img src=".\images\4237894789.png" alt="img" style="zoom:50%;" /> 

跳表中，删除元素的时间复杂度是多少？

删除元素的过程跟查找元素的过程类似，只不过在查找的路径上发现了要删除的元素，就执行删除操作。

跳表中，每一层索引其实就是一个有序的单链表，单链表删除元素的时间复杂度是O(1)，索引层数为logn表示最多需要删除logn个元素，所以删除元素的总时间包含`查找元素的时间 + 删除logn个元素的时间`为O(logn) + O(logn) = 2O(logn)，忽略常数部分，**删除元素的时间复杂度为`O(logn)`**。









---

#### 为什么使用跳表而不使用平衡树？

常见的面试题：为什么ZSet实现使用跳表而不使用平衡树（如AVL树、红黑树）？

对于这个问题，Redis的作者是这样说的：

```
There are a few reasons:

They are not very memory intensive. It's up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.

A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.

They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.
```

简单翻译一下，主要是从内存占用、对范围查找的支持、实现难易程度这三个方面总结原因：

> * **从内存占用上来比较，跳表比平衡树更灵活一些**。平衡树每个节点包含两个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。
> * **`在做范围查找的时候，跳表比平衡树操作更简单`**。ZSet拥有查找指定范围的元素，如果使用平衡树来实现的话，找到指定范围的小值以后，还要以中序遍历的顺序继续寻找不超过大值的节点，如果不对平衡树进行改造，中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值以后，对第一层链表进行若干遍历就可以实现了。
> * **`从算法实现难度上来比较，跳表比平衡树要简单得多。`**平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。











---


## 各种数据类型的编码（:star:）

### String

String类型的底层数据结构是**`int`和`SDS`（简单动态字符串）**。

字符串对象的内部编码（encoding）有三种：**`int`**、**`embstr`**和**`raw`**，这三种编码类对象所对应的数据结构是：

![img](.\images\string结构.png)



**int**

如果一个字符串对象保存的是整数值，并且这个整数值可以使用`long`类型来表示，即存入的正数满足下面的要求：

* long数据类型是64位、有符号的以二进制补码表示的整数

* 最小值是-2^63

* 最大值是2^63-1

  （数字最多有19位）

那么字符串对象会将整数值直接保存在字符串对象结构的`ptr`属性中（将void*类型转换成long类型），而不是使用指针去指向一段内存空间，并将字符串编码设置为`int`。

此时，就不需要SDS数据结构了，直接将数据保存在ptr属性中。

![image-20240725205117593](.\images\image-20240725205117593.png)  

**注意：`只有整数才会使用int`，如果是浮点数，Redis内部其实先将浮点数转化成字符串值，然后再保存。**

案例：

<img src=".\images\image-20240724160602909.png" alt="image-20240724160602909" style="zoom: 80%;" />  

当我们存入的是普通的整数型数据时，在long类型数据的范围内时，此时底层是使用long数据进行存储的，编码方式是int；如果存入的数据超出了long类型数据的范围，比如上例长度大于等于20的整数，此时由于long类型无法存储这么大的数据，那么就会将该数字转换成字符串类型，使用SDS的数据类型存储，编码方式变为了embstr（长度小于44字节）或者raw（长度大于等于44字节）。





**embstr**

如果字符串对象保存的是一个字符串，并且这个**字符串的长度`小于44字节`**，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串数据，并且将**对象的编码格式设置为`embstr`**，`embstr`编码是专门用于保存短字符串的一种优化编码方式：

![image-20240725205220572](.\images\image-20240725205220572.png)

可以看到，embstr类型的对象将redisObject对象和SDS数据对象存放在一个连续的内存空间里。



**raw**

如果字符串对象保存的是一个字符串，并且这个**字符串的长度`大于44字节`**时，那么字符串对象将使用一个简单动态字符串（SDS）来保存，并将该对象的**编码设置为`raw`**：

![image-20240725205313296](.\images\image-20240725205313296.png) 

可以看到，raw类型的string对象是将redisObject对象和SDS对象数据存放在不同的内存空间中。



即：

embstr和raw编码都会使用SDS来保存值，但不同之处在于：

`embstr`会通过一次内存分配函数来分配**一块连续的内存空间**来保存`redisObject`和`SDS`；

而`raw`编码会通过调用两次内存分配函数来分别**分配两块空间保存**`redisObject`和`SDS`。

embstr这样做有很多**好处**：

* embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次，**`效率更高`**。
* 释放embstr编码的字符串对象同样只需要调用一次内存释放函数；
* 因为embstr编码的字符串对象所有数据都保存在一块连续的内存里，可以**`更好地利用CPU缓存提升性能`**。

但是，embstr也存在着**缺点**：

* 如果字符串的长度增加需要重新分配内存时，整个redisObject和SDS都需要重新分配空间，所以，**`embstr编码的字符串对象实际上是只读的`**，redis没有为embstr编码的字符串对象编写任何响应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令时（如append），程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。



案例1：

<img src=".\images\image-20240724160941893.png" alt="image-20240724160941893" style="zoom:67%;" /> 

当我们存入的数据是小于44字节长度的字符串时，此时redisObject的编码方式是embstr；如果我们存入的数据是大于等于44字节长度的字符串时，此时redisObject的编码方式变为了raw。



案例2：

![image-20240724162227821](.\images\image-20240724162227821.png) 

对于embstr来说，它是只读的，如果对embstr对象进行修改时，比如使用APPEND命令进行添加，那么会将embstr先转换成raw，然后再进行修改。此时，无论字符串的长度是否达到了44字节，字符编码都是raw。





**总结**

* 只有整数才会使用int，如果是浮点数，Redis内部其实先将浮点数转换成字符串值，然后再保存；
* embstr与raw类型底层的数据结构其实都是SDS（简单动态字符串，Redis内部定义sdshdr一种结构）。

**三者的区别如下：**

| 编码类型     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| **`int`**    | 存入Long类型整数时，redisObject中的ptr指针直接赋值为整数数据，不再额外的指向整数了，节省了指针的空间开销。 |
| **`embstr`** | 当保存的是字符串数据且字符串小于等于44字节时，embstr类型将会调用内存分配函数，**只分配一块连续的内存空间**，空间中依次包含redisObject和SDS两个数据结构，让元数据、指针和SDS是一块连续的内存空间，这样就可以避免内存碎片。 |
| **`raw`**    | 当字符串大于44字节时，SDS的数量变多变大了，SDS和RedisObject布局分开，会给SDS分配多的空间并用指针指向SDS结构，raw类型将会**调用该两次内存分配函数**，分配两块内存空间，一块用于包含redisObject结构，而另一块用于包含SDS结构。 |

因为int编码格式直接将数据保存在ptr这个属性中，不会去申请额外的空间来保存SDS结构的字符串，所以能够使用int编码格式就使用int；

若保存的字符串中不是整数，此时只能使用embstr或者raw编码格式，又因为embstr编码格式只分配一块连续的内存空间，而raw编码格式则需要分配两块内存空间，所以尽量保证保存的字符串长度不超过44字节，从而去使用embstr的编码格式，来提高效率并且更好地使用CPU缓存。









---

### List

在Redis 3.2之前的版本，List数据类型的底层数据结构是由**双向链表或压缩列表**来实现的：

* 如果列表的元素个数小于`512`（默认值，可由list-max-ziplist-entries参数配置），列表每个元素的值都小于`64`字节（默认值，可由list-max-ziplist-value配置），Redis会使用**压缩列表**作为List类型的底层数据结构；

* 如果列表的元素不满足上面的条件，Redis会使用**双向链表**作为List类型的底层数据结构。

在Redis 3.2版本之后，List数据类型底层数据结构就是由**`quicklist`**实现了，代替了双向链表和压缩列表，此时的**`quicklist = 双向链表 + ziplist压缩列表`**；

在Redis 7版本以后，**quicklist中底层的ziplist压缩列表使用了listpack代替**，此时的**`quicklist = 双向链表 + listpack`**，那么此时，由于listpack中没有prevlen字段去记录上一个节点的长度，也就不存在压缩列表的连锁更新问题。







---

### Hash

Hash类型的底层数据结构是由**压缩列表或哈希表**实现的：

* 如果哈希类型元素个数小于512个（默认值，可由hash-max-ziplist-entries配置），所有值小于64字节（默认值，可由hash-max-ziplist-value配置）的话，Redis会使用压缩列表作为Hash类型的底层数据结构；
* 如果哈希类型元素不满足上面条件，Redis会使用哈希表作为Hash类型的底层数据结构。

在Redis 7.0中，使用listpack来代替压缩表，那么此时Hash类型的数据底层是使用**listpack紧凑列表或哈希表**来实现的。









---

### Set

Set类型的底层数据结构是由**哈希表或整数集合**实现的：

* 如果集合中的元素**都是整数且元素个数小于512**（默认值，通过set_maxintset-entries配置），Redis会使用整数集合作为Set类型的底层数据结构；

* 如果集合中的元素不满足上面的条件，则Redis使用哈希表作为Set类型的底层数据结构。



---

### ZSet

ZSet类型的底层数据结构是由**压缩列表或跳表**实现的：

* 如果有序集合的元素个数小于128个，并且每个元素的值小于64字节时，Redis会使用**压缩列表**作为ZSet类型的底层数据结构；

* 如果有序集合的元素不满足上面的条件，Redis会使用**跳表**作为ZSet类型的底层数据结构；

在Redis7.0中，压缩列表数据结构已经废弃了，交由**listpack**数据结构来实现了。







---

# 二、Redi高性能设计之epoll和IO多路复用

## I/O多路复用是什么？

> **注意：`Redis单线程`指的是`网络的请求模块使用一个线程`，即一个线程处理所有网络请求。其他的模块可以使用多线程。**

当有多个客户端连接Redis时，在多路复用方案之前最简单的方案是：**同步阻塞网络IO模型**。

这种方案就是使用**一个进程来处理一个网络连接（一个用户请求）**，即一个用户请求，就会使用一个进程来处理。

这种方式不是IO复用，也就是每次请求都会去创建一个新的IO，创建一个新的进程来进行处理。

**优点**：容易理解，代码简单，符合人的直线型思维。

**缺点**：性能差，每个用户请求都要占用一个进程。

进程是一个很笨重的东西，需要占用很多资源，一台服务器创建不了多少个进程。

就有点类似于连接池的概念，比如对于数据库连接池来说，我们不能每次去建立连接，都去重新创建，一般情况下，都是创建一个数据库连接池，在连接池中直接获取数据库的连接，结束后并不直接释放连接，而是将连接放入到连接池中以供后续的使用，这样就可以避免资源的浪费。

同理进程也是一样的，不可能每次接收到用户的请求后都去创建一个进程，肯定是对同一个进程进行多次的复用，来避免出现资源的浪费。

所以：

进程在Linux上是一个开销不小的家伙，先不说创建，切换不同的进程就需要花费几微秒。所以为了高效地对海量用户提供服务，必须**`要让一个进程同时处理很多个TCP连接才行`**。

假设现在一个进程保持了10000条TCP连接，那么我们该如何发现哪条连接上有数据可读、哪条连接有数据可写呢？这就是IO多路复用需要考虑的问题痛点。

我们可以使用循环遍历的方式来发现IO事件，即一遍一遍地循环遍历每个连接，判断是否要进行操作。这种方式首先特别浪费CPU资源，而且比较低级，不推荐。我们希望有一种更高效的机制，在很多连接中，某一个连接上有IO事件的发生立即快速地将其找出来，并进行处理。这个机制Linux系统已经帮助我们做好了，这就是我们所熟知的**`IO多路复用机制`**。**复用，指的就是进程的复用。**

> **I/O多路复用是什么？**
>
> * `I/O`：网络IO
> * `多路`：多个客户端连接，指的是多条TCP连接
> * `复用`：用一个进程来处理多条连接，使用单进程就能够实现同时处理多个客户端的连接
>
> 即：I/O多路复用机制实现了使用一个进程来处理大量的用户请求。IO多路复用类似于一个规范和接口，是Linux内核中操作，可以分为`select -> poll -> epoll`三个阶段来描述。





## Redis的单线程模型

Redis基于**`Reactor`**模式开发了自己的网络事件处理器，称之为**`文件事件处理器`**（`File Event Handler`）。

文件事件处理器由**`Socket`**、**`IO`多路复用程序**、**文件事件分派器（`dispather`）**，**事件处理器（`handler`）**四部分组成。

文件事件处理器的模型如下所示：

![img](.\images\011c1d3046570fa1458d748164fcc9e8.png)

`IO`多路复用程序会同时监听多个`socket`，当被监听的`socket`准备好执行`accept`、`read`、`write`、`close`等操作时，与这些操作相对的文件事件就会产生。IO多路复用程序会把所有产生事件的socket压入到一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。

**`因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。`**



**文件事件处理器分为几种：**

* **连接应答处理器**：用于处理客户端的连接请求；
* **命令请求处理器**：用于执行客户端传递过来的命令，比如常见的set、lpush等；
* **命令回复处理器**：用于返回客户端命令的执行结果，比如set、get等命令的结果。



**事件种类：**

* **`AE_READABLE`**：该事件可与两种事件处理器结合使用。
  * 当**客户端连接服务器**时，服务器端会将**连接应答处理器**与socket的`AE_READABLE`事件关联起来；
  * 当**客户端向服务端发送命令**时，服务端将**命令请求处理器**与`AE_READABLE`事件关联起来。
* **`AE_WRITEABLE`**：当**服务端有数据需要回传给客户端**时，服务端将**命令回复处理器**与socket的`AE_WRITEABLE`事件关联起来。

也就是说，客户端与Redis服务器建立连接时或者发送请求时，都是使用AE_READABLE事件，当建立连接，将该事件与应答处理器关联；发送请求时，将该事件与命令请求处理器关联。服务端响应数据给客户端，是将命令回复处理器与AE_WRITEABLE事件关联。



Redis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以IO操作在一般情况下不能直接返回，会被阻塞一段时间，而某一个文件的IO阻塞会导致整个进程无法使用，那么IO多路复用就是为了解决这个问题出现的。

所谓的IO多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制使用需要select、poll、epoll来配合。`多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。`



**Redis的客户端与服务端的交互过程如下所示：**

![img](.\images\f684e4971367e07551e3b0c791bdee92.png)





---

## 网络IO模型基本概念

### 内核态

**`内核态`** **拥有完全的底层资源控制权限，可以执行任何CPU指令，访问任何内存地址，其占有的处理机是不允许被抢占的。**

### 用户态

**用户程序是运行在操作系统之上，这些程序运行时称之为`用户态`。用户态下不能直接访问底层硬件和内存地址，只能通过委托系统调用的方式来访问底层硬件和内存。**

### 用户态到内核态如何切换









### 同步与异步







### 阻塞和非阻塞















---

## 五种IO模型























---

# 三、Redis通信协议——RESP协议











































