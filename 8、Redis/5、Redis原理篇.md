[TOC]

**不同版本中，Redis数据类型与数据结构之间的关系：**

**Redis 6与之前**

![image-20240724062016536](.\images\image-20240724062016536.png)



**Redis 7以后**

![image-20240724061730434](.\images\image-20240724061730434.png)







# 一、Redis数据类型与底层实现

### Redis数据类型与数据结构之间的关系

**Redis为什么那么快？**

除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis能高效地处理。

注意，Redis数据结构并不是指String（字符串）、List（列表）、Hash（哈希）、Set（集合）和ZSet（有序集合）对象，因为这些是Redis键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现方式使用了数据结构。

以下是Redis数据类型和底层数据结构的对应关系图，左边是Redis3.0版本，也就是《Redis设计与实现》这本书讲解的版本，右边是比较新的Redis版本：

![img](.\images\9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png)

可以看到，Redis数据类型的底层数据结构随着版本的更新也有所不同。（将在后面学习不同的数据类型所使用的底层数据结构）

这里，我们将去学习新旧版本的所有Redis数据结构，共有9种：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。



**不同版本中，Redis数据类型与数据结构之间的关系：**

**Redis 6与之前**

![image-20240724062016536](.\images\image-20240724062016536.png)

* `String` 使用 `SDS` 实现
* `List` 使用 `双向链表` + `ziplist` 实现
* `Hash` 使用 `hashtable` + `ziplist` 实现
* `Set` 使用 `hashtable` + `intset` 实现
* `SortedSet` 使用 `skiplist` + `ziplist` 实现



**Redis 7以后**

![image-20240724061730434](.\images\image-20240724061730434.png)

也就是说，在Redis7以后，压缩列表不再使用了，使用了其他数据结构来实现（但是这个数据结构还是保留了）：

* `String` 使用 `SDS` 实现。
* `List` 使用 `quicklist` 实现。
* `Hash` 使用 `hashtable` + `listpack` 实现。
* `Set` 使用 `hashtable` + `intset` 实现。
* `SortedSet` 使用 `skiplist` + `listpack` 实现。

Redis6和7版本，数据结构最大的不同就在于ziplist使用了listpack替代，并且List数据类型从原本使用双向链表+ziplist实现改成了使用quicklist实现。







### Redis源码如何查看？

Redis是一个开源的使用C语言编写的键值对存储数据库，提供了多种语言的API，Redis的源码位于Redis目录下的src目录中：

<img src=".\images\123412341234.png" alt="123412341234" style="zoom:67%;" /> 

有这么多源码文件，我们该如何看？

数据类型有关的源码文件：

* Redis对象：object.c
* 字符串：t_string.c
* 列表：t_list.c
* 字典：t_hash.c
* 集合及有序集合：t_set.c和t_zset.c

底层数据结构有关的源码文件：

* 简单动态字符串：sds.c
* 整数集合：intset.c
* 压缩列表：ziplist.c
* 快速链表：quicklist.c
* 紧凑链表：listpack.c
* 字典：dict.c

还有Redis数据库的实现：db.c

与持久化实现的源码：rdb.c和aof.c

Redis服务端和客户端的实现：

* 事件驱动：ae.c和ae_epoll.c
* 网络连接：anet.c和networking.c
* 服务端程序：server.c
* 客户端程序：redis-cli.c

主从复制实现的源码：replication.c

哨兵实现的源码：sentinel.c

集群实现的源码：cluster.c

其他数据结构，如hyperloglog.c、geo.c等等。





## 底层数据结构（:star:）

### 1、RedisObject

在开始讲数据结构之前，先给介绍一下Redis是怎样实现键值对（key-value）数据库的。

Redis的键值对中的**key就是字符串对象，而value可以是字符串对象，也可以是集合数据类型的对象**，比如List对象、Hash对象、Set对象和ZSet对象。

举个例子，我这里列出几种Redis新增键值对的命令：

```sh
> SET name "xiaolincoding"
OK

> HSET person name "xiaolincoding" age 18
0

> RPUSH stu "xiaolin" "xiaomei"
(integer) 4
```

这些命令代表着：

* 第一条命令：name是一个字符串键，因为键的值是一个字符串对象；
* 第二条命令：person是一个哈希表键，因为键的值是一个包含两个键值对的哈希表对象；
* 第三个命令：stu是一个列表键，因为键的值是一个包含两个元素的列表对象。

**这些键值对是如何保存在Redis中的呢？**

Redis是使用了一个**`哈希表`**来保存所有键值对，哈希表的最大好处就是让我们可以使用O(1)的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。

**Redis的哈希桶是怎么保存键值对数据的呢？**

哈希桶存放的是指向键值对数据的指针（`dictEntry*`），这样通过指针就能够找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构并不是直接保存值本身，而是分别保存了`void * key`和`void * value`指针，分别指向实际的键对象和值对象，这样一来，即使是集合数据，也可以通过`void * value`指针找到。

下面是Redis保存键值对时所涉及到的数据结构：

![img](.\images\f302fce6c92c0682024f47bf7579b44c.png)

大致说明：

* `redisDb`结构：表示Redis数据库的结构，在结构体中存放了指向dict结构的指针；
* `dict`结构，结构体里存放了两个哈希表，正常情况下都是使用哈希表1，哈希表2只有在rehash的时候才会使用，rehash将在哈希表数据结构中讲解。
* `dictht`结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向哈希表节点结构（dictEntry）的指针；
* `dictEntry`结构，表示哈希表节点的结构，结构里面存放了void * key和void * value指针。key指向的是String对象，而value可以指向String对象，也可以指向集合类型的对象，比如List、Hash、Set和ZSet，每一种对象都是由`redisObject`构成。





> **无论void * key指针和void * value指针指向的是哪一种数据类型对象，Redis中的每一个对象都是通过`redisObject`结构进行储存的，只不过是底层实现的数据结构不同。**

为了便于操作，Redis采用redisObject结构来统一五种不同的数据类型，这样所有的数据类型就都可以以相同的形式在函数间传递而不用使用特定的类型结构。同时，为了识别不同的数据类型，redisObject定义了type和encoding字段对不同的数据类型加以区别。简单来说，`redisObject就是string、hash、list、set、zset的父类`，可以在函数间传递时隐藏具体的类型信息，所以作者抽象了redisObject结构来达到同样的目的。

**redisObject的定义如下：**

```c
typedef struct redisObject {
　　unsigned type:4;
　　unsigned encoding:4;
　　unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */
　　int refcount;
　　void *ptr;
} robj;
```

一共有5个属性，其中的type、encoding和ptr是三个最重要的属性：

1. **`type`**

type字段表示**对象的类型**，占用4个bit，所有的取值包括：

```c
/*
 * 对象类型
 */
#define REDIS_STRING 0  // 字符串
#define REDIS_LIST 1    // 列表
#define REDIS_SET 2     // 集合
#define REDIS_ZSET 3    // 有序集
#define REDIS_HASH 4    // 哈希表
```

当我们执行type命令时，就是通过读取redisObject中的type字段来获取到对象的类型，如下图所示：

![img](.\images\1174710-20180327001214189-1733420705.png) 



2. **`encoding`**

encoding表示**对象的内部编码方式**，占用4个bit。

对于Redis支持的每种数据类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。

**通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。**

在Redis7及以后，encoding有11种取值：

![2384902380](.\images\2384902380.png)

这些encoding的取值，分别对应的数据结构为：

<img src=".\images\123097128903712.png" alt="123097128903712" style="zoom:80%;" /> 



通过`object encoding key`命令，可以查看对象采用的编码方式，如下图所示：

![img](.\images\1174710-20180327001228807-998910409.png) 



3. **lru**

lru这个必然是和内存回收相关的了，这里它记录的是当前的值对象最后一次被程序访问的时间。

通过这个时间我们可以得到该对象的空转时长，就是当前时间 - lru记录的时间，如果说redis服务器打开了 maxmemory 最大内存管理的选项，并且内存回收使用volatile-lru 或者 allkeys-lru算法，那么服务器就会优先释放这个空转时长比较长的对象，从而回收内存。



4. **refcount**

refcount记录的是当前这个值对象正在被多少数据结构所共享。



5. **`ptr`**

> **ptr是一个指针，指向实际保存值的数据结构，这个数据结构由type属性和encoding属性决定。**



那么也就是说，redisObject类似于一个封装起来对象，这个对象实际是什么数据类型，是根据type来决定的，数据类型实际使用什么样的数据结构，实际上是根据ptr指针来决定的。

所以，redisObject结构可以表示为：

<img src=".\images\58d3987af2af868dca965193fb27c464.png" alt="img" style="zoom:67%;" /> 

 



那么，Redis键值对数据库全景图如下所示：

![img](.\images\3c386666e4e7638a07b230ba14b400fe.png)





---

### 2、SDS动态字符串

`SDS`：`Simple Dynamic String`，简单动态字符串。

字符串在Redis中是很常见的，键值对中的键是字符串类型，值有时也是字符串类型。

Redis是使用C语言编写的，但是它没有直接使用C语言的char*字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string）的数据结构来表示字符串，也就是Redis的String数据类型的底层数据结构是SDS。

既然Redis设计了SDS结构来表示字符串，肯定是C语言的char*数组存在一些缺陷，现在我们来看看C语言字符串存在哪些缺陷。



#### C语言字符串存在的缺陷（:star2:）

C语言的字符串其实就是一个字符数组，即数组中的每个元素是字符串中的一个字符。

比如，下图就是字符串"xiaolin"的char*字符数组结构：

![img](.\images\376128646c75a893ad47914858fa2131.png) 

没有学过C语言的同学，可能会好奇为什么最后一个字符是"\0"？

在C语言中，对字符串操作时，char*指针只是指向字符数组的起始位置，而**字符数组的结尾就用"\0"表示，意思是指字符串的结束。**

因此，C语言标准库中的字符串操作函数就是通过判断字符是不是"\0"来决定要不要停止操作，如果当前字符不是"\0"，说明字符还没有结束，可以继续操作，如果当前字符是"\0"则说明字符串结束，要停止操作了。

举个例子：C语言获取字符串长度的函数`strlen`，就是去遍历字符数组中的每一个字符，并进行计数，当遇到字符为"\0"后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下面显示了strlen函数的执行流程：

<img src="https://cdn.xiaolincoding.com//mysql/other/bcf6bde3b647bdc343efcbc1a8f10579.png" alt="img" style="zoom:67%;" /> 



很明显，**C语言中获取字符串长度函数的时间复杂度是O(N)，这是一个可以改进的地方**。

C语言字符串使用"\0"字符作为结尾有一个缺陷：假设字符串中包含"\0"字符，这时在操作这个字符串的时候就会**提早结束**。比如"xiao\0lin"字符串，计算字符串长度的时候则会是4，如下图：

<img src=".\images\6286480eb1840a8930e18fd215d82565.png" alt="img" style="zoom:67%;" /> 

因此，除了字符串的末尾之外，**字符串里面不能含有"\0"字符**，否则最先被程序读入的"\0"字符将被误认为是字符串结尾，这个限制使得C语言的字符串只能保存文本数据，**不能保存像图片、音频、视频这样的二进制数据**（这也是一个可以改进的地方）。

另外，C语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一个不注意，就会导致缓冲区溢出。

举个例子，strcat函数是可以将两个字符串拼接在一起：

```c
//将 src 字符串拼接到 dest 字符串后面
char *strcat(char *dest, const char* src);
```

**C语言的字符串是不会记录自身的缓冲区大小的**，所以strcat函数是假定程序员在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而**一旦这个假设不成立，就会发生缓冲区溢出并可能造成程序运行终止（这时一个可以改进的地方）。**

而且，strcat函数和strlen函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾，然后对于strcat函数来说，还需要遍历源字符串才能完成追加，**对字符串的操作效率不高**。



> 通过上面的分析，我们可以得知C语言的字符串不足之处以及可以改进的地方：
>
> 1. 获取字符串长度需要通过运算，时间复杂度为O(N)。
> 2. 字符串的结尾是以"\0"字符表示，字符串里面不能包含有"\0"字符，因此不能保存二进制数据，即非二进制安全的。
> 3. 字符串操作函数不高效且不安全，存在缓冲区溢出的风险，有可能会造成程序运行终止。

Redis实现的SDS结构就把上面这些问题解决了，接下来我们来一起看看Redis是如何解决的。



#### SDS结构

为了解决上述存在的问题，Redis构建了一种新的字符串结构，称为简单动态字符串（`Simple Dynamic String`），简称为**`SDS`**。

SDS数据结构：

<img src=".\images\516738c4058cdf9109e40a7812ef4239.png" alt="img" style="zoom: 80%;" /> 

结构中的每个成员变量介绍如下：

1. **`len`：记录了字符串的长度**。这样获取字符串长度的时候，只需要返回这个成员变量值即可，时间复杂度为O(1)。

   

2. **`alloc`：分配给字符数组的空间长度**。也就是说，字符串不一定将buf[]数组申请的字节数全部占用。

   这样在修改字符串的时候，可以**通过`alloc - len`计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将SDS的空间扩展至执行修改所需的大小，然后再去执行修改操作，所以使用SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题**。

   **注意：**这里的**alloc值不包含\0结束标识所占用的空间**，是buf[]数组真正可以用来存放字符的长度。

   

3. **`flags`：用来表示不同类型的SDS**。一共设计了5种类型，分别是`sdshdr5`、`sdshdr8`、`sdshdr16`、`sdshdr32`和`sdshdr64`（由于sdshdr5能够表示的字符长度太小了，目前已经弃用），后面再说明区别之处。

   flags不同类型所对应的值：

   <img src=".\images\image-20240725201137821.png" alt="image-20240725201137821" style="zoom:67%;" /> 

   

4. **`buf[]`：字节数组，用来保存实际的数据**。不仅可以保存字符串，也可以保存二进制数据。

总的来说，Redis的SDS结构在原本字符数组的基础上，添加了三个元数据：len、alloc、flags，用来解决C语言字符串的缺陷。



例如，一个包含字符串"name"的SDS结构如下所示：

![image-20240725201031132](.\images\image-20240725201031132.png) 

SDS的内存空间是连续的。

因为我们的name是占用4个字节，所以可以使用sdshdr8类型（因为sdshdr5能表示的长度太小了，所以已经弃用），所以flags的值为1；

len表示字符串的长度，为4；

alloc表示buf[]数值申请的内存，第一次初始化时，申请的内存和占用的内存一致；

后面就是buf[]数组，最后会有一个\0的结束标识，SDS为了与C语言兼容，所以会保留\0这个结束标识。

但是，因为Redis中可以保存\0的二进制数据，不会根据\0这个标识来结束读取，而是根据SDS结构中的len字段值来读取相应的长度。





#### 使用SDS的好处

##### 获取字符串长度的时间复杂度为O(1)

C语言的字符串长度获取strlen函数，需要通过遍历的方式来统计字符串长度，时间复杂度是O(N)。

而Redis的SDS结构因为加入了len成员变量，那么**`获取字符串长度的时候，直接返回这个成员变量的值即可，时间复杂度是O(1)`**。





##### 二进制安全

因为SDS不需要用"\0"字符来标识子字符串结尾了，而是**`有一个专门的len成员变量来记录长度，所以可存储包含"\0"的数据`**。**SDS为了兼容部分C语言标准库的函数，SDS字符串结尾还是会加上"\0"字符。**

因此，SDS的API都是以处理二进制的方式来处理SDS存放在buf[]里的数据，程序不会对其中的数据做任何的限制，数据写入时是什么样，读取时就是什么样。

通过使用二进制安全的SDS，而不是使用C语言字符串，使得Redis不仅可以保存文本数据，也可以保存任意格式的二进制数据。



##### 不会发生缓存区溢出（动态扩容）

C语言的字符串标准库提供的字符串操作函数，大多数（比如strcat追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否够用，当发生了缓冲区溢出就有可能造成程序异常结束。

所以，Redis的SDS结构里引入了alloc和len成员变量，这样SDS API通过`alloc - len`计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。

而且，**当判断出缓冲区大小不够用时，Redis会自动扩大SDS的空间大小，以满足修改所需的大小**。

也就是说，**SDS具备`动态扩容`的功能**。例如一个内容为"hi"的SDS：

<img src=".\images\image-20240725201913887.png" alt="image-20240725201913887" style="zoom: 80%;" /> 

假如说我们要给SDS追加一段字符串",Amy"，这里首先会申请新内存空间：

> * **如果新字符串`小于1MB`，则新空间为`扩展后字符串长度的两倍+1`；**
> * **如果新字符串`大于1MB`，则新空间为`扩展后字符串长度+1MB+1`。**
>
> 这里的+1，是给最后的结束标识\0存放的。

例如，上例追加",Amy"字符串后，新的字符串就是"hi,Amy"，占6个字节，小于1MB，此时申请的字符串长度就是2 * 6 + 1 = 13字节（这里的1是给\0结束标识所使用的），那么此时该SDS的len为6，alloc为12，flags为1（alloc不包含\0字符占用的空间）：

<img src=".\images\image-20240725203245837.png" alt="image-20240725203245837" style="zoom:80%;" />



这种申请新内存空间的流程，就称为**`内存预分配`**，即**实际使用的内存比申请的内存小一些，也就是会多申请一部分内存。**

这也就是SDS中存在两个字段len和alloc的原因，要分别去记录实际占用的内存和申请的全部内存，在第一次申请时也就是没有进行扩容时，len = alloc。

**为什么要给SDS扩容时，要多分配一部分内存呢？**

扩容操作，申请新内存特别消耗资源，如果我们进行扩容时，只申请了我们所需要的内存，在下次操作SDS时，就需要再次去申请新内存，此时就会消耗资源。但是我们在申请新内存时，提前申请多一点的内存给SDS，此时给SDS追加一部分内容，如果SDS空间足够的话，API就会直接使用"未使用空间"，无需再执行内存分配，就可以**`有效地减少了内存的分配次数，从而提高性能`**。



**SDS扩容规则代码如下所示：**

```c
hisds hi_sdsMakeRoomFor(hisds s, size_t addlen)
{
    ... ...
    // s目前的剩余空间已足够，无需扩展，直接返回
    if (avail >= addlen)
        return s;
    //获取目前s的长度
    len = hi_sdslen(s);
    sh = (char *)s - hi_sdsHdrSize(oldtype);
    //扩展之后 s 至少需要的长度
    newlen = (len + addlen);
    //根据新长度，为s分配新空间所需要的大小
    if (newlen < HI_SDS_MAX_PREALLOC)
        //新长度<HI_SDS_MAX_PREALLOC 则分配所需空间*2的空间
        newlen *= 2;
    else
        //否则，分配长度为目前长度+1MB
        newlen += HI_SDS_MAX_PREALLOC;
       ...
}
```

在扩容SDS空间之前，SDS API会优先检查未使用空间是否足够，如果不够的话，API不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的"`未使用空间`"。

所以，使用SDS既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出的问题。





##### 节省内存空间

SDS结构中有个flags成员变量，表示的是SDS类型。

Redis一共设计了5种类型，分别是`sdshdr5`、`sdshdr8`、`sdshdr16`、`sdshdr32`和`sdshdr64`。

这5种类型的主要区别就在于，它们**数据结构中的`len`和`alloc`变量的数据类型不同**。

比如，sdshdr16和sdshdr32这两个类型，它们的定义如下：

```c
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags; 
    char buf[];
};


struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc; 
    unsigned char flags;
    char buf[];
};
```

可以看到：

* sdshdr16类型的len和alloc数据类型都是uint16_t，表示字符数组长度和分配空间大小不能超过2的16次方。
* sdshdr32则都是uint32_t，表示字符数组长度和分配空间大小不能超过2的32次方。

比如：

当我们要去创建一个字节长度在2^8-1以内的字符串时，就会使用sdshdr8的结构，此时len字段和alloc字段只占用1个字节；

当我们要去创建一个字节长度在2^8 ~ 2^16-1范围内的字符串时，就会使用sdshdr16作为底层的数据结构，此时len字段和alloc字段占用2个字节；

...

所以，**SDS设计不同类型的结构，是为了能够灵活地保存不同大小的字符串，从而有效地节省内存空间**。比如，**在保存小字符串时，结构头len和alloc字段占用的空间也比较少**。

并且，我们可以看到在SDS类型的声明中，还使用到了`_attribute_((packed))`，它的作用是：**告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐**。

举个例子，假设下面这个结构体，它有两个成员变量，类型分别是char和int，如下图所示：

```c
#include <stdio.h>

struct test1 {
    char a;
    int b;
 } test1;
 
int main() {
     printf("%lu\n", sizeof(test1));
     return 0;
}
```

这个结构体占用的内存是8个字节：

![img](.\images\35820959e8cf4376391c427ed7f81495.png) 

因为在默认情况下，编译器使用的是`字节对齐`的方式分配内存，虽然char只占用了一个字节，但是由于成员变量中存在int类型，它占用了4个字节，所以在成员变量为char类型分配内存时，会分配4个字节，其中这多余的3个字节是为了字节对齐而分配的，相当于有3个字节被浪费了。

而SDS采用了`_attribute_((packed))`属性定义结构体，这样会按照实际占用的字节数分配内存空间。

比如，使用`_attribute_((packed))`属性定义下面的结构体，同样包含char和int两个类型的成员变量，代码如下所示：

```c
#include <stdio.h>

struct __attribute__((packed)) test2  {
    char a;
    int b;
 } test2;
 
int main() {
     printf("%lu\n", sizeof(test2));
     return 0;
}
```

这个时候，占用的内存空间就是5个字节：

![img](.\images\47e6c8fbc17fd6c89bdfcb5eedaaacff.png) 



可以看得出，SDS是按照实际占用字节数进行分配内存的，这样可以节省内存空间。





> **总结：SDS的优点**
>
> 1. 获取字符串长度的时间复杂度为O(1)
> 2. 支持动态扩容
> 3. 内存预分配，减少内存分配的次数
> 4. 二进制安全的
> 5. 节省内存空间









---

### 3、双向链表

大家最熟悉的结构除了数组以后，就是链表了。

在以前的版本中，Redis的List对象底层实现之一就是链表，C语言本身并没有链表这个数据结构，所以Redis自己设计了一个链表数据结构，就类似于Java中的LinkedList。

#### 节点结构设计

先来看看链表节点结构的设计：

```c
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```

存在前置节点和后置节点，可以看得出，这个是一个双向链表：

![img](.\images\4fecbf7f63c73ec284a4821e0bfe2843.png) 





#### 结构设计

Redis在listNode结构体的基础上，又封装了list这个数据结构，这样操作起来更加方便，链表结构如下：

```c
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```

list结构为链表提供了链表头指针head、链表尾指针tail、链表节点数量len、以及可以自定义实现的dup、free、match函数。

举个例子，下面是由list结构和3个listNode结构组成的链表：

![img](.\images\cadf797496816eb343a19c2451437f1e.png)





#### 优势与缺陷

Redis链表优势如下：

* listNode链表节点的结构里带有prev和next指针，**获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向NULL，所以是无环链表**；
* list结构因为提供了表头指针head和表尾指针tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需要O(1)**;
* list结构因为提供了链表节点数量len，所以**获取链表中节点数量的时间复杂度只需O(1)**；
* listNode链表节点使用void*指针保存节点值，并且可以通过list结构的dup、free、match函数指针节点设置该节点类型特定的函数，因此**链表节点可以保存各种不同类型的值**。

Redis链表也存在着缺陷：

* 链表每个节点之间的内存都是不连续的，意味着**`无法很好利用CPU缓存`**。能够很好利用CPU缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用CPU缓存来加速访问。
* 还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，**`内存开销较大`**。

因此，在Redis 3.2之前，List对象在数据量比较少的情况下，会采用"压缩列表"作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。

不过，压缩列表存在着性能问题，所以在Redis 3.2版本以后设计了新的数据结构quicklist，并将List对象的底层数据结构改为由quicklist实现。









---

### 4、压缩列表ziplist

压缩列表最大的特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅**可以利用CPU缓存**，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地**节省内存开销**。

但是，压缩列表的缺陷也存在：

* **不能保存过多的元素，否则查询效率就会降低；**
* **新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。**

因此，在listpack和quicklist未被使用的版本中，List对象、Hash对象、ZSet对象包含元素数量较少，或者元素值不大的情况下才会使用压缩列表作为底层数据结构。

现在，我们来详细聊一下压缩列表。





#### 结构设计

压缩列表Redis为了节约内存而开发的，它是**`由连续内存块组成的顺序数据结构`**，有点类似于数组。

![img](.\images\ab0b44f557f8b5bc7acb3a53d43ebfcb.png) 

压缩列表在表头有三个字段：

* **`zlbytes`**：记录整个压缩列表占用的内存字节数；
* **`zltail`**：记录压缩列表的尾部节点距离起始地址有多少字节，也就是列表尾的偏移量；
* **`zllen`**：记录压缩列表包含的节点数量；
* **`zlend`**：记录压缩列表的结束点，固定值0xFF（十进制255）。

> 在压缩列表中，如果我们要**查找定位第一个元素和最后一个元素**，可以通过表头三个字段直接定位，**时间复杂度是`O(1)`**。
>
> 而**查找其他元素时，就没有那么高效了，只能逐个查找，此时的复杂度就是`O(N)`了，因此`压缩列表不适合保存过多的元素`。**
>

另外，压缩列表节点（entry）的构成如下：

![img](.\images\a3b1f6235cf0587115b21312fe60289c.png) 

压缩列表节点包含三部分内容：

* **`prevlen`**：记录前一个节点的长度，目的是为了实现从后向前遍历；
* **`encoding`**：记录了当前节点实际数据的类型和长度，类型主要有两种：字符串和整数。
* **`data`**：记录了当前节点的实际数据。

当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的prevlen和encoding这两个元素里保存的信息。

**压缩列表会根据数据大小和类型进行不同的空间大小分配，正是Redis为了节省内存空间而实现的。**

分别说一下，prevlen和encoding是如何根据数据的大小和类型来进行不同的空间大小分配：

**prevlen**

压缩列表里的每个节点的prevlen属性都记录了前一个节点的长度，而且prevlen属性的空间大小跟前一个节点长度值有关：

* 如果**前一个节点的长度小于254字节**，那么prevlen属性需要用**1字节的空间**来保存这个长度值；
* 如果**前一个节点的长度大于等于254字节**，那么prevlen属性需要用**5字节的空间**来保存这个长度值。

**encoding**

encoding属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关，如下图（下图中的content表示的是实际数据，即本文的data字段）：

<img src=".\images\压缩列表编码.png" alt="img" style="zoom:67%;" /> 

* 如果**当前节点的数据是整数**，则encoding会使用**1字节的空间**。通过encoding确认了整数类型，就可以确认整数数据的实际大小了。比如如果encoding编码确认了数据是int16整数，那么data的长度就是int16的大小。
* 如果**当前节点的数据是字符串，根据字符串的长度大小**，encoding会使用**1字节/2字节/5字节的空间**进行编码，encoding编码的前两个bit表示数据的类型，后续的其他bit标识字符串数据的实际长度，即data的长度。





#### 连锁更新问题（:star2:）

压缩列表除了查找复杂度高的问题外，还存在一个问题：

> **压缩列表新增某个元素或者修改某个元素时，如果空间不够，压缩列表占用的内存空间就需要重新分配。而当插入的新元素较大时，可能会导致后续元素的`prevlen`占用空间都发生变化，从而引起`连锁更新`问题，导致每个元素的空间都要重新分配，造成访问压缩列表的性能下降。**

对于这个问题，我们来重现一下：

前面提到，压缩列表节点的prevlen属性会根据前一个节点的长度进行不同的空间大小分配：

* 如果前一个节点的长度小于254字节，那么prevlen属性需要用1字节的空间来保存这个长度值；
* 如果前一个节点的长度大于等于254字节，那么prevlen属性需要用5字节的空间来保存这个长度值。

那么，现在假设一个压缩列表中有多个连续的、长度在250~253之间的节点，如下图所示：

![img](.\images\462c6a65531667f2bcf420953b0aded9.png) 

因为这些节点的长度值都是小于254字节的，所以prevlen属性都是使用1字节空间来保存这个长度值。

此时，如果将一个长度值大于或等于254字节的新节点插入到压缩列表的表头节点，即新节点将成为e1的前置节点，如下图：

<img src=".\images\d1a6deff4672580609c99a5b06bf3429.png" alt="img" style="zoom:67%;" />

因为e1节点的prevlen属性只有1个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重新分配操作，并将e1节点的prevlen属性从原来的1字节大小扩展为5字节大小。

此时，就会发生多米诺骨牌效应，后续所有节点的prevlen都会变为5个字节，每个节点的空间都会重新进行分配：

<img src=".\images\1f0e5ae7ab749078cadda5ba0ed98eac.png" alt="img" style="zoom:67%;" />

e1原本的长度在250~253之间，因为插入了一个长度超过254字节的节点，此时e1的prevlen属性就会变成5字节长度，此时e1的长度就大于等于254字节了，因此原本e2保存e1的prevlen属性也必须从1字节扩展至5字节大小。

正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展，而扩展e3又会引发对e4的扩展...这样会一直持续到结尾。

**这种在特殊情况产生的连续多次空间扩展就叫做连锁更新，连锁更新导致每个元素的内存空间重新分配，影响压缩列表的访问性能。**



#### 压缩列表的优势和缺陷

压缩列表存在着优势：

* **节省内存开销；**
* **元素存放在一块连续的内存空间，可以利用CPU缓存。**

压缩列表也存在着缺陷：

* **查找元素时，时间复杂度为O(N)，效率较低；**
* **保存的元素增加了或者元素变大，会导致内存重新分配，有可能还会发生连锁更新问题。连锁更新一旦发生，就会导致压缩列表占用的内存空间需要多次重新分配，直接影响到压缩列表的访问性能。**

因此，**`压缩列表只会用于保存节点数量不多的场景`**，只要节点数量足够小，即使发生连锁更新，也是可以接收的。

在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2引入）和listpack（Redis 5.0引入），这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表存在的连锁更新问题。







---

### 5、快速列表quicklist

在Redis 3.2之前，List对象的底层数据结构是双向链表或压缩列表，然后在Redis 3.2时，List对象底层改由quicklist数据结构实现。

quicklist，其实就是**`双向链表+压缩列表`**的组合，因为一个quicklist就是一个链表，而链表中的每个元素又都是一个压缩列表。

在前面讲压缩列表时，提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会存在连锁更新的风险，一旦发生，会造成压缩列表性能的下降。

quicklist解决方法：

> **通过控制每个链表节点中压缩列表或者元素个数，来规避连锁更新的风险。因为压缩列表元素越少或者越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。**





#### quicklist结构设计

quicklist的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于quicklist的节点是quicklistNode：

```c
typedef struct quicklist {
    //quicklist的链表头
    quicklistNode *head;      //quicklist的链表头
    //quicklist的链表尾
    quicklistNode *tail; 
    //所有压缩列表中的总元素个数
    unsigned long count;
    //quicklistNodes的个数
    unsigned long len;       
    ...
} quicklist;
```

接下来看看，quicklistNode的结构定义：

```c
typedef struct quicklistNode {
    //前一个quicklistNode
    struct quicklistNode *prev;     //前一个quicklistNode
    //下一个quicklistNode
    struct quicklistNode *next;     //后一个quicklistNode
    //quicklistNode指向的压缩列表
    unsigned char *zl;              
    //压缩列表的的字节大小
    unsigned int sz;                
    //压缩列表的元素个数
    unsigned int count : 16;        //ziplist中的元素个数 
    ....
} quicklistNode;
```

可以看到，quicklistNode结构体里包含了前一个节点和后一个节点的指针，这样每个quicklistNode形成一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以quicklistNode结构体里有一个指向压缩列表的指针`*zl`。

下图就是一个quicklist的数据结构：

![img](.\images\f46cbe347f65ded522f1cc3fd8dba549.png)

当往quicklist中添加一个元素时，不会像普通的链表那样，直接新建一个链表节点，而是去检查插入位置的压缩列表是否能够容纳该元素，如果能容纳就直接保存到quicklistNode结构里的压缩列表，如果不能容纳，才会去新建一个quicklistNode结构，并且将元素存入到新的压缩列表中，让quicklistNode指向这个新的压缩列表中。

quicklist会控制quicklistNode结构里的压缩列表大小或者元素个数，来规避潜在的连锁更新风险，但是这样**`并没有完全解决连锁更新问题`**。



> * 在Redis 7以前，`quicklist = 双向链表 + ziplist；`
>
> * 在Redis 7及以后，`quicklist = 双向链表 + listpack。`





---

### 6、紧凑列表listpack

quicklist虽然通过控制quicklistNode结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新问题。

因为quicklistNode还是用来压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。

于是，在Redis 5.0中新设计了一个数据结构，叫做listpack，目的是替代压缩列表，它最大特点是listpack中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，才会存在连锁更新的隐患。

#### listpack结构设计

listpack采用了压缩列表的很多优秀设计，比如还是使用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack节点会采用不同的编码方式来保存不同大小的数据。

我们来看看listpack结构：

<img src=".\images\4d2dc376b5fd68dae70d9284ae82b73a.png" alt="img" style="zoom:67%;" />

listpack头包含两个元素，分别记录了listpack总字节数和元素个数，然后listpack末尾也有个结尾标识。图中的listpack entry就是listpack的节点了。

每个listpack节点结构如下：

<img src=".\images\c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img" style="zoom:67%;" /> 

主要包含三个方面内容：

* `encoding`：定义该元素的编码类型，会对不同长度的整数和字符串进行编码；
* `data`：实际存放的数据；
* `len`：encoding + data的总长度。

> 可以看到，**listpack没有压缩列表中记录前一个节点长度的字段了，listpack只记录当前节点的长度，当我们向listpack加入一个新的元素时，不会影响到其他节点的字段长度，从而避免出现压缩列表的连锁更新问题。**



**问：压缩列表的entry为什么要保存prevlen呢？listpack改成len之后不会影响功能吗？**

压缩列表的 entry 保存 prevlen 是为了实现节点从后往前遍历，知道前一个节点的长度，就可以计算前一个节点的偏移量。

listpack 一样可以支持从后往前遍历的。详细的算法可以看：https://github.com/antirez/listpack/blob/master/listpack.c 里的`lpDecodeBacklen`函数，`lpDecodeBacklen` 函数就可以从当前列表项起始位置的指针开始，向左逐个字节解析，得到前一项的 entry-len 值。









---

### 7、哈希表hashtable（:star:）

哈希表是一种保存键值对（key-value）的数据结构，如果不懂什么是哈希表，使用Java中的HashMap理解就行。

哈希表中的每一个key都是独一无二的，程序可以根据key查找到与之关联的value，或者通过key来更新value，又或者根据key来删除整个value等等。

在讲压缩列表时，提到过Redis的Hash对象底层实现之一就是压缩列表（最新的Redis代码已经将压缩列表替换成了listpack）。Hash对象的另一个底层实现就是哈希表。

哈希表的优点在于，它能以**O(1)的时间复杂度快速查找数据**。怎么做到的呢？将key通过Hash函数的计算，就能够定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。

但是存在的风险也是有的，在哈希表大小固定的情况下，随着数据不断增多，那么**哈希冲突**的可能性也会越来越高。

解决哈希冲突的方式有很多种，**Redis采用了`链式哈希`来解决哈希冲突**，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接，以便这些数据在表中仍然可以被查询到。





#### 哈希表结构设计

Redis的哈希表结构如下：

```c
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表的长度，也就是哈希桶的个数
    unsigned long size;  
    //哈希表大小掩码，用于计算索引值，总等于size - 1
    unsigned long sizemask;
    //该哈希表已有的节点数量，也就是entry的个数
    //由于链表的存在，entry的个数是有可能超过size大小的
    unsigned long used;
} dictht;
```

可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向哈希表节点（dictEntry）的指针。

![img](.\images\dc495ffeaa3c3d8cb2e12129b3423118.png)

哈希表节点的结构如下：

```c
typedef struct dictEntry {
    //键值对中的键
    void *key;
  
    //键值对中的值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

dictEntry结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针next，这个指针就是用来解决哈希冲突，类似于Java中HashMap出现哈希冲突时，使用单向链表来存放同一个hash值的元素。同样地，这个next指针可以将多个哈希值相同的键值对链接起来，以此来**`解决哈希冲突问题`**，这就是链式哈希。

另外，dictEntry结构里键值对中的值是一个**联合体v**定义的。联合体表示可以是定义中的任何一个类型，也就是类似于Java中的枚举。在上面的联合体v中，表示v可以为四种类型，可以是*val指针，也可以是uint64_t类型，也可以是int64_t类型，也可以是double类型。即，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的64位整数或有符号的64位整数或double类型的值。这么做的好处是可以**`节省内存空间`，因为当值是整数或者浮点数时，就可以将值的数据内嵌在dictEntry结构里，无需再使用一个指针指向实际的值，从而节省了内存空间**。



#### 什么是哈希冲突？

哈希表实际上是一个数组，数组中每一个元素就是一个哈希桶。

**计算存放地址的方式**

当一个键值对的值经过Hash函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果就是该key-value对应的数组元素位置，也就是第几个哈希桶。

**那什么是哈希冲突呢？**

举个例子，有一个可以存放8个哈希桶的哈希表。key1经过哈希函数计算后，再将哈希值 % 8 进行取模计算，结果值为1，那么就对应哈希桶1，类似的，key9和key10分别对应哈希桶1和桶6。

<img src=".\images\753724a072e77d139c926ecf1f049b29.png" alt="img" style="zoom:67%;" /> 

此时，key1和key9对应到了相同的哈希桶中，这就发生了哈希冲突。

因此，当有两个以上数量的key被分配到了哈希表中同一个哈希桶上时，此时就认为这些key发生了哈希冲突。





#### 使用链式哈希解决哈希冲突

链式哈希，也就与Java中HashMap使用链表的方式来解决哈希冲突的方式一样。

**链式哈希是怎么实现的？**

实现的方式就是每个哈希表节点都有一个next指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用next指针构成一个单向链表，**被分配到同一个哈希桶中的多个节点可以用这个单向链表连接起来**，这样就解决了哈希冲突。

还是使用前面哈希冲突的例子，key1和key9经过哈希计算后，都落在同一个哈希桶中，此时就会使用链式哈希，将key1使用next指针指向key9，形成一个单向链表：

![img](.\images\675c23857a36b2dab26ed2e6a7b94b5d.png)

**链式哈希存在着局限性，随着链表长度的增加，在查询这一位置上的数据耗时也会增加，因为链表查询的时间复杂度是`O(n)`**。（所以，在HashMap中，链表中元素达到一定数量后，会将链表转换成红黑树，但是Redis中没有这样实现）

要想解决这一问题，就需要进行`rehash`，也就是对哈希表的大小进行扩展，现在我们来看看Redis是如何实现rehash的。



#### rehash（:star2:）

##### 普通rehash

我们在上一节中，介绍了Redis使用dictht结构体来表示哈希表，不过，在实际使用哈希表时，Redis定义了一个dict结构体，在Redis键值保存流程中也有图示说明该结构体：

![image-20240725085830503](.\images\image-20240725085830503.png) 

这个结构体中，定义了**两个哈希表（ht[2]）**：

```c
typedef struct dict {
    …
    //两个Hash表，交替使用，用于rehash操作
    dictht ht[2]; 
    …
} dict;
```

之所以定义2个哈希表，是因为在进行rehash的时候，需要使用上两个哈希表：

<img src=".\images\2fedbc9cd4cb7236c302d695686dd478.png" alt="img" style="zoom:67%;" /> 

在正常服务请求阶段，插入的数据，都会写入到`哈希表1`，此时的`哈希表2`并没有被分配空间。

随着数据逐步增多，触发了rehash操作，这个过程分为三步：

1. 给哈希表2分配空间，一般是哈希表1的两倍；
2. 将哈希表1的数据迁移到数据表2中；
3. 迁移完成后，哈希表1的空间会被释放，并把哈希表2设置为哈希表1，然后在哈希表2新创建一个空的哈希表，为下次rehash做准备。

为了方便理解，将上面三个过程画在了下面这张图中：

![img](.\images\cabce0ce7e320bc9d9b5bde947b6811b.png) 

这个过程看起来简单，但是存在一个问题：

**如果哈希表1的数据量非常大，那么在迁移至哈希表2的时候，会涉及大量的数据拷贝，此时可能会对Redis造成阻塞，无法服务其他请求。**



##### 渐进式rehash

为了避免rehash在数据迁移过程中，因拷贝数据的耗时，影响Redis的性能，所以Redis采用了渐进式rehash，也就是数据迁移的过程不再是一次性完成，而是分多次进行迁移。

**渐进式rehash步骤如下所示：**

> * `给哈希表2分配空间；`
> * `在rehash进行期间，每次对哈希表进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作以外，还会按照顺序将哈希表1中索引位置上所有的key-value迁移到哈希表2中；`
> * `随着处理客户端发起的哈希表操作请求数量越多，最终某个时间点会把哈希表1的所有key-value都迁移到哈希表2，从而完成rehash操作。`

这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求过程中，避免了一次性rehash的耗时操作。

**注意：**

* **在进行渐进式rehash操作的过程中，数据分别存放在两个哈希表中，所以在渐进式rehash进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表中进行。**

  比如，去查找一个key的值的话，会先去哈希表1中进行查找，如果没有找到，再去哈希表2中进行查找。

* **在渐进式rehash进行期间，新增一个key-value时，会被保存到哈希表2中，而哈希表1则不再进行任何添加操作，这样保证了哈希表1的key-value数量只会减少，随着rehash操作的完成，最终哈希表1就会变成空表。**



##### rehash触发条件

rehash的触发条件跟`负载因子（load factor）`有关。

Redis负载因子的计算公式如下：

![img](.\images\85f597f7851b90d6c78bb0d8e39690fc.png)

也就是使用dictht结构中的used属性 / size属性：

> **`loadFactor = used / size`**

used属性表示哈希表中已有的节点数量，size表示哈希表的大小，也就是桶的数量。

触发rehash操作的条件，主要有两个：

> * **当`负载因子大于等于1`时，在Redis没有执行bgsave命令或者bgrewriteaof命令，也就是没有执行RDB快照或者AOF重写的时候，就会进行rehash操作**。
> * **当`负载因子大于等于5`时，此时说明哈希冲突非常严重了，不管有没有在执行RDB快照或AOF重写，都会强制进行rehash操作。**







---

### 8、整数集合intset

整数集合是Set对象的底层实现之一，**当一个`Set对象中只包含整数值元素，并且元素数量不大于512时`，就会使用整数集合这个数据结构作为底层实现。**

**特征：**

1. 长度可变
2. 有序
3. 元素唯一



#### 整数集合结构设计

整数集合本质上是一块连续内存空间，它的结构定义如下：

```c
typedef struct intset {
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
} intset;
```

可以看到，保存元素的容器是一个contents数组，虽然contents被声明成int8_t类型的数组，但是实际上**contents[]数组并不保存任何int8_t类型的元素，contents数组的真正类型取决于intset结构体里encoding属性的值**。比如：

- 如果 encoding 属性值为 `INTSET_ENC_INT16`，那么 contents 就是一个 `int16_t` 类型的数组，数组中每一个元素的类型都是 `int16_t`，范围类似于Java的short，存入的整数数值大小范围在`-2^15 ~ 2^15-1`都会使用该属性值；
- 如果 encoding 属性值为 `INTSET_ENC_INT32`，那么 contents 就是一个 `int32_t` 类型的数组，数组中每一个元素的类型都是 `int32_t`，范围类似于Java的int，存入的整数数值大小范围在`-2^31 ~ 2^31-1`都会使用该属性值。
- 如果 encoding 属性值为 `INTSET_ENC_INT64`，那么 contents 就是一个 `int64_t` 类型的数组，数组中每一个元素的类型都是 `int64_t`，范围类似于Java的long，存入的整数数值大小范围在`-2^63 ~ 2^63-1`都会使用该属性值。

不同类型的contents数组，意味着数组的大小也会不同。**encoding属性的值决定了整数数组中每个元素的大小，而不是由contents[]数组的类型int8_t来决定的**。

案例：

为了方便查找，Redis会将intset中所有的整数**按照`升序`进行排序**，依次保存在contents数组中，结构如图所示：

![image-20240725214905149](.\images\image-20240725214905149.png) 

在上例中，由于intset中的元素是5、10、20，数值大小在-2^15 ~ 2^15-1范围内，此时encoding属性使用的是INTSET_ENC_INT16，那么此时contents[]数组中国每个元素的类型名都是int16_t，类似于Java中的short，也就是每个元素都占用2个字节。每部分占用的字节数为：

* encoding：4个字节（uint32_t表示使用32位的无符号bit来表示该属性值，也就是4个字节）；
* length：4个字节；
* contents：2字节 * 3 = 6字节。





#### 整数集合的升级操作（:star:）

整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展contents数组的空间大小，然后才能将新元素加入到整数集合中，当然升级的过程中，也要维持整数集合的有序性。

整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后再将每个元素按照间隔类型大小分割，如果encoding属性为INTSET_ENC_INT16，则每个元素的间隔就是16位。

举个例子，假设有一个整数集合里有3个类型为int16_t的元素。

![img](.\images\5dbdfa7cfbdd1d12a4d9458c6c90d472.png) 

现在，往这个整数集合中加入一个新元素65535，超过了int16_t的范围（-2^15 ~ 2^15-1），这个新元素需要int32_t类型来保存，此时整数集合要进行升级操作。

**升级操作的流程如下**：

> 1. 升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式及元素个数扩容数组；
> 2. 倒序依次将数组中的元素拷贝到扩容后的正确位置；（如果使用顺序的话，前面扩容后可能会将原位置的数据进行覆盖）
> 3. 将待添加的元素加入到数组末尾；
> 4. 最后，将intset的encoding属性修改为INTSET_ENC_INT32，将length属性修改为4。



那么对于上面的案例，实际的升级流程如下所示：

首先需要为contents数组扩容，**在原本空间的大小之上再扩容多80位（4x32 - 3x16 = 80），这样就能够确保存下4个类型为int32_t的元素**。

![img](.\images\e2e3e19fc934e70563fbdfde2af39a2b.png) 

扩容完contents数组空间大小后，需要将之前的三个元素转换为int32_t类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：

![img](.\images\e84b052381e240eeb8cc97d6b729968b.png)

最后，会将该intset对象的length属性修改为4，表示实际存储了4个元素；encoding属性修改为INTSET_ENC_INT32，表示数组中的每个元素都是int32_t类型，也就是使用了4个字节来存储整数数据。



> **整数集合升级有什么好处呢？**

如果要让一个数组同时保存int16_t、int32_t、int64_t类型的元素，最简单的做法是直接使用int64_t类型的数组。不过这样的话，当元素都是int16_t类型的话，就会造成内存的浪费。

整数集合升级就能够避免出现这种情况，如果一直向整数集合添加int16_t类型的元素，那么整数集合的底层实现就一直是用int16_t类型的数组，只有在我们将int32_t类型或者int64_t类型的元素添加到集合中时，才会对数组进行升级操作。

因此，整数集合升级的好处是**`节省内存资源`**。



> **整数集合支持降级操作吗？**

**`不支持降级操作`**，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了65535元素，整数集合的数组还是int32_t类型的，不会因此降级成为int16_t类型。





**总结：**

1. Redis会确保IntSet中元素的唯一性、有序性
2. 具备类型升级机制，可以节省内存空间
3. 底层采用二分查找方式来进行查询





---

### 9、跳表skiplist（:star:）

Redis只有ZSet对象的底层实现用到了跳表，跳表的优势是能**支持时间复杂度平均为`O(logN)`的节点查找**。

ZSet结构体里有两个数据结构：一个是跳表，一个是哈希表。这样做的好处是技能进行高效地范围查询，也能进行高效地单点查询。

```c
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```

ZSet对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新响应的数据，从而保证了跳表和哈希表中记录的信息一致。

ZSet对象能支持范围查询（如ZRANGEBYSCORE操作），这是因为它的数据结构采用了跳表，而又能以常数复杂度获取元素权重（如ZSCORE操作），这是因为它同时采用了哈希表进行索引。

可能很多人奇怪，为什么我说ZSET对象底层数据结构是listpack或者跳表，而没有说哈希表呢？

ZSET对象在使用跳表作为数据结构的时候，是使用由`哈希表+跳表`组成的struct zset，但是我们讨论的时候，都会说跳表是ZSet对象的底层数据结构，而不会提及哈希表，是因为struct zet中的哈希表只是用于获取元素权重的操作，该操作的时间复杂度是O(1)，大部分操作都是使用跳表来完成的。

那么，我们接下来详细地说说跳表。

#### 跳表结构设计

链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)。**跳表是在链表基础上进行改进得到的，实现了一种`多层`的有序链表**，这样做的好处是能够快速定位数据。

那跳表张什么样子呢？我们这里举一个例子，下图展示了一个层级为3的跳表：

![img](.\images\2ae0ed790c7e7403f215acb2bd82e884.png) 

图中头节点有L0~L2三个指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：

* L0层级共有5个节点，分别是节点1、2、3、4、5；
* L1层级共有3个节点，分别是节点2、3、5；
* L2层级只有1个节点，也就是节点3。

如果我们要在链表中查找节点4这个元素，只能从头开始遍历链表，需要查找4次，而使用了跳表后，只需要查找2次就能够定位到节点4，因为可以从头节点直接从L2层级跳到节点3，然后再往前遍历找到节点4。

可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。**当数据很大时，跳表查找的时间复杂度是`O(logN)`**。

那跳表节点是如何实现多层级的呢？这就需要看跳表节点的数据结构了，如下所示：

```c
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
  
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```













#### 跳表节点查询过程















#### 跳表节点层数设置

















#### 为什么使用跳表而不使用平衡树？





























---


## 各种数据类型的编码（:star:）

### String

String类型的底层数据结构是**`int`和`SDS`（简单动态字符串）**。

字符串对象的内部编码（encoding）有三种：**`int`**、**`embstr`**和**`raw`**，这三种编码类对象所对应的数据结构是：

![img](.\images\string结构.png)



**int**

如果一个字符串对象保存的是整数值，并且这个整数值可以使用`long`类型来表示，即存入的正数满足下面的要求：

* long数据类型是64位、有符号的以二进制补码表示的整数

* 最小值是-2^63

* 最大值是2^63-1

  （数字最多有19位）

那么字符串对象会将整数值直接保存在字符串对象结构的`ptr`属性中（将void*类型转换成long类型），而不是使用指针去指向一段内存空间，并将字符串编码设置为`int`。

此时，就不需要SDS数据结构了，直接将数据保存在ptr属性中。

![image-20240725205117593](.\images\image-20240725205117593.png)  

**注意：`只有整数才会使用int`，如果是浮点数，Redis内部其实先将浮点数转化成字符串值，然后再保存。**

案例：

<img src=".\images\image-20240724160602909.png" alt="image-20240724160602909" style="zoom: 80%;" />  

当我们存入的是普通的整数型数据时，在long类型数据的范围内时，此时底层是使用long数据进行存储的，编码方式是int；如果存入的数据超出了long类型数据的范围，比如上例长度大于等于20的整数，此时由于long类型无法存储这么大的数据，那么就会将该数字转换成字符串类型，使用SDS的数据类型存储，编码方式变为了embstr（长度小于44字节）或者raw（长度大于等于44字节）。





**embstr**

如果字符串对象保存的是一个字符串，并且这个**字符串的长度`小于44字节`**，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串数据，并且将**对象的编码格式设置为`embstr`**，`embstr`编码是专门用于保存短字符串的一种优化编码方式：

![image-20240725205220572](.\images\image-20240725205220572.png)

可以看到，embstr类型的对象将redisObject对象和SDS数据对象存放在一个连续的内存空间里。



**raw**

如果字符串对象保存的是一个字符串，并且这个**字符串的长度`大于44字节`**时，那么字符串对象将使用一个简单动态字符串（SDS）来保存，并将该对象的**编码设置为`raw`**：

![image-20240725205313296](.\images\image-20240725205313296.png) 

可以看到，raw类型的string对象是将redisObject对象和SDS对象数据存放在不同的内存空间中。



即：

embstr和raw编码都会使用SDS来保存值，但不同之处在于：

`embstr`会通过一次内存分配函数来分配**一块连续的内存空间**来保存`redisObject`和`SDS`；

而`raw`编码会通过调用两次内存分配函数来分别**分配两块空间保存**`redisObject`和`SDS`。

embstr这样做有很多**好处**：

* embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次，**`效率更高`**。
* 释放embstr编码的字符串对象同样只需要调用一次内存释放函数；
* 因为embstr编码的字符串对象所有数据都保存在一块连续的内存里，可以**`更好地利用CPU缓存提升性能`**。

但是，embstr也存在着**缺点**：

* 如果字符串的长度增加需要重新分配内存时，整个redisObject和SDS都需要重新分配空间，所以，**`embstr编码的字符串对象实际上是只读的`**，redis没有为embstr编码的字符串对象编写任何响应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令时（如append），程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。



案例1：

<img src=".\images\image-20240724160941893.png" alt="image-20240724160941893" style="zoom:67%;" /> 

当我们存入的数据是小于44字节长度的字符串时，此时redisObject的编码方式是embstr；如果我们存入的数据是大于等于44字节长度的字符串时，此时redisObject的编码方式变为了raw。



案例2：

![image-20240724162227821](.\images\image-20240724162227821.png) 

对于embstr来说，它是只读的，如果对embstr对象进行修改时，比如使用APPEND命令进行添加，那么会将embstr先转换成raw，然后再进行修改。此时，无论字符串的长度是否达到了44字节，字符编码都是raw。





**总结**

* 只有整数才会使用int，如果是浮点数，Redis内部其实先将浮点数转换成字符串值，然后再保存；
* embstr与raw类型底层的数据结构其实都是SDS（简单动态字符串，Redis内部定义sdshdr一种结构）。

**三者的区别如下：**

| 编码类型     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| **`int`**    | 存入Long类型整数时，redisObject中的ptr指针直接赋值为整数数据，不再额外的指向整数了，节省了指针的空间开销。 |
| **`embstr`** | 当保存的是字符串数据且字符串小于等于44字节时，embstr类型将会调用内存分配函数，**只分配一块连续的内存空间**，空间中依次包含redisObject和SDS两个数据结构，让元数据、指针和SDS是一块连续的内存空间，这样就可以避免内存碎片。 |
| **`raw`**    | 当字符串大于44字节时，SDS的数量变多变大了，SDS和RedisObject布局分开，会给SDS分配多的空间并用指针指向SDS结构，raw类型将会**调用该两次内存分配函数**，分配两块内存空间，一块用于包含redisObject结构，而另一块用于包含SDS结构。 |

因为int编码格式直接将数据保存在ptr这个属性中，不会去申请额外的空间来保存SDS结构的字符串，所以能够使用int编码格式就使用int；

若保存的字符串中不是整数，此时只能使用embstr或者raw编码格式，又因为embstr编码格式只分配一块连续的内存空间，而raw编码格式则需要分配两块内存空间，所以尽量保证保存的字符串长度不超过44字节，从而去使用embstr的编码格式，来提高效率并且更好地使用CPU缓存。









---

### List

在Redis 3.2之前的版本，List数据类型的底层数据结构是由**双向链表或压缩列表**来实现的：

* 如果列表的元素个数小于`512`（默认值，可由list-max-ziplist-entries参数配置），列表每个元素的值都小于`64`字节（默认值，可由list-max-ziplist-value配置），Redis会使用**压缩列表**作为List类型的底层数据结构；

* 如果列表的元素不满足上面的条件，Redis会使用**双向链表**作为List类型的底层数据结构。

在Redis 3.2版本之后，List数据类型底层数据结构就是由**`quicklist`**实现了，代替了双向链表和压缩列表，此时的**`quicklist = 双向链表 + ziplist压缩列表`**；

在Redis 7版本以后，**quicklist中底层的ziplist压缩列表使用了listpack代替**，此时的**`quicklist = 双向链表 + listpack`**，那么此时，由于listpack中没有prevlen字段去记录上一个节点的长度，也就不存在压缩列表的连锁更新问题。







---

### Hash

Hash类型的底层数据结构是由**压缩列表或哈希表**实现的：

* 如果哈希类型元素个数小于512个（默认值，可由hash-max-ziplist-entries配置），所有值小于64字节（默认值，可由hash-max-ziplist-value配置）的话，Redis会使用压缩列表作为Hash类型的底层数据结构；
* 如果哈希类型元素不满足上面条件，Redis会使用哈希表作为Hash类型的底层数据结构。

在Redis 7.0中，使用listpack来代替压缩表，那么此时Hash类型的数据底层是使用**listpack紧凑列表或哈希表**来实现的。









---

### Set

Set类型的底层数据结构是由**哈希表或整数集合**实现的：

* 如果集合中的元素**都是整数且元素个数小于512**（默认值，通过set_maxintset-entries配置），Redis会使用整数集合作为Set类型的底层数据结构；

* 如果集合中的元素不满足上面的条件，则Redis使用哈希表作为Set类型的底层数据结构。



---

### ZSet















---

# 二、Redis网络模型































