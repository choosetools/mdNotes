[TOC]



# 一、相关概念

## 1、多线程是什么？

现代操作系统（Windows，macOs，Linux）都可以执行多任务。

多任务就是同时运行多个任务，例如：edge、QQ、微信等，CPU执行代码都是一条一条顺序执行的，但是，即使是单核CPU，也可以同时运行多个任务。因为**操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行**。

例如，让浏览器执行0.001每秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在别人宏观看来，CPU就是在同时执行多个任务，但是微观上来说，单核CPU一次只执行一个任务。

即便是多核CPU，因为通常任务的数量远远多余CPU的核数，所以任务也是交替执行的。



## 2、程序、进程与线程

* **程序（program）**：为完成特定任务，用某种语言编写的`一组指令的集合`。即指`一段静态的代码`，静态对象。

* **进程（process）**：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。

  * 每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）
  * 程序是静态的，进程是动态的
  * 进程作为`操作系统调度和分配资源的最小单位`（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。
  * 现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。

* **线程（thread）**：进程可进一步细化为线程，是程序内部的`一条执行路径`。一个进程中至少有一个线程。例如，我们在使用word时，word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。

  - 一个进程同一时间若`并行`执行多个线程，就是支持多线程的。

    <img src=".\images\image-20220331233204504.png" alt="image-20220331233204504" style="zoom:67%;" />

  - 线程作为`CPU调度和执行的最小单位`。

  - 一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来`安全的隐患`。



> **`进程是操作系统调度和分配资源的最小单位。`**
>
> **`线程是CPU调度和执行的最小单位。`**

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。

![image-20231208173056787](.\images\image-20231208173056787.png)

常见的Windows、Linux等操作系统都采用**`抢占式多任务`**，即如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间，但是我们可以给线程增加优先级，让系统调度时多考虑考虑调度该线程，但实际调度与否我们无法控制。

**什么是抢占式调度？**

让`优先级高`的线程以`较大的概率`优先使用CPU。如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。操作系统使用的也是抢占式调度。

![抢占式调度](.\images\抢占式调度.bmp)

因为一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：

多进程模式（每个进程只有一个线程）：

![image-20231208173535265](.\images\image-20231208173535265.png)

多线程模式（一个进程有多个线程）：

![image-20231208173600489](.\images\image-20231208173600489.png)

多进程+多线程模式（复杂度最高）：

![image-20231208173633901](.\images\image-20231208173633901.png)

**进程 vs 线程**

进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程+多线程。具体采用哪种方式，要考虑进程和线程的特点。

|        | 优点                                                         | 缺点                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 多进程 | 稳定性高（一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃） | 开销大（创建进程比创建线程开销大）通信慢（进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。） |
| 多线程 | 开销小、通信快                                               | 稳定性差、复杂度高（多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难） |

Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。

![img](.\images\f86be0ff79da458eb3d852b27a8c119b.png)



## 3、多线程程序的优点

**背景**：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？

**多线程程序的优点：**

1. 提高应用程序的相应。对图形化界面更有意义，可增强用户体验。
2. 提高计算机系统CPU的利用率。
3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。



## 4、单核CPU和多核CPU

单核CPU，在一个时间单元内，只能执行一个线程的任务。例如，可以把CPU看成是医院的医生诊室，在一定时间内只能给一个病人诊断治疗。所以单核CPU就是，代码经过前面一系列的前导操作（类似于医院挂号，比如有10个窗口挂号），然后到cpu处执行时发现，就只有一个CPU（对应一个医生），大家排队执行。

这时候想要提升系统性能，只有两个办法，要么提升CPU性能（让医生看病快点），要么多加几个CPU（多整几个医生），即为多核CPU。

`问题：多核的效率是单核的倍数吗？`譬如4核A53的cpu，性能是单核A53的4倍吗？理论上是，但实际不可能，至少有两方面的损耗。

* `一个是多个核心的其他共用资源限制。`譬如，4核CPU对应的内存，cache、寄存器并没有同步扩充4倍。这就好像医院一样，1个医生换4个医生，但是做B超检查的还是一台机器，性能瓶颈就从医生转到B超检查了。
* `另一个是多核CPU之间的协调管理损耗。`譬如多个核心同时运行两个相关的任务，需要考虑任务同步，这也需要消耗额外性能。好比公司工作，一个人的时候至少不用开会浪费时间，自己跟自己商量就行了。两个人就要开会同步工作，协调分配，所以工作效率绝对不可能达到2倍。



## 5、并行和并发

* **并行（parallel）**：指两个或多个事件在`同一时刻`发生（同时发生）。指在同一时刻，有`多条指令`在`多个CPU`上`同时`执行。比如：多个人同时做不同的事。

事。

![image-20220401000804242](.\images\image-20220401000804242.png)

* **并发（concurrency）**：指两个或多个事件在`同一时间段内`发生。即在一段时间内，有`多条指令`在`单个CPU`上`快速轮换、交替`执行，使得在宏观上具有多个进程同时执行的效果。

![image-20220401000515678](.\images\image-20220401000515678.png)

在操作系统中，启动了多个程序，`并发`指的是在一段时间内宏观上有多个程序同时运行，这在单核CPU系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。

而在多核CPU系统中，则这些可以`并发`执行的程序便可以分配到多个CPU上，实现多任务`并行`执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。



# 二、创建和启动线程的方式

## 1、概述

* Java语言的JVM允许程序运行多个线程，使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。
* Thread类的特性
  * 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，因此把run()方法体称为`线程执行体`。
  * 通过该Thread对象的**`start()`**方法来启动这个线程，而非直接调用run()方法。
  * 要想实现多线程，必须在主线程中创建新的线程对象。

**无论使用哪一种方式去创建多线程，都必须创建Thread对象，通过Thread对象中的start()方法启动：**

**`start()`方法的作用是：**

1. 启动线程
2. 调用Thread类中的run()方法



## 2、方式1：继承Thread类

Java通过继承Thread类来**创建**并**启动多线程**的步骤如下：

> 1. 创建一个继承于`Thread`类的子类
> 2. 重写`Thread`类的`run()`方法，将此线程要执行的操作，声明在`run()`方法体中
> 3. 创建当前`Thread`类的子类的对象
> 4. 通过对象调用`start()`

代码案例：

```java
public class EvenNumberTest {
    public static void main(String[] args) {
        PrintNumber t1 = new PrintNumber();
        t1.start();
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "中的main()方法");
        }
    }
}

class PrintNumber extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "中的run()方法");
        }
    }
}
```

打印结果：

<img src=".\images\image-20231209201515232.png" align="left">

可以发现，创建了一个线程，该线程名为Thread-0，main方法的线程名为main。



**`Thread.currentThread()`**：用于获取当前的线程

其中的`getName()`方法用于获取当前线程名。

![image-20231209192416851](.\images\image-20231209192416851.png)

在创建线程对象的时候，就会给线程取名，取名的方式是：`Thread-nextThreadNum()`，其中nextThreadNum()的返回值根据threadInitNumber的值，初始值是0，每次创建一个线程都会+1。

![image-20231209192602068](.\images\image-20231209192602068.png)



对于只使用一次的线程，我们一般使用**匿名子类的对象**方式去创建：

例如，创建两个线程，一个线程打印100以内所有的奇数，一个线程打印100以内所有的偶数：

```java
public class EvenNumberTest {
    public static void main(String[] args) {
        Thread t1 = new Thread(){
            @Override
            public void run() {
                for (int i = 1; i < 100; i += 2) {
                    System.out.println(i);
                }
            }
        };
        Thread t2 = new Thread(){
            @Override
            public void run() {
                for (int i = 2; i <= 100; i += 2) {
                    System.out.println(i);
                }
            }
        };
        t1.start();
        t2.start();
    }
}
```

<img src="images/image-20220401221215860.png" alt="image-20220401221215860" style="zoom:67%;" />

> **注意：**
>
> 1. 如果要想启动多线程，必须调用**`start()`**方法，而不能调用run()方法。单纯调用run()方法不会启动线程，不会分配新的分支线。
>
>    start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了，线程就启动成功了。
>
> 2. run()方法由JVM调用，什么时候调用、执行的过程控制都有操作系统的CPU。run()方法在分支栈的底部，main方法在主栈的栈底部，run和main是平级的。
>
> 3. 一个线程对象只能调用一次start()方法启动多线程，如果多调用了，则将抛出异常：**`IllegalThreadStateException`**。





## 3、方式2：实现Runnable接口

Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法。

**步骤如下：**

> 1. 定义`Runnable`接口的实现类，并重写该接口的``run()`方法，该`run()`方法的方法体同样是该线程的线程执行体。
> 2. 创建`Runnable`实现类的实例，并以此实例作为`Thread`的`target`参数来创建`Thread`对象，该`Thread`对象才是真正的线程对象。
> 3. 调用线程对象的`start()`方法，启动线程。此时，就会去调用Runnable接口实现类中的run()方法。

Runnable接口只提供一个run()方法，我们无论是使用继承Thread类的方式创建多线程，还是使用实现Runnable接口的方式实现，实际上都是重写了该run()方法，然后通过Thread类去创建多线程。

![image-20231210110536153](.\images\image-20231210110536153.png)



在使用实现Runnable接口创建多线程这种方式时，可以使用采取一种参数的构造器，也可以使用两种参数的构造器：

![image-20231209222716130](.\images\image-20231209222716130.png)

其中，两种参数的构造器第二个参数用于指定新建的线程名称。

**使用案例：**

```java
class EvenNumberPrint implements Runnable{
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
         System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}

public class EvenNumberTest {
    public static void main(String[] args) {
        EvenNumberPrint p = new EvenNumberPrint();
        Thread t1 = new Thread(p);
        //第二个参数可用于指定线程名
        Thread t2 = new Thread(p, "第二条线程");
        t1.start();
        t2.start();
        //main()方法对应的主线程执行的操作
        for (int i = 1; i <= 100; i++) {
		 System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
```

打印结果：

<img src=".\images\image-20231209224710236.png" align="left">

同样地，对于使用实现Runnable接口的方式创建多线程，也可以使用匿名实现类的方式。当该线程只使用一次，或者只在当前类中使用的情况下，就可以使用匿名实现类的方式去创建Runnable接口的实现类，从而创建多线程。

案例：

```java
new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
          			System.out.println(Thread.currentThread().getName() + ":" + i);
                }
            }
        }).start();
```

这里就是给Thread构造器中的target参数进行了匿名实现类的创建。

通过实现Runnable接口，使得该类有了多线程类的特征。所有的分线程要执行的代码都在run()方法里面。

在启动多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。

实际上，所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。

说明：Runnable对象仅仅作为Thread对象的target，Runnable实现类里面包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。



> 对于以上两种创建线程的方式，更加推荐第二种，即使用实现Runnable接口的方式去创建多线程。



## 4、对比两种方式

**联系**：

实际上，Thread类也是实现了Runnable接口的类。即：

```java
public class Thread extends Object implements Runnable
```

即Thread类中的run()方法也是通过实现Runnable接口获得的，我们使用继承Thread类的方式去创建多线程中，重写的run()方法追根到底是重写的Runnable接口中的run()方法。

这里其实是一种设计模式：代理模式

原本我们是需要去实现Runnable接口，重写其中的run()方法，从而创建多线程；

但是如果我们通过继承Thread类的方式去创建多线程，实际上Thread也是通过实现Runnable接口的方式去创建多线程，所以Thread是一个代理类，我们通过这个代理类间接地实现Runnable接口，从而创建多线程。

![image-20231209230814874](.\images\image-20231209230814874.png)

Thread类中的run()方法实际上调用的就是Runnable接口中的run()方法。

**区别**：

- 继承Thread：线程代码存放Thread子类run方法中。

- 实现Runnable：线程代码存在接口的子类的run方法。

**实现Runnable接口比继承Thread类所具有的优势**

- 避免了单继承的局限性
- 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。
- 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。

**使用匿名内部类对象来实现线程的创建和启动**

```java
new Thread("新的线程！"){
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(getName()+"：正在执行！"+i);
		}
	}
}.start();
```

```java
new Thread(new Runnable(){
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(Thread.currentThread().getName()+"：" + i);
		}
	}
}).start();
```



## 5、方式3：实现Callable接口(JDK5.0新增)

**使用实现Callable接口的方式创建多线程过程如下：**

> 1. 创建一个实现`Callable`接口的实现类
> 2. 重写`call()`方法，将此线程需要执行的操作声明在`call()`方法中
> 3. 创建`Callable`接口实现类的对象
> 4. 将此`Callable`实现类的对象作为参数传递到`FutureTask`构造器中，创建`FutureTask`的对象。
> 5. 将`FutureTask`的对象作为参数传递到`Thread`类的构造器中，创建`Thread`对象，并调用`start()`方法
> 6. 若有返回值，则使用`FutureTask`对象调用get()方法获取

使用Callable实现类创建线程，我们来看一下这个Callable接口：

![image-20231214225341955](.\images\image-20231214225341955.png)

可以看到这个接口是支持泛型的

call()方法也是可以抛出异常，有返回值的。

所以，与实现Runnable的方式创建多线程相比，**Callable功能更加强大：**

* 相比于`run()`方法，`call()`方法可以有返回值
* `call()`方法可以向上抛出异常，而`run()`方法中的异常只能通过`try-catch`进行处理
* call()支持带泛型的返回值，可以设置返回值的类型，而`run()`方法无返回值

但是Callable同样也有**缺点**：

由于`call()`方法带有返回值，当我们要去获取`call()`的返回值时，就必须等待线程执行完毕，故当前线程会被阻塞，效率较低。



**Future接口：**

* 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。
* **`FutureTask`是`Future`接口的唯一的实现类。**
* FutureTask同时实现了Runnable，Future接口。故它既可以作为Runnable接口的实现类的参数，也可以作为Future接口的实现类参数。
* **当FutureTask作为参数传入到Thread构造器中时，是作为Runnable接口的实现类传入的。**

**使用案例**：

```java
/*
 * 创建多线程的方式三：实现Callable （jdk5.0新增的）
 */
//1.创建一个实现Callable的实现类
class NumThread implements Callable {
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
                sum += i;
            }
        }
        Thread.sleep(10000);
        return sum;
    }
}


public class CallableTest {
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();

        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(futureTask).start();


//      接收返回值
        try {
            //6.获取Callable中call方法的返回值
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
            Object sum = futureTask.get();
            System.out.println("总和为：" + sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

}
```

在上例中，无论在Callable线程中需要花费多长时间，由于在主线程中去获取了线程执行方法的返回值，故主线程会一直BLOCKED阻塞地等待Callable线程中的call()方法执行完毕。这就是Callable线程存在的缺点。

## 6、方式4：使用线程池（JDK5.0新增）

以下只是线程池中的一小部分知识点，更多的知识请查看高并发笔记中。

**现有问题**：

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种方法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？

**思路**：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。

![线程池的理解](.\images\线程池的理解.jpg)

**好处**：

* 提高响应速度（减少了创建新线程的时间）
* 降低资源消耗（重复利用线程池中线程，不需要每次创建）
* 便于资源管理（重复利用线程池中线程，不需要每次都创建）
  * corePoolSize：核心池的大小
  * maximumPoolSize：最大线程数
  * keepAliveTime：线程没有任务时最多保持多长时间后会终止
  * ...

**线程池相关API**：

* JDK5.0之前，我们必须手动自定义线程池。从JDK5.0开始，Java内置线程池相关的API。在java.util.concurrent包下提供了线程池相关API：`ExecutorService`和`Executors`。

* `ExecutorService`：真正的线程池接口。常见子类`ThreadPoolExecutor`。
  * **`void execute(Runnable command)`**：执行任务/命令，没有返回值，**一般用来执行Runnable**。
  * **`<T> Future<T> submit(Callable<T> task)`**：执行任务，有返回值，**一般用来执行Callable**。
  * **`void shutdown()`**：关闭连接池
* **`Executors`**：线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。
  * `Executors.newCachedThreadPool()`：创建一个可根据需要创建新线程的线程池。
  * `Executors.newFixedThreadPool(int nThreads)`：创建一个可重用固定线程数的线程池
  * `Executors.newSingleThreadExecutor()`：创建一个只有一个线程的线程池
  * `Executors.newScheduledThreadPool(int corePoolSize)`：创建一个线程池，它可安排在给定延迟后运行命令或者定期执行。



代码举例：

```java
class NumberThread implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    @Override
    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread2 implements Callable {
    @Override
    public Object call() throws Exception {
        int evenSum = 0;//记录偶数的和
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                evenSum += i;
            }
        }
        return evenSum;
    }

}

public class ThreadPoolTest {

    public static void main(String[] args) {
        //1. 提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
//        //设置线程池的属性
//        System.out.println(service.getClass());//ThreadPoolExecutor
        service1.setMaximumPoolSize(50); //设置线程池中线程数的上限

        //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
        service.execute(new NumberThread());//适合适用于Runnable
        service.execute(new NumberThread1());//适合适用于Runnable

        try {
            Future future = service.submit(new NumberThread2());//适合使用于Callable
            System.out.println("总和为：" + future.get());
        } catch (Exception e) {
            e.printStackTrace();
        }
        //3.关闭连接池
        service.shutdown();
    }

}
```



# 三、Thread类的常用结构

## 1、构造器

* **`public Thread()`**：分配一个新的线程对象。
* **`public Thread(String name)`**：分配一个指定名字的新的线程对象。
* **`public Thread(Runnable target)`**：指定创建线程的目标对象，它实现了Runnable接口中的run()方法。
* **`public Thread(Runnable target, String name)`**：分配一个带有指定目标新的线程对象并指定名字。

对于第一种、第二种构造器，一般用于使用继承Thread的方式去创建多线程；

第三种、第四种构造器，一般用于使用实现Runnable接口的方式创建多线程。

对于未使用指定线程名的方式，创建的线程会使用默认的线程名称：

`Thread-创建的线程数量`（从0开始）



对于第二种构造器：public Thread(String name)，对应于继承于Thread类的方式创建多线程，由于需要创建一个Thread子类类，该子类中只有默认的空参构造器，所以若需要使用此构造器，则需要在类中创建一个带String参数的构造器，例如：

```java
class ThreadConstructor extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + i);
        }
    }
    
    //若想要使用带String参数的构造器创建Thread类
    //则需要在子类中也创建一个带参的构造器
    public ThreadConstructor(String name) {
        super(name);
    }
}

public class ThreadConstructorTest {
    public static void main(String[] args) {
        ThreadConstructor t1 = new ThreadConstructor("第一条线程");
        t1.start();
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + i);
        }
    }
}
```



## 2、常用方法及使用案例

### 常用方法

1. **`public void start()`**：①启动线程；②调用线程的run()方法。

   

2. **`public void run()`**：将线程要执行的操作，声明在run()方法中。

   

3. **`public static Thread currentThread()`**：获取当前正在执行的线程。若使用的是Thread子类的方式创建多线程，则在该类中可直接使用this表示当前线程。该方法一般用于主线程或使用Runnable接口的方式创建多线程中。

   

4. **`public String getName()`**：获取当前线程名称。

   

5. **`public void setName(String name)`**：设置该线程名称。

   

6. **`public static native void sleep(long millis) throws InterruptedException;`**：使当前正在执行的线程以指定的毫秒数**暂停**（暂时停止执行）。该方法会报编译时异常：`InterruptedException`，即中断异常。

   

7. **`public static void yield()`**：一旦执行到此方法，就**释放当前线程的CPU执行权**。执行该方法，是希望当前线程释放CPU执行权，让优先级更高或者相等的线程获得执行权，但是只是希望，没有一定。释放CPU执行权后，有可能优先级更低的线程获得执行权，也可能该线程重新又获取执行权。即该方法的作用在于让线程从“`运行状态`”回到“`就绪状态`”。注意：在回到就绪之后，当前线程有可能还会再次抢到CPU的执行权。

   

8. **`public final void join() throws InterruptedException`**：**暂停当前线程的执行，等待调用该方法的线程停止运行后，当前线程再执行**。

   该方法也会抛出编译时异常，需要进行try-catch处理。

   `void join(long millis)`：等待调用该方法的线程停止运行的时长最长为millis毫秒。如果millis时间已到，将不再等待。

   `void join(long millis, int nanos)`：等待线程停止的时间最长为millis毫秒 + nanos纳秒。

   join()方法是非static的，因为是需要指定当前线程等待哪一个线程停止执行完毕，故需要使用对象进行调用。

   若在当前线程中，使用当前线程对象去调用join方法，含义是当前线程等待当前线程停止执行后再去执行，听起来感觉很绕，实际的效果就是当前线程停止执行

   在实际的开发中，比如我们一个线程，要去联网获取结果，此时我们就可以另开一个线程，让另一个线程用于获取网络中的结果，当前线程使用join()方法等待另一个线程执行完毕，得到想要的结果后再去执行。

   

9. **`public final native boolean isAlive()`**：判断当前线程是否存活。

   

10. **`public final void stop()`**：**已过时**，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些请理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有锁，导致数据得不到同步的处理，出现数据不一致的问题。

    

11. **`void suspend()/void resume()`**：**已过时**，不建议使用。这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其他线程都无法访问被它占用的锁，直到调用resume()。







### 与优先级有关的方法

每个线程都有一定的优先级，同优先级线程组成先进先出（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。

* **Thread类的三个优先级常量：**
  * **`MAX_PRIORITY(10)`**：最高优先级
  * **`MIN_PRIORITY(1)`**：最低优先级
  * **`NORM_PRIORITY(5)`**：普通优先级，默认情况下main线程具有普通优先级。
* **`public final int getPriority()`**：返回线程的优先级
* **`public final void setPriority(int newPriority)`**：改变线程的优先级，范围在[1, 10]之间。

其实，优先级并不代表着一定、肯定的含义，而是表示**`概率`**。**优先级高的线程代表被CPU执行的概率更高，机会更大**，但不是一定，有可能优先级低的线程，CPU给与的资源更多，有可能优先级低的线程执行完毕了优先级高的线程还未执行，只不过优先级高的线程更有可能被执行罢了。



### 与线程间通信有关的方法

1. sleep()
2. wait()
3. notify()
4. notifyAll()

### 方法使用案例

* **sleep(long millis)方法案例：**

```java
public class ThreadConstructorTest {
    public static void main(String[] args) {
        ThreadConstructor t1 = new ThreadConstructor();
        t1.start();
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+ ":" + i);
        }

    }
}

class ThreadConstructor extends Thread{
    @Override
    public void run() {
        try {
            sleep(100);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
```

由于支线程开始睡眠了100毫秒，所以CPU一开始只能调用主线程进行执行。

<img src=".\images\image-20231210105532839.png" align="left">

注意：

**在run()方法中调用sleep()方法，只能使用try-catch方法处理异常**，不能使用throws向上抛，原因在于所有的run()方法都是重写Runnable接口中的run()方法，在Runnable接口中的run()方法没有抛异常：

![image-20231210105117548](.\images\image-20231210105117548.png)

对于重写的方法，其抛出的异常范围不能大于被重写的方法，run()方法未抛出异常，则其重写的方法也不能抛出异常，故其中的sleep()方法只能使用try-catch的方式处理。



* **yield()方法与优先级方法的使用案例：**

```java
//使用实现Runnable接口的方式创建线程
class PriorityTest implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}

public class ThreadPriorityTest {
    public static void main(String[] args) {
        //创建两个线程
        Thread t1 = new Thread(new PriorityTest(), "优先级为1的线程");
        Thread t2 = new Thread(new PriorityTest(),"优先级为10的线程");
        //设置两个线程的优先级，分别设置为1和10
        t1.setPriority(1);
        t2.setPriority(10);
        
        //其实默认情况下main线程的优先级就是5
        Thread.currentThread().setPriority(5);
        
        //启动线程
        t1.start();
        t2.start();
        for (int i = 0; i < 100; i++) {
            //释放CPU，目的是希望让优先级更高或者相等的线程执行，也可能出现优先级低的线程执行或者当前线程又继续执行的情况
            Thread.yield();
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}

```

部分打印结果：

<img src=".\images\image-20231210182648045.png" align="left">

从打印结果我们可以得知，释放main线程的执行权后，既有可能当前线程继续获得CPU执行权，继续执行；也有可能是优先级高的线程获得CPU的执行权；还有可能优先级低的线程获得。

其实，优先级并不代表着一定、肯定的含义，而是表示概率。优先级高的线程更高概率地获得CPU的执行权，优先级低的线程更低概率地获得CPU执行权，但不是一定，CPU有可能先去执行优先级低的线程，只不过优先级高代表着执行概率更高罢了。





* **join()方法使用案例：**

```java
public class ThreadConstructorTest {
    public static void main(String[] args) {
        ThreadConstructor t1 = new ThreadConstructor();
        t1.start();
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+ ":" + i);
            if (i == 20){
                try {
                    //等待t1线程执行完毕后，当前线程再执行
                    t1.join();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }

    }
}

class ThreadConstructor extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            try {
                sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(this.getName() + ":" + i);
            if (i % 20 == 0){
                Thread.yield();
            }
        }
    }
}
```

上例中，mian线程中，当i==20时，调用Thread-0线程的join()方法，意思是等待Thread-0线程执行完毕之后再去执行。打印结果：

<img src=".\images\image-20231210165303355.png" align="left">

同理，如果join()方法会抛出编译时异常，也只能使用try-catch进行处理。







# 四、多线程的生命周期(JDK1.5之后)

## 线程的六种状态

在java.lang.Thread.State的枚举类中这样定义线程的状态：

```java
public enum State {
	NEW,
	RUNNABLE,
	BLOCKED,
	WAITING,
	TIMED_WAITING,
	TERMINATED;
}
```

首先我们展示一下整个线程状态转换流程图，下面我们将进行详细的介绍讲解，如下图所示，我们可以直观的看到六种状态的转换。

* **`NEW`**-初始状态，一个新创建的线程，还没开始执行。
* **`RUNNABLE`**-可执行的状态，要么是在执行，要么是一切就绪等待执行，例如等待分配CPU时间。
* **`BLOCKED`**-被阻塞状态，等待锁，以便进入同步块中。
* **`WAITING`**-等待状态，等待其他线程去执行特定的动作，没有时间限制。
* **`TIMED_WAITING`**-限时等待状态，等待其他的线程去执行特定的动作，这个是在一定的时间范围内的。
* **`TERMINATED`**-终止状态，线程执行结束。

在我们程序编码中如果想要确定线程当前的状态，可以通过`getState()`方法来获取，同时我们需要注意任何线程在任何时刻都只能是处于一种状态。

![img](.\images\kvkfzsgic9.jpeg)

如上图，这些状态大体上可以分为两个部分：

（1）正常过程

创建线程（NEW），然后线程做自己的工作（RUNNABLE），做完之后就终止了（TERMINATED）。

（2）非正常情况

线程执行的时候遇到了点问题，需要等待（WAITING、TIMED_WAITING）一会儿，或者被人阻塞了(BLOCKED)。

线程结束等待之后，也可能进入到阻塞状态。

### 1、`NEW`

**创建新线程的状态，处于`NEW`的线程被创建出来后还未被执行的**。

NEW表示线程被创建但尚未启动的状态：当我们用new Thread()新建一个线程时，如果线程没有开始运行start()方法，那么线程也就没有开始执行run()方法里面的代码，那么此时它的状态就是NEW。而一旦线程调用了start()，它的状态就会从NEW 变为RUNNABLE。

下面的代码显示了一个NEW状态的线程：

```java
Thread t = new MyThread();
```

### 2、`RUNNABLE`

**我们创建一个线程，然后调用了`start()`方法，那么这个线程就从`NEW`变为了`RUNNABLE`状态。**

![img](..\images\ig8alffclf.jpeg)

Java中的RUNNABLE状态对应操作系统线程状态中的两种状态，分别是RUNNING和READY，也就是说，**Java中处于RUNNABLE状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配CPU资源**。

由于JVM无法控制CPU何时进行调度，所以JVM无法控制当前的线程是准备状态还是运行状态，故将原本属于两个状态的READY和RUNNING，将其归于一种线程状态RUNNABLE，这样方便JVM表示。

所以，如果一个正在运行的线程是RUNNABLE状态，当它运行到任务的一半时，执行该线程的CPU被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是RUNNABLE，因为它有可能随时被调度回来继续执行任务。

JVM中的`Thread-Scheduler`(线程调度器)会为每个线程分配一个固定的执行时间，所以一个线程一次就只执行一段时间，时间到了以后，就会让其他的RUNNABLE状态的线程执行。

下面的代码中，线程处于`RUNNABLE`状态：

```java
Thread t = new MyThread();
t.start();
```

### 3、`BLOCKED`

从**`RUNNABLE`**状态进入到**`BLOCKED`**状态只有一条途径，那就是当进入到**同步代码块**或**同步方法（synchronized）**中**未能获得相应的同步监视器**。

![img](.\images\v2-03a30146fded70f85d0a38f6efdf5551_720w.webp)

一个线程要执行的代码被其他线程锁了，所以被BLOCKED在这了，需要等其他线程释放锁后，当前线程获取到锁了，才能继续执行。

那么由此，我们也可以知道，从**`BLOCKED`**状态转变为**`RUNNABLE`**状态，也只有一种情况，那就是线程**获取到了同步监视器**，此时线程就会进入到RUNNABLE状态参与CPU资源的抢夺。

### 4、`WAITING`

对于WAITING状态的进入有三种情况，如下图所示，分别为：

* 当线程中调用了没有设置Timeout参数的**`Object.wait()`**方法
* 当线程调用了没有设置Timeout参数的**`Thread.join()`**方法
* 当线程调用了**`LockSupport.park()`**方法

![img](.\images\v2-ad7fb4f0e53a372d833b952f69b7696f_720w.webp)

对于LockSupport.park()方法，这里说一下，由上面我们可以知道BLOCKED是针对synchronized的同步监视器锁的，但是Java中还有其他的锁，比如ReentrantLock锁等，在这些锁中，如果线程没有获取到相应的锁时则会进入到WAITING状态，其实本质上就是执行了LockSupport.park()方法进入了WAITING状态。即：**`LockSupport.park()`方法相当于Lock锁中的`wait()`方法。**

因为wait()方法只能用在synchronized代码块或者方法中，不能用于Lock锁中。



例如：

我们创建并启动 1个线程 *threadA*

*threadA* 又创建了 *threadB*，然后启动

在 *threadA* 里面调用了 *threadB.join()*，那么这时 *threadA* 就进入了 *WAITING* 状态，直到 *threadB* 执行结束。



### 5、`TIMED_WAITING`

`TIMED_WAITING`和`WAITING`状态非常相似，其中的区别只在于是否有时间的限制，在`TIMED_WAITING`状态时若等待超时，则会由系统唤醒，或者也可以提前被通知唤醒，例如`notify()`。

![img](.\images\v2-cc5f3f449cd8bccbd020bb1d212efd2e_720w.webp)

通过上图，我们可以知道在以下情况下会让线程进入到TIMED_WAITING状态。

* 线程执行了设置时间参数的**`Thread.sleep(long millis)`**方法；
* 线程执行了设置时间参数的**`Object.wait(long timeout)`**方法；
* 线程执行了设置时间参数的**`Thread.join(long millis)`**方法；
* 线程执行了设置时间参数的**`LockSupport.parkNanos(long nanos)`**方法和**`LockSupport.parkUntil(long deadline)`**方法。



### 6、`TERMINATED`

这是线程生命结束的状态，一个线程的结束，有可能是正常执行完了，也有可能是异常终止了。

![img](.\images\6xsll7z8wx.jpeg)

## 线程状态间转换

上面我们讲了各自状态的特点和运行状态进入相应状态的情况，那么接下来我们将来分析各自状态的转换，其实主要的是BLOCKED、WAITING和TIMED_WAITING三种状态的转换，以及他们是如何进入到RUNNABLE的。

### BLOCKED 进入 RUNNABLE

想要从BLOCKED状态进入RUNNABLE状态，即通过获取同步监视器进入。

![img](.\images\v2-f6071eafdbda7436b00f06dd725f52a7_720w.webp)



### WAITING 进入 RUNNABLE

只有当执行了`LockSupport.unpark()`，或者`join`的线程运行结束，或者`被中断`时才可以进入RUNNABLE状态。

（LockSupport.unpark()方法相当于Lock锁中使用的notify()方法）

![img](.\images\v2-a647d98d5fbc94740a011ea24be88f7a_720w.webp)

如果通过其他线程调用notify()或notifyAll()来唤醒它，则它会直接进入BLOCKED状态，这里大家可能会有疑问，不是应该直接进入RUNNABLE状态吗？

原因在于被notify()唤醒的线程并不一定拥有同步监视器，notify()的作用只是唤醒线程，让线程从wait set中进入到ready queue准备队列中，由于wait()一定是在synchronized代码块或方法中的，所以线程开始执行的位置也一定在synchronized代码块中，此时由于线程并不拥有同步监视器，因为同步监视器此刻在执行notify()方法的线程手中，只有当该线程执行wait()方法释放手中的同步监视器或执行完synchronized代码块自动释放时，被唤醒的线程才能够去抢夺同步监视器，只有当它抢到了，才从BLOCKED状态回到RUNNABLE状态。

![img](.\images\v2-7944fe33e9546acc6437e18e40164a88_720w.webp)

所以我们需要注意的是，当我们通过notify唤醒线程时，线程是先进入阻塞状态的，等到其抢到了同步监视器时，才会进入到RUNNABLE状态。



### TIMED_WAITING进入RUNNABLE

TIMED_WAITING与WAITING进入RUNNABLE状态有些不同：

1. 若是通过notify()和notifyAll()的方式唤醒线程，那么与WAITING状态一样，会先进入BLOCKED状态，当抢到同步监视器后，再回到RUNNABLE状态。

![img](.\images\v2-e185809518035d5ffa28089a2d9eac2c_720w.webp)

2. 对于TIMED_WAITING而言，存在着超时机制。

   当超过设置的时间后，TIMED_WAITING状态的线程会直接拿到锁，或者调用join(timeout)的线程执行结束/被中断，或调用了LockSupport.unpark()都会直接进入到RUNNABLE状态，而不会经历BLOCKED状态。

![img](.\images\v2-68afcd3ee580cd42e80fe28f9c7c40e6_720w.webp)

## 总结

最后我们说一下再看线程转换的过程中一定要注意：

- 线程的状态是按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。
- 线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。
- 所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。也就是这两个状态不会参与相互转化



**参考资料：**

[线程的生命周期及其六种状态的转换 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/267331681)

[图解 Java 线程生命周期-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1683376)



# 五、线程的安全问题及解决方式

当我们使用多个线程访问**同一资源**（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程`只有读操作`，那么不会发生线程安全问题。但是如果多个线程对资源有`读和写`的操作，就容易出现线程安全问题。

举例：

<img src=".\images\image-20220401233218326.png" alt="image-20220401233218326" style="zoom:67%;" />

账户里面有3000块钱，你去取2000块钱，当还没取出来的时候，这个时候，若你妻子也去取2000块钱，因为你还没取出来2000块钱，判断还剩下3000块钱，则妻子也能够取出2000块钱。这个时候，若两个人都取2000块钱，都可以取出来，余额结果变为-1000了。

这就是因为余额这个变量，没有锁起来，两个都同时进行写操作，会造成线程安全问题。



## 1、 同一个资源问题和线程安全问题

案例：

火车站要卖票，我们模拟火车站的卖票过程。因为疫情期间，本次列车的座位共100个（即，只能出售100张火车票）。我们来模拟车站的售票窗口，实现多个窗口同时售票的过程。注意：不能出现错票、重票。

**理想状态下：**

![image-20231212110017910](.\images\image-20231212110017910.png)

**极端情况：**

![image-20231212110551388](.\images\image-20231212110551388.png)



示例代码：

```java
public class ThreadSafeTest {
    public static void main(String[] args) {
        SellTicket sell = new SellTicket();
        Thread t1 = new Thread(sell, "A号窗口");
        Thread t2 = new Thread(sell, "B号窗口");
        Thread t3 = new Thread(sell, "C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class SellTicket implements Runnable {

    private int ticketNum = 100;

    @Override
    public void run() {
        
        while (ticketNum > 0) {
            //使用sleep()方法，让结果更加明显
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName() + "卖出了一张票，票号是：" + ticketNum);
            ticketNum--;
        }
    }
}
```

部分打印结果：

<img src=".\images\image-20231212101726430.png" align="left">

<img src=".\images\image-20231212110910478.png" align="left">

发现出现了重号、错号的问题。

为什么会出现重号以及错号的问题呢？

重号：多个线程进入到循环语句中，当一个线程打印出来卖票的信息，但是还未对票数减一，此时失去了CPU的执行权，另一个线程获得了CPU的执行权，此时票数依旧未变，另一个线程打印出来卖票的信息，也就和之前打印出来的票号一致。

错号：打印结果中有0,-1号票，这些都是错号，原因在于当票数为1时，一个线程经过判断进入了循环，但是此时丧失了CPU执行权，另外两个线程也进入到了循环中，也开始执行循环，所以出现了0号票和-1号票这样错误的票号。



那么该如何解决这种问题呢？

必须保证一个线程在操作ticket的过程中，其他线程必须等待，直到线程a操作ticket结束后，其他线程才可以进来继续操作ticket。



## 2、同步机制解决线程安全问题

要解决上述多线程并发访问一个资源的安全性问题：也就是解决重复票和不存在票问题，Java提供了同步机制（`synchronized`）来解决。

![1563372934332](.\images\1563372934332.png)

根据案例简述：

窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1、窗口2和窗口3才有机会进行入代码区执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。

为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。注意：在任何使用，最多只允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着（BLOCKED）。

**说明**：

> * 需要被同步的代码，即为操作共享数据的代码。
> * 共享数据：即多个线程都需要操作的数据。比如：ticket
> * 需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其他线程必须等待。
> * 同步监视器，俗称锁。哪个线程获取了锁，哪个线程就能执行需要被同步的代码。
> * 同步监视器，可以使用任何一个类的对象充当。但是，多个线程必须共用同一个同步监视器。

### 2.1、同步机制解决线程安全问题的原理

同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。因为Java对象在堆中的数据包含对象头、实例变量、空白的填充。而对象头中包含：

* Mark Word：记录了和当前对象有关的GC、锁标记等信息。
* 指向类的指针：每一个对象需要记录它是由哪个类创建出来的。
* 数组长度（只有数组对象才有）

**哪个线程获得了“同步锁”对象之后，“同步锁”对象就会记录这个线程的ID**，这样其他线程就只有等待了，除非这个线程“释放”了锁对象，其他线程才能重新获得/占用“同步锁”对象。

所以，若需要控制多个线程对某一段代码有序执行，则需要使用到锁，这个锁必须是**`同一个对象`**，当进入到同步代码块中，会对“锁”对象进行判断是否拥有了其他的线程ID，如果已拥有，则BLOCKED；如果未拥有，则将该线程ID写入“锁”对象中，并继续执行。

![image-20231212151137174](.\images\image-20231212151137174.png)

### 2.2、方式一：同步代码块

**同步代码块**：synchronized关键字可以用于某个区块前面，表示只对这个区块的资源实现互斥访问。

**格式：**

```java
synchronized(同步锁){
	//需要同步操作的代码
}
```

> 对于同步代码块来说，同步锁对象是由程序员手动指定的，当线程均使用同一个Runnable实现类对象去创建时，大多数情况下使用**`this`**作为锁；当多个线程的创建使用的是同一个Thread子类创建时，由于对象不同，故不可使用this作为锁，大多数情况下使用**`当前类.class`**对象。

当然，你也可以使用其他的对象，只不过大多数情况下都会使用this或类名.class对象。

`当前类.class`也是一种对象，属于`Class`类，任何一个类，都有一个`Class`类的对象，`类.class`是固定的，一个类只有一个`类.class`，无论在类的哪一个对象中，`类.class`都是同一个。

**案例1：使用实现Runnable接口的方式去卖票**

```java
public class ThreadSafeTest {
    public static void main(String[] args) {
        SellTicket sell = new SellTicket();
        Thread t1 = new Thread(sell, "A号窗口");
        Thread t2 = new Thread(sell, "B号窗口");
        Thread t3 = new Thread(sell, "C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class SellTicket implements Runnable {

    private int ticketNum = 100;

    @Override
    public void run() {

        while (true) {
            //使用同步代码块的方式，锁使用的是this对象，由于三个线程都使用的是同一个SellTicket对象，所以this指定的也是同一个对象
            synchronized (this) {
                if (ticketNum > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + "卖出了一张票，票号是：" + ticketNum);
                    ticketNum--;
                } else {
                    break;
                }
            }

        }
    }
}
```

在上例中，使用的是实现Runnable接口的方式创建多线程，创建出来的多个线程对象均使用的是同一个Runnable实现类对象，故若要在这几个线程中实现线程安全，则可以使用this对象来作为锁。



**案例2：使用继承Thread类的方式卖票**

```java
public class ThreadSafeTest2 {
    public static void main(String[] args) {
        TicketWindow t1 = new TicketWindow("A号窗口");
        TicketWindow t2 = new TicketWindow("B号窗口");
        TicketWindow t3 = new TicketWindow("C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}
class TicketWindow extends Thread{
    private static int ticket = 100;
    @Override
    public void run() {
        while (true){
            synchronized (TicketWindow.class) {
                if (ticket > 0) {
                    try {
                        sleep(10);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(getName() + "卖出了一张票，票号是：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            }
        }
    }

    //使用继承Thread类的方式创建多线程时，若需要手动设置线程名，则需要去创建一个带String类型参数的构造器
    public TicketWindow(String name) {
        super(name);
    }
}
```

上例中，使用的是`当前类.class`对象作为同步代码块的锁，不可使用`this`，原因在于使用的是继承Thread类的方式创建多线程，会创建三个不同的线程对象，若使用this则分别表示这三个不同的线程对象t1、t2、t3，对象不同，则无法构成同步机制。

### 2.3、方式二：同步方法

如果操作共享的数据代码完整的声明在一个方法中，那么我们就可以将此方法声明为同步方法即可。

**同步方法**：synchronized关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。

**格式**：

```java
public synchronized void method(){
	//可能会产生线程安全问题的代码。
}
```

> 对于同步方法来说，其synchronized的锁是**`默认且固定`**的：
>
> 1. 当方法是**非静态方法**时，同步监视器是**`this`**；
> 2. 当方法是**静态方法**时，同步监视器是**`当前类.class`**。

由以上的信息，我们就可以推出：

当我们使用Thread子类的方式去实现多线程，若多个线程之间需要去操作同一组数据，此时由于对象的不同，当我们要使用同步方法的方式解决线程安全问题，需要将该方法设置成静态方法；

当我们使用Runnable实现类的方式去实现多线程，若多个线程之间需要去操作同一组数据，且这些线程都使用同一个Runnable实现类的对象去创建，那么当我们要使用同步方法的方式解决线程安全问题，方法可以设置成非静态的，原因在于this表示的对象相同。



**案例1：使用继承Thread类的方式卖票**

```java
public class ThreadSafeMethodTest {
    public static void main(String[] args) {
        TicketMethod t1 = new TicketMethod("A号窗口");
        TicketMethod t2 = new TicketMethod("B号窗口");
        TicketMethod t3 = new TicketMethod("C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}
class TicketMethod extends Thread{
    private static int ticketNum = 100;
    private static boolean isFlag = true;
    @Override
    public void run() {
        while (isFlag){
            sellTicket();
        }
    }

    //静态方法，同步监视器为：类名.class
    //非静态方法，同步监视器为：this
    //由于使用的是继承Thread类的方式创建多线程，故每个线程的对象不同，故只能使用静态的同步方法
    private static synchronized void sellTicket(){
        if (ticketNum > 0){
            try {
                sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName() + "售卖了一张票，票号是：" + ticketNum);
            ticketNum--;
        }else {
            isFlag = false;
        }
    }

    public TicketMethod(String name) {
        super(name);
    }
}
```
在上例中，由于使用的是Thread继承子类的方式去创建多个线程，这些Thread对象均不相同，所以对于同步方法来说，必须要设置成静态类型的，否则同步监视器不同。



**案例2：使用实现Runnable接口的方式去卖票**

```java
public class ThreadSafeMethodTest2 {
    public static void main(String[] args) {
        TicketSafeMethod ticketSafeMethod = new TicketSafeMethod();
        Thread t1 = new Thread(ticketSafeMethod,"A号窗口");
        Thread t2 = new Thread(ticketSafeMethod,"B号窗口");
        Thread t3 = new Thread(ticketSafeMethod,"C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class TicketSafeMethod implements Runnable{
    private int ticketNum = 100;
    private boolean isFlag = true;
    @Override
    public void run() {
        while (isFlag){
            sellTicket();
        }
    }

   
    private synchronized void sellTicket(){
        if (ticketNum > 0){
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(Thread.currentThread().getName() + "售卖了一张票，票号是：" + ticketNum);
            ticketNum--;
        }else {
            isFlag = false;
        }
    }
}
```

### 2.4、synchronized的锁是什么？

同步锁对象可以是任意类型类型，但是必须保证竞争“同一个共享资源”的多个线程必须使用同一个“同步锁对象”。

对于同步代码块来说，同步锁是由程序员手动指定的（很多时候也是指定为this或类名.class），但是对于同步方法来说，同步锁对象只能是`默认`的：

* 静态方法：当前类的Class对象（**`类名.class`**）
* 非静态方法：**`this`**

### 2.5、同步操作的思考顺序

1. 如何找问题，即代码是否存在线程安全问题？（非常重要）

   1. 明确哪些代码是多线程运行的代码
   2. 明确多线程是否有共享数据
   3. 明确多线程运行代码中是否有多条语句操作共享数据

2. 如何解决？（非常重要）

   对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。

   即所有操作共享数据的这些语句都要放在同步范围中

3. 切记：

   范围太小：不能解决安全问题

   范围太大：因为一旦某个线程抢到锁，其他线程只能等待，所以范围太大，效率会降低，不能合理利用CPU资源。





### 2.6、方式三：JDK5.0新特性 `Lock锁`（推荐）

* JDK5.0的新增功能，保证线程的安全。与采用的synchronized相比，Lock可提供多种锁方法，更灵活、更强大。Lock通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

* java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

* 在实现线程安全的控制中，比较常用的是**`ReentrantLock`**，可以显式加锁、释放锁。

  * ReentrantLock类实现了Lock接口，它拥有与synchronized相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。

* Lock锁也称为**同步锁**，加锁和释放锁方法，如下：

  * **`public void lock()`**：加同步锁
  * **`public void unlock()`**：释放同步锁。

  加锁之后必须要释放锁，就如同要关闭资源一样，**若同步代码块中有编译时异常，需要将unlock()方法写入到finally语句块中**。

> 1. 要想实现同步，则多个线程需要共用**`同一个Lock对象`**，这个和synchronized代码块或方法需要同一个监视器对象类似。
>
> 2. Lock是一个接口，一般会使用它的实现类**`ReentrantLock`**来创建Lock的实现类对象。

**使用举例1，使用Runnable接口的方式实现多线程：**

```java
public class LockTest {
    public static void main(String[] args) {
        Window window = new Window();
        Thread t1 = new Thread(window, "A号窗口");
        Thread t2 = new Thread(window, "B号窗口");
        Thread t3 = new Thread(window, "C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class Window implements Runnable{

    private int ticket = 100;
    //由于这里是使用Runnable接口的方式实现多线程，创建出来的多个线程lock对象是一样的。
    private final Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(100);
                //加锁
                lock.lock();
                if (ticket > 0){
                    System.out.println(Thread.currentThread().getName() + "卖出一张票，票号是：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                //释放锁
                lock.unlock();
            }
        }
    }
}
```

**使用举例2，使用继承Thread的方式创建多线程**：

```
public class LockTest {
    public static void main(String[] args) {
        Window t1 = new Window( "A号窗口");
        Window t2 = new Window("B号窗口");
        Window t3 = new Window("C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class Window extends Thread{

    private static int ticket = 100;
    
    //由于这里使用的是Thread子类的方式实现多线程，要想让lock对象相同，则应该设置成static类型的，即实现共享同一个对象数据
    private static final Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(100);
                //加锁
                lock.lock();
                if (ticket > 0){
                    System.out.println(Thread.currentThread().getName() + "卖出一张票，票号是：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                //释放锁
                lock.unlock();
            }
        }
    }
    
    public Window(String name) {
        super(name);
    }
}
```



**synchronized与Lock对比**：

1. Lock显式锁（手动开启和关闭），synchronized是隐式锁，出了作用域、遇到异常等自动解锁。
2. Lock只有代码块锁，synchronized有代码块锁和方法锁
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。
4. Lock锁可以对读不加锁，对写加锁，synchronized不可以
5. Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以。

> 说明：
>
> 开发建议中处理线程安全问题优先使用顺序为：
>
> Lock  →  同步代码块  →  同步方法





## 3、单例设计模式的线程安全问题

### 3.1、饿汉式和懒汉式回顾

单例模式分为饿汉式和懒汉式，现在让我们重温一下饿汉式与懒汉式：

**饿汉式：**

```java
方式一：普通类的方式
public class HungrySingle {

    private static HungrySingle instance = new HungrySingle();
    
    private HungrySingle(){
    }

    public static HungrySingle getInstance(){
        return instance;
    }
}

方式二：枚举类
public enum HungryOne{
    INSTANCE;
}
```

**懒汉式：**

```java
方式一：普通类
public class Singleton {

    private static Singleton singleton;
    
    private Singleton(){
    }
    
    public static Singleton getInstance(){
        if (singleton == null){
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

饿汉式与懒汉式最大的区别就在于，一个是在类加载时就创建了单例对象，一个是在获取对象时才会去创建。

### 3.2、懒汉式存在线程安全问题

由于饿汉式在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的。

但是懒汉式在获取对象时才会去创建单例对象，有可能造成创建出来多个单例对象的问题，如：

存在两个线程：线程A和线程B，线程A调用getInstance()方法获取单例对象，此时单例对象还未被创建，则进入判断为true，进入到if语句中；若此时线程A失去了CPU的执行权，线程B获得了，此时由于对象还未被创建出来，getInstance()方法判断也为true，也进入到了if语句中，则二者获得的单例对象不同，就不符合单例模式的要求了。

懒汉式线程安全问题重现案例：

```java
//创建懒汉式单例模式的类
class Bank{
    private Bank(){}
    private static Bank instance;
    public static Bank getInstance(){
        if (instance == null){
            try {
                //让线程睡眠1秒
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            instance = new Bank();
        }
        return instance;
    }
}

public class LazySingletonSafeTest extends Thread {

    public Bank bank;

    @Override
    public void run() {
        this.bank = Bank.getInstance();
    }

    public static void main(String[] args) {
        //创建两个线程，分别去获取单例
        LazySingletonSafeTest t1 = new LazySingletonSafeTest();
        LazySingletonSafeTest t2 = new LazySingletonSafeTest();
        t1.start();
        t2.start();
        //等t1和t2执行完毕后再执行
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(t1.bank);
        System.out.println(t2.bank);
        System.out.println(t1.bank == t2.bank);
    }
}
```

执行结果：

<img src=".\images\image-20231212220322119.png" align="left">

这时就会去创建两个不同的单例对象，出现了线程不安全的问题。



### 3.3、如何解决懒汉式的线程安全问题？

**方式一：使用同步方法的方式**

很好理解，就是将获取单例对象的方法改成同步的。

```java
class Bank{
    private Bank(){}
    private static Bank instance;

    //static方法，默认监视器为Bank.class
    public static synchronized Bank getInstance(){
        if (instance == null){
            instance = new Bank();
        }
        return instance;
    }
}
```



**方式二：使用同步代码块的方式**

就是将获取对象部分的代码使用synchronized代码块包起来。

```java
class Bank {
    private Bank() {
    }

    private static Bank instance;

    public static Bank getInstance() {
        synchronized (Bank.class) {
            if (instance == null) {
                instance = new Bank();
            }
            return instance;
        }
    }
}
```

**代码优化一下**：在synchronized代码块之前再设置一个判断。

即：

```java
class Bank {
    private Bank() {
    }

    private static Bank instance;

    public static Bank getInstance() {
        //优化：在synchronized代码块之前再加一个判断
        if(instance == null){
        	synchronized (Bank.class) {
            	if (instance == null) {
               	 	instance = new Bank();
            	}
        	}
        }
        return instance;
    }
}
```

优化措施：在synchronized代码块之前再加一个判断，好处：

当有多个线程同时访问getInstance()方法时，若添加这个if判断，则一旦有一个线程进入到同步代码块中，则其他线程就必须等待这个线程执行完毕后，才能够进入；

但是，一旦有一个线程进入到同步代码块中，那么单例对象就会被创建出来了，此时其他的线程就没有必要进入到同步代码块中判断单例对象是否被创建，所以，我们可以让其他未进入到代码块前进行等待的线程，判断当前的单例对象是否被创建了，如果被创建出来了，就没有必要再进行等待，等待其他线程执行完同步代码块，可以直接获取到单例对象了。





**方式三：避免指令重排，将单例对象设置成volatile**(JVM中再学)



**方式四：使用内部类的方式（推荐）**

```java
public class LazySingle{
	private LazySingle(){}
	
	public static LazySingle getInstance(){
		return Inner.INSTANCE;
	}
	
	private static class Inner{
		static final LazySingle INSTANCE = new LazySingle();
	}
}
```



> 内部类只有在使用到内部类的时候才加载，产生INSTANCE实例。
>
> 故对于上例来说，当我们一开始使用`getInstance()`方法时，才会去加载内部类Inner，才会去创建`LazySingle()`对象；此时即不会有饿汉式一开始边创建对象占用内存的缺点，也不会有一般懒汉式的线程安全问题，因为一调用方法，就会加载内部类，在加载类的时候不会出现线程安全问题。
>
> 此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。
>
> 此时的内部类，使用`enum`进行定义，也是可以的。

## 4、死锁

不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。

![thread-lock](.\images\thread-lock.png)

一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。

举例：

```java
public class DeadLockTest {
	public static void main(String[] args) {

		StringBuilder s1 = new StringBuilder();
		StringBuilder s2 = new StringBuilder();

		new Thread() {
			public void run() {
				synchronized (s1) {
					s1.append("a");
					s2.append("1");
					
					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}

					synchronized (s2) {
						s1.append("b");
						s2.append("2");

						System.out.println(s1);
						System.out.println(s2);

					}
				}
			}
		}.start();

		new Thread() {
			public void run() {
				synchronized (s2) {
					s1.append("c");
					s2.append("3");

					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					
					synchronized (s1) {
						s1.append("d");
						s2.append("4");

						System.out.println(s1);
						System.out.println(s2);

					}

				}
			}
		}.start();

	}
}
```

这个时候就会发生死锁现象。原因在于，两个线程都拥有着对方继续执行下去需要的监视器，并且都无法释放，死死地拿在手中，致使双方都无法继续执行下去。



**诱发死锁的原因**：

* 互斥条件
* 占用且等待
* 不可抢夺（或不可抢占）
* 循环等待

以上四个条件，同时出现就会触发死锁。



**如何解决死锁**：

死锁一旦出现，基本很难人为干预，只能尽量避免。可以考虑打破上面的诱发条件。

针对条件1：互斥条件基本上无法被破坏，因为线程需要通过互斥解决安全问题。

针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。

针对条件3：占用部分资源的线程在进一步申请其他资源时如果申请不到，就主动释放掉已经占用的资源。

针对条件4：可以将资源改为线性顺序。申请资源时，先申请需要较小的，这样避免循环等待问题。

## 5、JDK5.0新特性：Lock锁


* JDK5.0的新增功能，保证线程的安全。与采用的synchronized相比，Lock可提供多种锁方法，更灵活、更强大。Lock通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

* java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

* 在实现线程安全的控制中，比较常用的是**`ReentrantLock`**，可以显式加锁、释放锁。

  * ReentrantLock类实现了Lock接口，它拥有与synchronized相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。

* Lock锁也称为**同步锁**，加锁和释放锁方法，如下：

  * **`public void lock()`**：加同步锁
  * **`public void unlock()`**：释放同步锁。

  加锁之后必须要释放锁，就如同要关闭资源一样，**若同步代码块中有编译时异常，需要将unlock()方法写入到finally语句块中**。

> 1. 要想实现同步，则多个线程需要共用**`同一个Lock对象`**，这个和synchronized代码块或方法需要同一个监视器对象类似。
>
> 2. Lock是一个接口，一般会使用它的实现类**`ReentrantLock`**来创建Lock的实现类对象。

**使用举例1，使用Runnable接口的方式实现多线程：**

```java
public class LockTest {
    public static void main(String[] args) {
        Window window = new Window();
        Thread t1 = new Thread(window, "A号窗口");
        Thread t2 = new Thread(window, "B号窗口");
        Thread t3 = new Thread(window, "C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class Window implements Runnable{

    private int ticket = 100;
    //由于这里是使用Runnable接口的方式实现多线程，创建出来的多个线程lock对象是一样的。
    private final Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(100);
                //加锁
                lock.lock();
                if (ticket > 0){
                    System.out.println(Thread.currentThread().getName() + "卖出一张票，票号是：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                //释放锁
                lock.unlock();
            }
        }
    }
}
```

**使用举例2，使用继承Thread的方式创建多线程**：

```
public class LockTest {
    public static void main(String[] args) {
        Window t1 = new Window( "A号窗口");
        Window t2 = new Window("B号窗口");
        Window t3 = new Window("C号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}

class Window extends Thread{

    private static int ticket = 100;
    
    //由于这里使用的是Thread子类的方式实现多线程，要想让lock对象相同，则应该设置成static类型的，即实现共享同一个对象数据
    private static final Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(100);
                //加锁
                lock.lock();
                if (ticket > 0){
                    System.out.println(Thread.currentThread().getName() + "卖出一张票，票号是：" + ticket);
                    ticket--;
                }else {
                    break;
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                //释放锁
                lock.unlock();
            }
        }
    }
    
    public Window(String name) {
        super(name);
    }
}
```



**synchronized与Lock对比**：

1. Lock显式锁（手动开启和关闭），synchronized是隐式锁，出了作用域、遇到异常等自动解锁。
2. Lock只有代码块锁，synchronized有代码块锁和方法锁
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。
4. Lock锁可以对读不加锁，对写加锁，synchronized不可以
5. Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以。

> 说明：
>
> 开发建议中处理线程安全问题优先使用顺序为：
>
> Lock  →  同步代码块  →  同步方法



# 六、线程间的通信

## 1、为什么要处理线程间通信？

当我们`需要多个线程`来共同完成一件任务，并且我们希望它们`有规律的执行`，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据。

比如：线程A用来生产包子的，线程B用来吃包子的， 包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即——**等待唤醒机制**。

## 2、等待唤醒机制

这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的`竞争（race）`，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。在一个线程满足某个条件时，就进入等待状态（`wait()/wait(time)`），等待其他线程执行完他们的指定代码过后再将其唤醒（`notify()`）；或可以指定wait的时间，等时间到了自动唤醒；在有多个线程等待时，如果需要，可以使用`notifyAll()`来唤醒所有的等待线程。wait/notify就是线程间的一种协作机制。

* **`wait()`**：线程不再活动，不再参与调度，进入到`wait set`中，因此不会浪费CPU资源，同时也会释放同步监视器（释放同步监视器的原理实际上是将对象中的当前线程的锁标记删除），这时的线程状态是WAITING或TIMED_WAITING。它还要等着别的线程执行一个特别的动作，也即“通知（notify）”或者等待时间到，在这个对象上等待的线程从`wait set`中释放出来，重新进入调度队列（`read queue`）中。
* **`notify()`**：从wait set中选取出**优先级最高**的那一个线程释放，如果wait set上的线程优先级相同，则随机唤醒一个，被唤醒的线程从当初被wait()的位置继续执行（注意，由于notify的调用者必须是锁对象，释放出来的是使用相同锁对象调用wait()进入到wait set中的线程）。
* **`notifyAll()`**：释放与notifyAll调用者相同锁对象的wait set上的所有线程。



**案例：使用两个线程，线程1和线程2交替打印1-100的数**

```java
public class AlternatePrintTest {
    public static void main(String[] args) {
        PrintThread print = new PrintThread();
        Thread t1 = new Thread(print, "线程1");
        Thread t2 = new Thread(print, "线程2");
        t1.start();
        t2.start();

    }
}

class PrintThread implements Runnable {

    private int num = 1;
    private final Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(100);
                //对于线程中包含wait()与notify()方法时
                //只能使用synchronized同步代码块或同步方法的方式
                //且wait()方法和notify()的调用者必须是锁对象
                //故wait()方法和notify()方法必须声明在同步代码块或同步方法中
                //不能声明在其他的位置
                synchronized (this) {
                    
                    //注意，对于多个线程使用run()方法要实现线程间的通信时
                    //必须将notify()或notifyAll()方法放在前面
                    //如果是先执行wait()方法，那么所有线程都会被停止
                    //而无法被唤醒
                    //notify()和wait()方法的调用者必须是同步监视器
                    notify();
                    if (num <= 100) {
                        System.out.println(Thread.currentThread().getName() + "打印了一个数字：" + num);
                        num++;
                    } else {
                        break;
                    }
                    wait();
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

打印结果：

<img src=".\images\image-20231214155802427.png" align="left">

可以发现，线程实现了交替打印。



## 3、使用注意点

> 1. **被通知的线程被唤醒后也不一定能立即恢复执行**，因为它执行中断的地方是在同步块中，而且wait()方法释放锁资源，即此刻它不再持有锁，所以它需要再次尝试去获取锁，成功后才能够恢复执行。
>
>    所以：
>
>    当对线程使用wait()后，它会进入到`WAITING` 或 `TIMED_WAITING`状态，并且释放锁；再对其使用notify()方法唤醒后，由于线程处于同步块中，若当前线程未获得锁，此时线程进入的是`BLOCKED`状态，而不是`RUNNABLE`状态；
>
>    若线程获取到锁后，线程就转为`RUNNABLE`状态。
>
> 2. **若要唤醒某一线程，则调用notify()的方法对象必须与调用wait()方法的`对象一致`，调用者必须是`同步监视器`对象**。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
>
> 3. **对于多个线程使用的是相同的`run()`方法时，在方法中，notify()方法应该放在wait()方法`之前`**，即让线程先进行唤醒，在暂停，否则会出现全部都暂停的情况。
>
> 4. **`wait()`方法和`notify()`只能在`同步代码块`中或`同步方法`中使用**，**即只能通过synchronized来实现同步，而不能使用Lock对象来实现**。因为：必须要通过**`监视器对象`**调用这两个方法，否则会报`java.lang.IllegalMonitorStateException`异常。
>
> 5. **任何对象都可以作为同步监视器，同理，任何对象都可以调用`wait()`和`notify()`方法。**原因在于wait()和notify()方法定义在Object类中。





注意：

当前学的wait()和notify()只能使用在synchronized结构中，那么Lock中的通信该如何实现呢？

后面学习Lock配合Condition实现线程间的通信





## 4、`sleep() vs wait()`

### 相同点

二个方法一旦执行，都会使得当前线程进入到阻塞状态。

* **`sleep(long millis)`与`wait(int timeout)`方法会使线程进入到`TIMED_WAITING`状态。**

* **`wait()`方法使线程进入到`WAITING`状态。**

### 不同点

1. **`sleep()`方法与`wait()`方法最大的区别在于对`CPU的占用`。**

调用sleep()方法后，线程虽然进入了休眠，但是实际上还是占用着CPU，os认为该线程正在工作；

调用wait()方法后，线程会让出系统资源，线程进入等待池，其他线程可以占用CPU。

例如：线程调用sleep(100)后，虽然线程要休眠100毫秒，但是该线程也要在CPU中执行100毫秒，这100毫秒依旧是在执行该线程，并未释放CPU的执行权。



2. **`sleep()`方法声明在Thread类中，是静态方法；而`wait()`方法声明在Object类中，是非静态方法**

故只有当该类继承Thread类时，才可以直接调用sleep()方法，否则都是通过Thread类进行调用；

由于wait()方法声明在Object类中，故所有类中都包含wait()方法，所以可以直接使用。



3. 使用的范围不同：**`sleep()`可以在任何需要的位置被调用；`wait()`方法必须使用在同步代码块或同步方法中，否则报：`java.lang.IllegalMonitorStateException`异常。**



4. **`sleep()`方法不会释放同步监视器，`wait()`方法会释放同步监视器**。



5. **`sleep()`方法一到时间就会从`TIMED_WAITING`状态转为`RUNNABLE`状态；`wait()`方法包含带参数的与不带参数的，若是带参数的`wait()`方法，则调用后直到被唤醒之前，都是处于`TIME_WAITING`状态，唤醒后若获取到同步监视器，则转变为`RUNNABLE`状态，否则变为`BLOCKED`状态；不带参数的则是被唤醒之前处于`WAITING`状态。**





## 5、哪些操作会释放锁？哪些操作不会？

### 释放锁的操作

1. 当前线程的同步方法、同步代码块执行结束。
2. 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
3. 当前线程在同步代码块、同步方法中出现了未处理的Error和Exception，导致当前线程异常结束。
4. 当前线程在同步代码块、同步方法中执行了锁对象的wait()方法，当前线程会被挂起，并释放锁。

### 不释放锁的操作

1. 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。

2. 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）

   ​		应尽量避免使用suspend()和resume()这样过时的方法来控制线程。





# 线程经典问题：生产者与消费者问题

等待唤醒机制可以解决经典的“生产者与消费者”的问题。生产者与消费者问题（英语：Producer-consumer problem），也称为有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）`共享固定大小缓冲区的线程`——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。

生产者的主要作用是生产一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。**该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据。**

举例：

生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如：20），如果生产者试图生产更多的产品，店员会叫生产者暂停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会叫消费者等一下，如果店中有产品了再通知消费者取走产品。

**生产者与消费者问题中其实隐含着两个问题：**

* 线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。
* 线程的协调工作问题：
  * 要解决该问题，就必须让生产者线程在缓冲区满时等待（wait），暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知（notify）正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待（wait），暂停进入阻塞状态，等待生产者往缓冲区添加数据之后，再通知（notify）正在等待的线程恢复到就绪状态。通过这样的通信机制来解决这类问题。

**代码实现**：

```java
public class ConsumerProducerTest {
	public static void main(String[] args) {
		Clerk clerk = new Clerk();
		Producer p1 = new Producer(clerk);
		
		Consumer c1 = new Consumer(clerk);
		Consumer c2 = new Consumer(clerk);
		
		p1.setName("生产者1");
		c1.setName("消费者1");
		c2.setName("消费者2");
		
		p1.start();
		c1.start();
		c2.start();
	}
}

//生产者
class Producer extends Thread{
	private Clerk clerk;
	
	public Producer(Clerk clerk){
		this.clerk = clerk;
	}
	
	@Override
	public void run() {
		
		System.out.println("=========生产者开始生产产品========");
		while(true){
			
			try {
				Thread.sleep(40);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			//要求clerk去增加产品
			clerk.addProduct();
		}
	}
}

//消费者
class Consumer extends Thread{
	private Clerk clerk;
	
	public Consumer(Clerk clerk){
		this.clerk = clerk;
	}
	@Override
	public void run() {
		System.out.println("=========消费者开始消费产品========");
		while(true){
			
			try {
				Thread.sleep(90);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			//要求clerk去减少产品
			clerk.minusProduct();
		}
	}
}

//资源类
class Clerk {
	private int productNum = 0;//产品数量
	private static final int MAX_PRODUCT = 20;
	private static final int MIN_PRODUCT = 1;
	
	//增加产品
	public synchronized void addProduct() {
		if(productNum < MAX_PRODUCT){
			productNum++;
			System.out.println(Thread.currentThread().getName() + 
					"生产了第" + productNum + "个产品");
			//唤醒消费者
			this.notifyAll();
		}else{
			
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	//减少产品
	public synchronized void minusProduct() {
		if(productNum >= MIN_PRODUCT){
			System.out.println(Thread.currentThread().getName() + 
					"消费了第" + productNum + "个产品");
			productNum--;
			
			//唤醒生产者
			this.notifyAll();
		}else{
			
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
}
```

