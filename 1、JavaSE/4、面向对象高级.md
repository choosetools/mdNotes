[TOC]



# static关键字

## 1、类属性、类方法的设计思想

当我们编写一个类的时候，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的属性在内存空间里只有一份。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必再每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。

![](.\images\image-20220325213629311.png)

此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。

这里的类方法、类变量，只需要使用`static`修饰即可。所以也称为静态变量、静态方法。

## 2、static关键字

* 使用范围：
  * 在Java类中，可用static修饰属性、方法、代码块和内部类。
* 被修饰后的成员具备以下特点：
  * 随着类的加载而加载
  * 优先于对象存在
  * 修饰的成员，被所有对象所共享
  * 访问权限允许时，可不创建对象，直接被类调用
  * **子类可以继承父类中的静态属性与静态方法**



## 3、静态变量

> <font color="red">**静态变量可以让所有对象实例共享同一个值**</font>

### 3.1 语法格式

使用static修饰的成员变量就是静态变量（或类变量、类属性）

```java
[权限修饰符] class 类名{
	[权限修饰符] static 数据类型 变量名;
}
```

### 3.2 静态变量的特点

* **静态变量也有默认值，其默认值规则和成员变量的默认值规则一样。**
* **静态变量的值是所有对象所共享的，访问的实际上是同一个变量，存储在方法区的常量池中。**
* 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。
* 如果权限修饰符允许，在其他类中可以通过“`类名.静态变量`”直接访问，也可以通过“`对象.静态变量`”的方式访问（但是更推荐使用类名.静态变量的方式）。
* 静态变量的get/set方法也是静态的，当局部变量和静态变量重名时，使用`类名.静态变量`的方式进行区分。



### 3.3 对比静态变量与实例变量

1. **个数**：
   * 静态变量：在内存空间中只有一份，被多个对象所共享
   * 实例变量：类的每一个实例（或对象）都保存着一份实例变量。
2. **内存位置**：
   * 静态变量：jdk6及之前存放在方法区。jdk7及之后，存放在堆空间。（我学习的都是存放在方法区的常量池中）
   * 实例变量：存放在堆空间的对象实体中。
3. **加载时机**：
   * 静态变量：**`随着类的加载而加载`**，由于类只会加载一次，所以静态变量也只有一份。
   * 实例变量：随着对象的创建而加载，每个对象拥有一份实例变量。
4. **调用者**：
   * 静态变量：只能被类调用，也可以使用对象调用。推荐直接使用类调用。
   * 实例变量：只能使用对象调用。
5. **消亡时机**：
   * 静态变量：随着类的卸载而消亡。
   * 实例变量：随着对象的回收而消亡。

**静态变量的生命周期**：

静态变量的生命周期和类的生命周期相同。它们在类加载时初始化，一直存在，直到程序结束或类被卸载。静态变量的值在类记载后保持不变，因为它们是类级别的，而不是与对象实例相关联。

### 3.4 静态变量举例

```java
class Chinese{
    //实例变量
    String name;
    int age;
    //类变量
    static String nation;//国籍

    public Chinese() {
    }

    public Chinese(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Chinese{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", nation='" + nation + '\'' +
                '}';
    }
}
public class StaticTest {
    public static void main(String[] args) {
        Chinese c1 = new Chinese("康师傅",36);
        c1.nation = "中华人民共和国";

        Chinese c2 = new Chinese("老干妈",66);

        System.out.println(c1);
        System.out.println(c2);

        System.out.println(Chinese.nation);
    }
}
```

对应的内存结果：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）

<img src=".\images\image-20220514183814514.png" style="zoom:67%;">



## 4、静态方法（类方法）

### 4.1 语法格式

用static修饰的成员方法就是静态方法。

```java
[修饰符] class 类{
    [权限修饰符] static 返回值 方法名(参数列表){
        //方法体
    }
}
```

### 4.2 静态方法的特点

* 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。
* 只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法"的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。

* **在类的非静态方法中，可以调用当前类中的静态结构与非静态结构。**

  **在类的静态方法中，只能调用类中的静态结构。**

因为静态方法是随着类的加载而加载的，此时都没有类的对象，那么存储在堆空间中的属于对象结构的实例属性与实例方法也就不存在，自然也就无法访问。

* **静态方法内，不能使用this，也不能使用super。**

this表示的是当前的对象实例，super表示的是当前对象的父类结构。调用静态方法的是类，而不是对象，连对象都没有，故不能使用this或super。



> **<font color="red">静态方法可以被继承，但不可被重写</font>**

案例：

```java
class Father{
    public static int age = 1;
    public static void staticMethod(){
        System.out.println("fatherMethod!");
    }

    public static void staticMethod2(){
        System.out.println("父类中的staticMethod2方法！");
    }

}
class Child extends Father{
    public static void staticMethod2(){
        System.out.println("子类中的staticMethod2方法！");
    }
}
```

测试类：

```java
public class StaticMethodTest {
    @Test
    public void test(){
        Father.staticMethod();
        Child.staticMethod();

        System.out.println(Father.age);
        System.out.println(Child.age);

    //使用多态，将父类对象的引用指向子类的对象，此时调用父类中已有的方法会去调用子类中重写的
        Father father = new Child();
        father.staticMethod2();
    }
}
```

输出结果：

<img src=".\images\Snipaste_2023-11-11_14-19-06.png" align="left">

结果得出的结论：

> 1. **子类可以继承父类中的静态属性与方法**
> 2. **子类不能重写父类中的静态方法**

父类的静态属性与方法可以被子类继承，但不能被“重写”，这里的重写指我们一般默认的重写，是基于动态绑定来说的，按动态绑定来说向上转型之后在运行调用方法时，若子类重写了该方法会调用子类重写的方法。

但对于静态方法来说，不存在动态绑定这一说法，其基于的是静态绑定。

静态方法属于静态绑定，在编译阶段已经确定函数名和地址，静态方法可以被继承，但是不能被重写。因为重写的意思是重新定义父类的虚函数，但是虚函数是动态绑定的，静态方法不属于虚函数，也就不存在所谓的重写。

简单来说：

**静态方法绑定类，在类记载时便与类捆绑，不受其他类的影响。**

**动态方法绑定实例对象，受子类重写的影响，若被重写则重新绑定到重写的子类对象上。**

另外，<font color="red">**`抽象abstract修饰符无法与static组合使用`**</font>正是此原因，abstract方法是要被子类重写的，若将其变成静态方法便导致无法重写，与abstract目的矛盾，故无法组合使用。



## 5、什么时候需要使用静态的属性和方法？

**开发中，什么时候需要将属性声明为静态？**

* 判断当前类的讴歌实例是否能共享此成员变量，且此成员变量的值是相同的。
* 开发中，常量常常声明成静态的，比如：Math中的PI。

**什么时候需要将方法声明成静态的？**

* 方法内操作的变量如果都是静态变量（而非实例变量）的话，则此方法建议声明为静态方法。
* 开发中，常常将工具类中的方法声明为静态方法。比如：Arrays类、Math类。

---

# 类的成员之四：代码块

如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考考虑代码块来实现。

* 代码块的作用：
  * 对java类或对象进行初始化。
* 代码块的分类，依据是否有static修饰分为：
  * 静态代码块（有static修饰）
  * 非静态代码块（无static修饰）

## 静态代码块

如果想要为静态变量进行初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块的方式。

### 语法格式：

```java
【修饰符】 class 类{
	static{
        静态代码块
    }
}
```

### 静态代码块的特点：

1. <font color="red">**静态代码块随着类的加载而执行，且只执行一次。**</font>
2. 可以访问静态属性与静态方法，但不可调用非静态属性与方法。（类似于静态方法中的调用权限）
3. 若有多个静态代码块，那么按照从上到下的顺序依次执行。
4. 静态代码块的执行要先于非静态代码块。



## 非静态代码块

### 语法格式

```java
【修饰符】 class 类{
    {
        非静态代码块
    }
}
```

### 非静态代码块的意义

如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。

### 非静态代码块的执行特点

1. <font color="red">**随着对象的创建而执行，每次创建对象都会执行一次，且在构造器之前。**</font>
2. 既可以调用非静态结构，还可以调用静态的变量或方法。
3. 若有多个非静态代码块，那么按照从上到下的顺序依次执行。

**案例**：

```java
//测试类
public class CodeBlockTest {
    @Test
    public void test(){
        CodeBlock codeBlock1 = new CodeBlock();
        System.out.println("************************************");
        CodeBlock codeBlock2 = new CodeBlock();
    }

}


class CodeBlock{
    private static int age = 1;
    private String name = "cheng";

    static {
        System.out.println("静态代码块1，age = " + CodeBlock.age);
    }
    static {
        System.out.println("静态代码块2");
    }

    public CodeBlock(){
        age = 2;
        this.name = "jia";
    }
    {
        System.out.println("非静态代码块1，name = " + this.name);
    }

    {
        System.out.println("非静态代码块2");
    }
}
```

输出结果：

<img src=".\images\Snipaste_2023-11-19_11-04-39.png" align="left">

可以从上述结果知道：

* 静态代码块只会执行一次，就是在类加载时
* 代码块会随着对象的创建而执行
* 静态代码块和非静态代码块之间的执行顺序是从上往下执行
* 二者都是在构造器执行执行

## 实例变量的赋值顺序：

默认初始化 --> 显式初始化、多个代码块依次执行（同级别下按先后顺序执行） --> 构造器再对成员进行初始化操作 --> 通过“对象.属性”或“对象.方法”的方式，可多次给属性赋值

<img src=".\images\image-20220325230208941.png">

**显式初始化与代码块初始化属于同一级别，根据声明的先后顺序进行赋值**

比如：

```java
public class LeafTest {
    {
        this.age = 2;
    }

    int age = 1;

    public static void main(String[] args) {
        LeafTest leafTest = new LeafTest();
        System.out.println(leafTest.age);
    }
}
```

输出结果：

```
1
```

只不过在通常情况下，会将显式初始化放在代码块之前，因为属性的声明一般放在首位。

对于有静态代码块，且有多重继承关系的类中，属性的初始化又是怎样的呢？

按照对象的初始化过程来说，会先去创建java父类中的属性与方法，然后再对父类对象进行扩充，让其含有子类独有的属性以及覆盖重名的方法。按照上述描述的过程，应该会先去调用父类中的代码块，再调用父类的构造器，使得创建一个父类的对象，然后再在其基础上扩充，去调用子类的代码块，子类中的构造器，创建子类的对象。

案例：

```java
package org.example.javaadvanced.high;

public class LeafTest {
    public static void main(String[] args) {
        Zi zi = new Zi();
    }
}
class Fu{
    private static int i = getNum("（1）i");
    private int j = getNum("（2）j");
    static{
        print("（3）父类静态代码块");
    }
    {
        print("（4）父类非静态代码块，又称为构造代码块");
    }
    Fu(){
        print("（5）父类构造器");
    }
    public static void print(String str){
        System.out.println(str + "->" + i);
    }
    public static int getNum(String str){
        print(str);
        return ++i;
    }
}
class Zi extends Fu{
    private static int k = getNum("（6）k");
    private int h = getNum("（7）h");
    static{
        print("（8）子类静态代码块");
    }
    {
        print("（9）子类非静态代码块，又称为构造代码块");
    }
    Zi(){
        print("（10）子类构造器");
    }
    public static void print(String str){
        System.out.println(str + "->" + k);
    }
    public static int getNum(String str){
        print(str);
        return ++k;
    }
}
```

输出结果：

<img src=".\images\Snipaste_2023-11-19_15-54-28.png" align="left">

创建对象，**首先会去加载类，加载类时则会按照先去加载最高父类，依次往下加载**。

对于上例来说，则会先去加载Fu类。依据属性的赋值顺序来说，显式赋值与代码块方式属于同一个级别，那么也就是说其实在对象创建和类加载时，会去给属性赋值（非静态属性与静态属性），那么对于赋值时属性是调用方法来获取的情况，也会去调用方法。比如上例中的private static int i = getNum("(1)i");这种情况下，在类加载时就会去调用getNum()方法给i赋值。又因为这段代码在静态代码块之前，所以getNum()的调用比静态代码块的执行先。

之后，则会去加载Zi类，顺序与父类中的执行顺序一致。

之后，去创建对象，创建对象的顺序也是先去创建最高父类的对象，之后在父类对象的基础上进行扩张。所以，会先去执行父类中的代码块或给父类中的非静态属性赋值（依据声明的顺序），然后再去执行父类中的构造器；之后才会去创建子类对象。



## 创建对象的实例化过程

创建一个对象，实际上会经过两个步骤：

1. 加载类

2. 在内存空间中创建对象

在这两个步骤中，实际上又会经过很多的过程：

1. 依据声明的顺序，初始化静态属性或执行静态代码块
2. 依据声明的顺序，初始化非静态属性或执行非静态代码块
3. 调用构造器

如果创建的对象所属的类有父类，那么则先去初始化父类，才初始化子类，遵循的原则是：**先静态，后实例，先父类，后子类**。

---

# 关键字final

含义：最终的，不可更改的

## final的使用

### final修饰类

final修饰类，表示这个类**不能被继承**，没有子类。

比如：String、StringBuffer、StringBuilder。

```java
final class Eunuch{//太监类
	
}
class Son extends Eunuch{//错误
	
}
```



### final修饰方法

final修饰方法，表示该方法**不能被重写**

例如：Object类中的getClass()方法

```java
class Father{
	public final void method(){
		System.out.println("father");
	}
}
class Son extends Father{
	public void method(){//错误
		System.out.println("son");
	}
}
```



### final修饰变量

final修饰变量，可以修饰成员变量，也可以修饰局部变量。

**表示该变量一旦赋值，其值就不能被修改**，即常量，常量名建议使用大写字母表示。

> * **final修饰的变量不可以在方法中赋值，那么也就没有set方法。**
>
> * **但是可以通过其他方式进行赋值：<font color="red">显式赋值、代码块赋值、实例变量还可以在构造器中赋值。</font>**
> * **final修饰的属性当赋一次值之后就不可再更改。**

例如：

当创建一个final属性并且未赋值时，会报错，提示变量未被初始化，即final修饰的属性必须显示地进行赋值才行，不能使用其默认初始化值。

![image-20231119202821497](.\images\image-20231119202821497.png)

不可在方法中对final修饰的属性进行赋值，只能通过显式赋值，或者通过代码块与构造器的方式进行赋值，并且在第一次赋值后就不可再更改。

![image-20231119203102257](.\images\image-20231119203102257.png)

![image-20231119203220431](.\images\image-20231119203220431.png)

![image-20231119203304310](.\images\image-20231119203304310.png)



**特殊情况：**

> **当final修饰的成员变量是引用类型的变量，那么实际上不能被修改的是对象的地址值，对于对象中属性的值是可以更改的，因为其地址值是不变的。**

例如：

```java
public class FinalTest {
    private final Father father = new Father("cheng");
    
    @Test
    public void test(){
        father.name = "jia";
//        father = new Father("wei");报错
    }
}
```

即：使用final修饰的属性是引用类型时，可以修改对象中的属性，但不可修改其地址值，即不可给其赋一个其他对象。

### final与static搭配

用来修饰成员变量时，此成员变量称为：**全局常量**，因为在项目中不可出现魔法值，所以当需要使用固定的某一个值时，会去声明一个全局常量使用。

比如：Math.PI就是全局常量





## 注意点

> * final修饰的引用类型的变量，意思只是**`变量的地址值不可变`**了。
>
>   当我们要去修改引用数据类型的变量中的属性时，该引用数据类型的变量使用了final修饰，依然是可以的。

案例：

```java
final Person person = new Person("cheng", 123);
person.setAge(12);
System.out.println(person);

final HashMap<String, Integer> hashMap = new HashMap<>();
hashMap.put("cheng", 22);
```

以上的代码均可实现



---

# 抽象类与抽象方法（abstract关键字）

## 引入：

我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形中。但是这些方法在父类中无法给出具体的实现，而是应该交给子类各自具体显示。那么父类在声明这些方法时，就只有方法签名，没有方法体，我们把**没有方法体的方法称为抽象方法**。**Java语法规定，包含抽象方法的类必须是抽象类**。

## 语法格式

* **抽象类**：被abstract修饰的类
* **抽象方法**：被abstract修饰的没有方法体的方法

### 抽象类的语法格式

```java
[权限修饰符] abstract class 类名{
    
}
```

### 抽象方法的语法格式

```java
[其他修饰符] abstract 返回值类型 方法名([形参列表]);
```

> 注意：抽象方法不具有方法体

![image-20220517204707255](.\images\image-20220517204707255.png)

代码举例：

抽象父类：

```java
abstract class AbstractFather{
    public abstract void method();
}
```

子类：

```java
class Son extends AbstractFather{
	//重写抽象方法
    @Override
    public void method() {
        System.out.println("子类中的method方法");
    }
}
```

测试类：

```java
public class AbstractTest {
    @Test
    public void test(){
    	//利用多态，创建父类的引用指向子类对象
        AbstractFather father = new Son();
        //调用子类中重写的method方法
        father.method();
    }
}
```

### 注意：

* **抽象类是不可以创建对象的**。如果创建，编译无法通过。只能创建其非抽象子类的对象。

  > 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。
  >
  > 抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，说明类中依然还有抽象方法，仍为抽象类。

* 抽象类中，也有构造方法，是提供子类创建对象时，初始化父类成员变量使用的。

  > 理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。

* 抽象类中，不一定包含抽象方法，但是有抽象方法的类一定是抽象类。

  > 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

* 抽象类的子类，必须重写父类中**所有**的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类，不创建对象。

  > 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

* 不能用abstract修饰变量、代码块、构造器；

* <font color="red">**不能使用abstract修饰私有方法、静态方法、final的方法、final的类。**</font>

  > 其原因就在于这些方法或者类不能被重写或继承，如果使用abstract修饰，则表示这些类或方法无法直接使用，必须被继承或重写才可以使用，那实际上就会造成逻辑冲突。
  >
  > 同样地，abstract不能与final共同使用，原因就是逻辑之间的冲突，final表示的是最终的，无法被修改的；而abstract修饰的类与方法则表示需要被继承和重写的；这与final产生了逻辑冲突，故不可一起使用。





---

# Interface接口       

接口有些类似于抽象类，同样也是不能创建实例对象，一般在实际开发中，可以通过使用父接口的引用指向子类的对象的方式，限制只能调用接口中已经声明了的方法。

## 理解接口

官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，**一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）**。

我的理解：接口可以理解为一种特殊的类，里面全是由**全局常量**和**公共的抽象方法**所组成。接口是解决**Java无法使用多继承**的一种手段，但是接口在实际中更多的作用是**制定标准**的，即当我们需要实现某种功能时，必须重写某一种方法，例如当我们需要使用clone()方法时，必须实现Cloneable接口。或者我们可以直接把接口理解为**100%的抽象类**，即接口中的方法必须全部是抽象方法（JDK1.8之前可以这样理解）。



## 接口的特点

就是一个类一样，一个接口也能拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）

* 接口指明了一个类必须做什么和不能做什么，相当于类的蓝图。
* 一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，就必须实现某些方法，我才承认你确实拥有该接口代表的某种能力。
* 一个Java库中接口的例子是：Comparator接口，这个接口代表了“能够进行比较”这种能力，任何类只要实现了这个Comparator接口的话，这个类也具备了“比较”这种能力，那么就可以用来进行排序操作了。

接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。继承是一个“是不是”的`is-a`关系，而接口实现则是“能不能”的`has-a`关系。

例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或者是否具备USB通信功能，就看你是否遵循USB接口规范。

<img src=".\images\image-20220517211517846.png" alt="image-20220517211517846" style="zoom:67%;" />

即：接口类似于一个功能，如果你想要这个功能，你就需要去实现这个接口，实现了这个接口，也就代表着你拥有了这个功能。



## 接口格式

接口的定义，它与定义类方式相似，但是使用interface关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。

> 引用数据类型：数组、类、枚举、接口、注解。

### 接口的声明格式

```java
[修饰符] interface 接口名 {
    //接口的成员列表：
    //1、公共的静态常量
    //2、公共的抽象方法
    
    //3、公共的默认方法（JDK8以后）
    //4、公共的静态方法（JDK8以后）
    //5、私有方法（JDK9以后）
}
```



### 接口中的成员

**在JDK8以前**，接口中只允许出现：

1. <font color="red">**公共的静态常量**</font>：其中`public static final`可以省略
2. <font color="red">**公共的抽象方法**</font>：其中`public abstract`可以省略

**在JDK8时**，接口中允许声明：

3. **<font color="red">公共的默认方法</font>**：其中`public`可以省略，但是建议保留，`default`不能省略

> 对于父接口中的默认方法，如果想在实现类中进行调用，可以使用：
>
> **`父接口名.super.默认方法名`**
>
> 的方式进行调用

4. <font color="red">**公共的静态方法**</font>：其中`public`可以省略，但是建议保留，`static`不能省略

**在JDK9时**，接口中又允许增加了：

5. **<font color="red">私有方法</font>**

除此之外，**接口中没有构造器，没有初始化块**，因为就算使用多态创建了接口的引用指向了子类的对象，但是因为接口中没有成员变量，所以不需要进行初始化，那么也就不需要构造器和代码块。

案例：

```java
interface Flyable {
    //公共的静态常量，public static final可以省略
    public static final int MIN_SPEED = 0;
    int MAX_SPEED = 8000;

    //公共的抽象方法，public abstract可以省略
    public abstract void method1();
    void method2();

    //公共的默认方法
    default void method3(){}

    //公共的静态方法
    static void method4(){
    }

    //私有方法
    private void method5(){
    }
}
```



之前我们学过，在子类中调用父类中

### 接口的使用规则

#### 1、类实现于接口（implements)

接口不能创建对象，但是可以被类实现（implements，类似于被继承）

类与接口的关系为实现关系，即**类实现接口**，该类称为接口的实现类。实现的工作类似于继承，格式相仿，只是关键字不同，实现使用`implements`关键字。

之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类只能继承于一个父类，但可以同时实现多个接口。

```java
【【修饰符】 class 实现类  implements 接口1，接口2，接口3。。。{
	// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}

【修饰符】 class 实现类 extends 父类 implements 接口1，接口2，接口3。。。{
    // 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}
```

**注意：**

1. 如果接口的实现类是非抽象类，那么必须`重写所有接口中的所有抽象方法`。<font color="red">**如果抽象方法有重名的，只需要重写一次**</font>。如果是抽象类，抽象类可以存在抽象方法，所以可以不用重写。
2. 默认方法可以选择保留，也可以重写。

```
重写时，default单词就不要写了，默认方法的概念只存在于接口中，类中就没有所谓的默认方法了。
```

3. 静态方法不能被继承也不能被重写（子父类中也一样）。



#### 2、接口继承于接口（extends)

一个接口能继承另一个或多个接口，接口的继承也使用extends关键字，子接口会继承父接口的方法。这样一来，实现一个子接口就需要同时实现子接口、以及其父接口中所有的抽象方法。

定义父接口：

```java
public interface Chargeable{
	void charge();
	void in();
	void out();
}
```

定义子接口：

```java
public interface UsbC extends Charageable, USB3{
	void reverse();
}
```

定义子接口的实现类：

```java
public class TypeCConverter implements UsbC {
    @Override
    public void reverse() {
        System.out.println("正反面都支持");
    }

    @Override
    public void charge() {
        System.out.println("可充电");
    }

    @Override
    public void in() {
        System.out.println("接收数据");
    }

    @Override
    public void out() {
        System.out.println("输出数据");
    }
}
```

> 所有父接口的抽象方法都要重写。
>
> 方法名相同的抽象方法只需要实现一次。



#### 3、接口的多态性

实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象所重写的方法。

**对于接口多态性的理解：**

接口与子类之间也呈现着多态性，其实接口看成是一种类更加好理解：

> **当我们去创建一个子类对象的时候，不仅仅会去创建其父类，同时也会去给其实现的接口开辟内存空间，将接口中的抽象方法、默认方法以及私有方法都放入到该内存空间中**。然后当子类中实现了接口中的方法时，方法被覆盖，抽象方法也就不存在了。这一点和父类的创建一样，与之不同的是，接口中由于没有成员属性，所以不会通过构造器去给属性赋值，但是给方法开辟内存空间这一点是毋庸置疑的。

所以，当我们去使用实现接口的引用指向子类的对象时，当我们去调用接口中抽象方法，实际上调用的是子类中重写后的方法，但是如果调用的是接口中的默认方法且该方法未被重写，那么实际上调用的是接口中的方法，原因是默认方法是存放在内存空间中的，且未被覆盖，可以通过接口调用。

同理，只能调用接口声明的方法，原因和类的多态一样，编译器在编译期间会去验证。

案例：

两个实现类：

```java
class Mouse implements USB3 {
    @Override
    public void start() {
        System.out.println("鼠标开始连接");
    }

    @Override
    public void stop() {
        System.out.println("断开鼠标");
    }
}

class KeyBoard implements USB3{
    @Override
    public void start() {
        System.out.println("键盘开始连接");
    }

    @Override
    public void stop() {
        System.out.println("断开键盘");
    }
}
```

测试类：

```java
public class TestComputer {
    public static void main(String[] args) {
        USB3 usb = new Mouse();
        Computer.setUsb(usb);
        usb.start();
        usb.stop();
        
        System.out.println("--------------------------");
        
        usb = new KeyBoard();
        Computer.setUsb(usb);
        usb.start();
        usb.stop();
    }
}
```

输出结果：

```
鼠标开始连接
断开鼠标
--------------------------
键盘开始连接
断开键盘
```

**对于接口中声明的默认方法，由于接口无法创建对象，只能通过实现类对象才能调用**：

**对于接口中声明的静态方法，因为静态方法是属于类的（将接口看成是一种类），所以静态方法不能被继承，只能通过`接口名.静态方法`进行调用。**





#### 4、接口的实现具有继承传递性

含义：当一个类A实现了一个接口I，其子类类B就算没有显式地实现接口I，也会因为是类A的子类具有传递性，自身也相当于实现了接口I。

例如：

```java
interface I{
    public void method();
}

abstract class T1 implements I{
}


class T2 extends T1{
    @Override
    public void method() {
    }
}


```

又例如：

```java
public class Throwable implements Serializable {
    @java.io.Serial
    private static final long serialVersionUID = -3042686055658047285L;
    ...
}

public class Exception extends Throwable {
    @java.io.Serial
    static final long serialVersionUID = -3387516993124229948L;
    ...
}
```

虽然Exception类没有实现Serializable接口，但因为Exception继承于Throwable类，Throwable类实现了Serializable，所以Exception相当于实现了Serializable接口，可以声明serialVersionUID。

## JDK8中接口存在的相关冲突问题

对于抽象方法重名的情况，只需要在实现类中重写一个，会将所有同名的抽象方法进行重写。

### 1、默认方法冲突问题

#### （1）类与接口冲突，类优先原则

> 当一个类，既继承一个父类，又实现若干接口时，父类中的成员方法与接口中的默认方法同名同参，此时就会发生冲突问题。
>
> 当子类未对该方法进行重写，**默认情况下，执行的是父类中的成员方法。**

例如：

定义接口：

```java
interface Friend {
    default void date(){//约会
        System.out.println("吃喝玩乐");
    }
}
```

定义父类：

```java
class Father {
    public void date(){//约会
        System.out.println("爸爸约吃饭");
    }
}
```

定义子类：

```java
class Son extends Father implements Friend{
    //若不重写，则默认保留父类的同名方法
}
```

测试类：

```java
public class InterfaceConflictTest {
    @Test
    public void test(){
        Son son = new Son();
        son.date();
    }
}
```

执行结果：

<img src=".\images\image-20231126104938235.png" align="left">



> 当子类去重写该方法，就不会出现冲突问题。
>
> 通过**`super.方法名`**或者**`父接口名.super.方法名`**的方式，选择子类中要保留的方法。
>
> 也可以直接重写该方法。

子类案例：

```java
class Son extends Fathers implements Friend{
    //若不重写，则默认保留父类的同名方法

    public void date(){
        //在重写中，可以通过super.方法名去调用父类的方法
//        super.date();
        //也可以使用父接口.super.方法名去调用父接口的方法
//        Friend.super.date();

        //同样也可以自己去重写方法
//        System.out.println("自己去玩！");
    }
}
```



#### （2）接口与接口冲突

当一个类或接口同时实现或继承了多个父接口，且这些接口中包含同名同参的默认方法时，此时就会报错，发生了方法的冲突。

这时因为都是接口，不会出现默认优先执行哪一个方法的现象，必须要进行重写了。

> 1. 可以选择保留其中一个，通过“**`接口名.super.方法名`**”的方式选择保留那个接口的默认方法。
>
> 2. 也可以直接进行重写。

案例：

```java
interface Friend {
    default void date(){//约会
        System.out.println("吃喝玩乐");
    }
}

interface Classmates{
    default void date(){
        System.out.println("图书馆学习");
    }
}

interface Son extends Friend, Classmates{
    default void date(){
        //保留Friend父接口中的date()方法
		//Friend.super.date();

		//保留Classmates接口中的date()方法
        //Classmates.super.date();
        
        //也可以直接进行重写
        System.out.println("自己去玩");
    }
}
```



### 常量冲突问题

* 当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。
* 当子类同时实现多个接口，而多个接口存在相同同名的常量。

此时





## 总结

- 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。
- 声明接口用interface，接口的成员声明有限制：
  - （1）公共的静态常量
  - （2）公共的抽象方法
  - （3）公共的默认方法（JDK8.0 及以上）
  - （4）公共的静态方法（JDK8.0 及以上）
  - （5）私有方法（JDK9.0 及以上）
- 类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。
- 接口可以继承接口，关键字是extends，而且支持多继承。
- 接口的默认方法可以选择重写或不重写。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。
- 接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。



## 有关接口的问题：

### 1、为什么接口中只能声明公共的静态常量？

因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就会有“危险”。

例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V/500mA

### 2、为什么JDK1.8之后允许接口定义静态方法和默认方法呢，它违反了接口作为一个抽象标准定义的概念？

`静态方法`：因为之前的标准类库设计中，有很多Collection/Collections或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。

`默认方法`：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。

### 3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。

**私有方法**：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。

在实际的开发中，我们使用接口中的静态、默认和私有方法还是比较少的，更多的是在源码中使用，但是我们要会使用。





## this和super的区别

this表示的是调用当前成员的对象，而super表示的是父类。

二者一个表示的是对象，一个表示的是类，所以在考虑逻辑是需要注意，一个和创建出来的对象有关，一个只与类有关，与对象无关。

当我们去创建一个子类对象时，如果对象的方法中使用的是this.方法名的方式去调用方法，那么该方法可能会被重写（覆盖），此时就会去调用已经被覆盖了的方法；

如果对象的方法中使用的是super.方法名的方式去调用，那么肯定会去调用父类中的方法，而不用考虑是否被覆盖。



---

# 内部类

推荐查看资料：[【Java基本功】一文读懂Java内部类的用法和原理-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1513052)

## 内部类概述

### 1、什么是内部类

将一个类A定义在另一个类B里面，里面的那个类A就成为`内部类（InnerClass）`，类B则称为`外部类（OuterClass）`。

### 2、为什么要声明内部类？

具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。

> 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。——《Think in java》

也就是说内部类拥有类的基本特征。在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，**间接解决类无法多继承引起的一系列问题**。

例：

```java
/**
 1. Outer类继承了ClassA，实现了IFunctionA
*/
public class Outer extends ClassA implements IFunctionA{ 
	/**
	*	Inner类继承了ClassB，实现了IFunctionB
	*/
	public class Inner extends ClassB implements IfunctionB{
	//
	} 
}
```

除了上面的优点之外，下面是一些需要内部类的常见情况：

> 1. 封装性和组织性：内部类可以将相关的类组织在一起，提高封装性

总的来说，遵循**`高内聚、低耦合`**的面向对象开发原则。

### 3、内部类的分类以及如何使用内部类

简单总结如下：

<img src=".\images\20180929170617308.jfif">

### 4、内部类的特性

1. **内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。**

2. **内部类不能用普通的方式访问。** 

3. **内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量 。**

4. **外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问**

## 成员内部类

成员内部类可以看成是外部类的一个成员，类似于类中的方法，只不过这个“方法”的结构是完整的类类型。

成员内部类分为**非静态内部类**和**静态内部类**。

当我们不使用外部类中的非静态成员时，通常将内部类声明为静态内部类；否则声明为非静态内部类。

**1、成员内部类语法格式**：

```java
[修饰符] class 外部类 {
	[其他修饰符] [static] class 内部类 {
	}
}
```

外部类可以进行修饰的只有`缺省`、`public`和`abstract`。但是内部类还可以使用`private`、`protected`以及`static`进行修饰。这一点，也就是我将其看成是外部类的一部分的原因，方法也是可以声明成`private`、`protected`以及`static`的。



**2、成员内部类的使用特征，概况来讲有如下两种角色**：

* **成员内部类作为`类的成员的角色`：**
  * 和外部类不同，内部类还可以声明为private或protected；
  * 可以调用外部类的结构。但是注意：在静态内部类中不能调用外部类的非静态成员）
  * 内部类可以声明为static，但是此时就不能再使用外部类的非static的成员。
* **成员内部类作为`类的角色`：**
  * 可以在内部定义属性、方法、构造器等结构
  * 可以继承自己想要继承的父类，实现自己想要实现的结构，和外部类的父类以及父接口无关。
  * 可以声明为抽象类，因此可以被其他的内部类继承
  * 可以声明为final，表示不能被继承
  * 编译以后生成OuterClass$InnerClass.class字节码文件

**3、注意点**：

> 1. **外部类访问内部类的成员，需要使用“`内部类.成员`”（静态成员）或“`内部类对象.成员`”（非静态成员）的方式**
>
> 2. **当内部类与外部类中的方法或属性同名时，在内部类中直接调用默认调用的是内部类中的属性或方法，要想调用外部类中的同名的属性或方法，需要使用：**
>
>    ```java
>    外部类名.this.成员属性或方法
>    ```
>
>    **的方式。**
>
> 3. 成员内部类可以直接使用外部类的所有成员，包括私有的数据。
>
> 4. **当想要在外部类的静态成员中使用内部类对象，需要将内部类声明为静态的**，将成员内部类看作是外部类的一个成员，只有当内部类设置成静态的，才可以被外部类中静态方法使用。
>
> 5. **内部类如果设置成静态的，就不能直接访问外部类的成员了，此时内部类只能访问外部类的静态成员。**



**4、对于成员内部类何时设置成静态的理解：**

外部类，即我们平时使用的类，其实本身就是静态的，静态的成员是在类加载时就创建了，而类加载的时候，其本身也就会创建，所以外部类本身一定是静态的，一定有一个static修饰。

对于成员内部类而言，它作为外部类的一个成员，当外部类加载时，其内部类不一定会加载，要将其看成一种类似于方法的成员，当我去给它设置成static时，它就会加载；否则只有去创建内部类对象时，其才会被加载。

所以：

> * **如果想在外部类的静态成员中，直接通过创建内部类对象的方式，去调用内部类中的非静态成员时，此时就需要将内部类设置成静态的。**
>

如：

```java
public class OuterClass {
    public static class InnerClass{
    }
    
    public static void method(){
       InnerClass innerClass = new InnerClass();
    }
}
```

将内部类设置成静态的目的是，为了让外部类加载时，其中的内部类也被加载（看作是外部类的成员），这样就能够让外部类中的静态方法访问到内部类，能够通过创建内部类对象的方式访问到内部类中的信息。

但如果通过以下这种方式，内部类不设置成静态的，外部类中的非静态成员也可以访问到：

```java
public class OuterClass {
    public class InnerClass{
    }

    public static void method(){
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
    }
}
```

即通过使用其他类创建内部类的方式，去创建内部类，就不需要考虑内部类是否是静态的。

### 1. 非静态成员内部类

**在其他类如何创建非静态成员内部类对象**：

先创建外部类对象，然后通过外部类对象去创建。

> <font color="red">**外部类名 外部类变量名 = new 外部类();**</font>
>
> <font color="red">**外部类名.非静态内部类名 内部类变量名 = 外部类变量名.new 非静态内部类名();**</font>

例如：

```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

也可以在外部类中定义get方法，用于获取内部类对象，在使用时，只需要outer.getInnerInstance()即可。比如：

```java
Outer outer = new Outer();
Outer.Inner inner = outer.getInnerInstance();
```



### 2. 静态成员内部类

静态内部类是定义在外部类内部的静态类，与非静态成员内部类不同，静态内部类不依赖于外部类的实例，可以直接使用。在其他类中创建静态内部类的语法：

**其他类如何创建静态成员内部类对象**：

> <font color="red">**外部类名.静态内部类名 内部类变量名 = new 外部类名.静态内部类名();**</font>

例如：

```java
Outer.Inner inner = new Outer.Inner();
```



静态内部类和非静态内部类差别不是很多，最重要的一点是在于当外部类中的静态成员想要访问内部类中的非静态信息时，此时，就需要去创建内部类的对象，只有当内部类设置为静态时才不会报错。

但是如果是通过其他类创建内部类的方式去创建内部类，而不是通过new直接创建的话，则无需将内部类设置为静态的。

静态成员内部类是随着外部类的加载而加载的，如果是在外部类的静态成员中创建内部类对象，此时静态内部类也已经加载，就不会报错；否则，非静态成员内部类此时未被加载，也就无法在外部类的静态成员中找到这个类，创建对象时也就会报错。二者加载的时机不同。

对于类中的其他成员，例如属性和方法，如果是静态的，也是随着类的加载而加载；如果是非静态的，类加载时并没有被加载，而是当对象创建时才会被创建。

**成员内部类使用举例：**

```java
//外部类
class Outer{
    private int outerVariable = 1;
    private int commonVariable = 2;
    private static int outerStaticVariable = 3;
    Inner inner = new Inner();
    /**
     * 成员方法
     */
    public void outerMethod() {
        System.out.println("我是外部类的outerMethod方法");
    }

    /**
     * 静态方法
     */
    public static void outerStaticMethod() {
        System.out.println("我是外部类的outerStaticMethod静态方法");
    }

    public Outer(){}

    public void method(){}

    class Inner{

        public static int innerStaticVariable = 1;
        private int commonVariable = 20;
        
        public Inner(){}
        public void method(){}
        public void innerShow() {
            //当和外部类冲突时，直接引用属性名，是内部类的成员属性
            System.out.println("内部的commonVariable:" + commonVariable);

            //内部类访问外部属性
            System.out.println("outerVariable:" + outerVariable);

            //当和外部类属性名重叠时，可通过外部类名.this.属性名的方式进行调用
            System.out.println("外部的commonVariable:" + Outer.this.commonVariable);
            System.out.println("outerStaticVariable:" + outerStaticVariable);

            //访问外部类的方法
            outerMethod();
            outerStaticMethod();

            //同理，当外部类方法名与内部类方法名重名时
            //在内部类中直接使用方法名的方式调用的是内部类中的方法
            //使用外部类名.this.方法名的方式调用外部类同名的方法
            method();
            Outer.this.method();
        }
    }

   	public void outerShow(){
        //如果在外部类中想要调用内部类中的成员属性或方法，需要使用内部类对象调用
        Inner inner = new Inner();
        inner.innerShow();
        //对于静态的方法或属性直接使用内部类调用
        Inner.innerStaticMethod();
    }
    
    //若外部类中的静态成员想要访问内部类时，需要将内部类设置成静态的
}

//测试类
public class MemberInnerClassTest {
    @Test
    public void test(){
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
    }
}
```



### 小结：【成员内部类当成是外部类的成员信息存在】

1. 内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）
2. 外部类也可以访问内部类的所有成员变量和方法（包括private），外部类若想访问内部类的非静态信息，**必须先创建内部类对象，通过内部类对象去调用**。静态信息通过内部类名直接调用。
3. 外部类中的静态成员若想访问内部类中的非静态信息（创建内部类对象的方式），则必须将内部类设置成静态的，才能进行访问。（如果通过其他类创建内部类的方式创建内部类，则无需将内部类设置为静态的）

设置成静态的，外部类静态成员如何调用：

```java
Inner inner = new Inner();
```

未设置成静态的，外部类静态成员如何调用：

```java
Outer outer = new Outer();
Inner inner = outer.new Inner();
```

4. 若在内部类与外部类中存在同名的属性或同名同参的方法，在内部类中直接调用默认是调用内部类中的成员，如果想要调用外部类中的同名的成员，需要使用：

```java
外部类名.this.属性或方法名
```

​		的方式。

5. <font color="red">**普通内部类中不能有静态成员。**</font>

> 1. 成员内部类之所以叫做成员，就是说他是类实例的一部分，而不是类的一部分 
>
> 2. 结构上来说，他和你声明的成员变量是一样的地位，一个特殊的成员变量，而静态的变量是类的一部分和实例无关
>
> 3. 你若声明一个成员内部类，让他成为主类的实例一部分，然后又想在内部类声明和实例无关的静态的东西，你让JVM情何以堪啊
>
> 4. 若想在内部类内声明静态字段，就必须将其内部类本身声明为静态

**成员内部类的字节码文件**：

> **以外部类为开头，后面跟上$，然后再加上成员内部类名**

例如：

![image-20231127202632777](.\images\image-20231127202632777.png)

## 局部内部类

局部内部类分为非匿名内部类和匿名内部类。

### 非匿名内部类

非匿名内部类是定义在一个方法内部的内部类，它的作用域仅限于包含它的方法。非匿名内部类通常用于解决一些特定的问题，例如需要一个临时的类来完成某项任务。非匿名内部类的基本语法如下：

**语法格式**：

```java
[修饰符] class 外部类{
    [修饰符] 返回值类型  方法名(形参列表){
        [final/abstract] class 内部类{
        	//非匿名内部类信息
    	}
    }    
}
```

* 编译后有自己独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。

  * 在字节码文件中，在$后面以数字开头的，后面跟上类名的，都是局部内部类。
  * 这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类。

  例如，在下例中，就是在Person类的不同方法中创建了多个InnerClass1类：

![image-20231127202726991](.\images\image-20231127202726991.png)

* 和成员内部类不同的是，它前面不能有权限修饰符等
* 局部内部类如同局部变量一样，有作用域
* 局部内部类中是否能够访问外部类的非静态成员，取决于所在的方法



使用场景案例：

```java
public class LocalInnerClass {
   	public Comparable getInstance(){
        
       // 提供实现了Comparable接口的类，局部内部类
        class MyComparable implements Comparable{
            @Override
            public int compareTo(Object o) {
                return 0;
            }
        }
        return new MyComparable();
    }
}
```

比如在上例中，当我们要去获取一个Comparable接口实现类对象的返回值时，因为我们没有去创建过Comparable接口的实现类，当我们需要去获取时，可以在方法中临时地创建一个。

局部内部类可以用来解决一些特定的问题，例如需要一个临时的类来完成某项任务。

### 匿名内部类

在[匿名子类详解](.\匿名子类详解.md)文件中，我对这一部分进行了详细解释，可以查看。匿名内部类，也就是所谓的匿名子类。

**语法结构：**

```java
new 父类([实参列表])/父接口(){
	重写方法...
}
```

举例：使用匿名内部类的对象直接调用方法：

```java
interface A{
	void a();
}
public class Test{
    public static void main(String[] args){
    	new A(){
			@Override
			public void a() {
				System.out.println("aaaa");
			}
    	}.a();
    }
}
```



* 匿名内部类编译后也 有自己独立的字节码文件，只不过在外部类名后面跟上的是$和数字，没有类名。

例如：其中的OuterClassTest1表示的是外部类名，跟上$表示内部类，后面只有1，表示是第一个编译的匿名内部类。

![image-20231127203442473](.\images\image-20231127203442473.png)

**匿名内部类可能存在的问题：**

> **匿名内部类中，若匿名子类中新建了子类独有的方法，而父类或父接口中没有该方法，则此时不构成方法的重写。此时不能通过父类的引用去调用（因为父类/父接口中不存在该方法，编译时报错），那么若想调用该方法，则不能创建匿名内部类的父类/父接口的引用，只能在匿名内部类声明时直接调用。这样一来，匿名内部类只能使用一次。**

例如：

```java
public class Test{
	@Test
	public void test(){
		Object obj = new Object(){
			public void method(){
				System.out.println("匿名子类中的method方法");
			}
		};
		obj.method();//报错
	}
}
```

此时构成多态，父类的引用指向了匿名子类的对象，会因为Object类中不存在method()方法而报错。

若想成功调用，只能改成：

```java
public class Test {
    @Test
    public void test(){
        new Object(){
            public void method(){
                System.out.println("尚硅谷");
            }
        }.test();
    }
}
```

但是，此时由于未创建父类的引用，创建出来的匿名子类对象只能使用一次。



## 内部类的加载时机？

**内部类的加载时机？它和外部类的加载有没有什么关系？**

> **`静态内部类和非静态内部类一样，都是在被调用时才会被加载。`**和外部类的加载没有必然关系。但是在加载内部类的时候，发现外部类还没有加载，那么就会先加载外部类，加载完外部类之后，再加载内部类。
>
> 
>
> 如果在程序中单纯的使用外部类，并不会触发静态内部类的加载。
>
> 
>
> **扩展：**类的加载时机：new 一个类的时候，调用类内部的静态变量，调用类的静态方法，调用类的静态内部类。











# 枚举类

开发中，如果针对于某个类，其实例是确定个数且值是不变的，类似于固定个数的常量，那么我们就可以使用枚举类来保存这些实例。

枚举类实际就是类，只不过这个类对象是固定的，限制了用户去创建对象，并且将所有的对象保存在了类里面，可以直接进行调用。

枚举类的例子：

- `星期`：Monday(星期一)......Sunday(星期天)
- `性别`：Man(男)、Woman(女)
- `月份`：January(1月)......December(12月)
- `季节`：Spring(春节)......Winter(冬天)
- `三原色`：red(红色)、green(绿色)、blue(蓝色)
- `支付方式`：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)
- `就职状态`：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)
- `订单状态`：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）
- `线程状态`：创建、就绪、运行、阻塞、死亡

**若枚举只有一个对象，则可以作为一种单例模式的实现方式**

## 定义枚举类

**格式**：

```java
【修饰符】 enum 枚举类名{
    常量对象列表
}
```

**要求与特点**：

* 枚举类的常量对象必须放在枚举类的首行，建议大写。

* 列出来的常量对象，会自动添加public static final进行修饰，常量不可修改其中的属性值，所以不提供set方法，只提供get方法。

* 每个常量对象之间使用“,”进行分隔，最后一个常量对象使用";"结尾。

* 由于限制了用户去创建枚举类的对象，所以构造器要求是private类型的。

* 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明。如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。

* 枚举类默认继承的是`java.lang.Enum`类，因此不可再显式地去继承父类。

* switch提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。

* 对于枚举类中的属性，需要使用：

  <font color="red">**`private final`**</font>

  进行修饰，因为枚举类中的属性仅在该类中使用，且不可修改。

* 枚举类中创建的对象常量，全样实际是：

  <font color="red">**`public static final 类名 对象名 = new 类名(实参列表);`**</font>

​		将其简化成了：

​		<font color="red">**`对象名(实参列表);`**</font>

具体实现：

```java
public enum Weekend {
	//创建枚举类对象常量，声明在枚举类的首位
    MONDAY("Monday","星期一"),
    TUESDAY("Tuesday","星期二"),
    WEDNESDAY("Wednesday","星期三"),
    THURSDAY("Thursday","星期四"),
    FRIDAY("Friday","星期五"),
    SATURDAY("Saturday","星期六"),
    SUNDAY("Sunday","星期日");

	//声明每个对象拥有的属性：private final修饰
    private final String weekendCode;
    private final String weekendName;
    
    //私有化枚举类的构造器
    private Weekend(String weekendCode, String weekendName){
        this.weekendCode = weekendCode;
        this.weekendName = weekendName;
    }

    //创建枚举类属性的get方法，不提供set方法
    public String getWeekendCode() {
        return weekendCode;
    }

    public String getWeekendName() {
        return weekendName;
    }
}
```

**注意点**：

> 1. **枚举类中声明的属性，需要使用<font color="red">`private final`</font>进行修饰**
> 2. **枚举类一般只提供属性get方法，不提供set方法（枚举常量不可被修改）**
> 3. **对于枚举类中对象属性，要有包含相应实参列表的构造器与之对应**

总而言之，就是将枚举类看作是一种特殊的类进行处理即可。

## 枚举类中常用的方法

```java
* String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！
    
* static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
    
* static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
    
* String name():得到当前枚举常量的名称。建议优先使用toString()。
    
* int ordinal():返回当前枚举常量的次序号，默认从0开始
```

这里的name，是枚举类中该枚举类常量的常量名。例如：MONDAY("Monday","星期一")这个枚举常量的name是`MONDAY`，是常量名，而和枚举中的实参无关。



## 实现接口的枚举类

- 和普通类一样，枚举类也可以实现一个或多个接口
- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可，此时通过不同的枚举类对象调用的重写方法都是同一个。
- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，此时通过不同的枚举类调用的重写方法不同。

**语法：**

```java
//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！
enum A implements 接口1，接口2{
	//抽象方法的实现
}

//2、如果枚举类的常量可以继续重写抽象方法!
enum A implements 接口1，接口2{
    常量名1(参数){
        //抽象方法的实现或重写
    },
    常量名2(参数){
        //抽象方法的实现或重写
    },
    //...
}
```

例如：

接口：

```java
interface Info{
    void show();
}
```

枚举类对象对于接口呈现相同的行为：

```java
public enum Weekend implements Info{
    MONDAY("Monday","星期一"),
    TUESDAY("Tuesday","星期二"),
    WEDNESDAY("Wednesday","星期三"),
    THURSDAY("Thursday","星期四"),
    FRIDAY("Friday","星期五"),
    SATURDAY("Saturday","星期六"),
    SUNDAY("Sunday","星期日");
    
    private final String weekendCode;
    private final String weekendName;
    private Weekend(String weekendCode, String weekendName){
        this.weekendCode = weekendCode;
        this.weekendName = weekendName;
    }
	//接口的实现
    @Override
    public void show(){
        System.out.println("Weekend枚举类");
    }
}
```

枚举类对象对于接口呈现不同的行为：

```java
public enum Weekend implements Info{
    MONDAY("Monday","星期一"){
        @Override
        public void show() {
            System.out.println("星期一");
        }
    },
    TUESDAY("Tuesday","星期二"){
        @Override
        public void show() {
            System.out.println("星期二");
        }
    },
    WEDNESDAY("Wednesday","星期三"){
        @Override
        public void show() {
            System.out.println("星期三");
        }
    },
    THURSDAY("Thursday","星期四"){
        @Override
        public void show() {
            System.out.println("星期四");
        }
    },
    FRIDAY("Friday","星期五"){
        @Override
        public void show() {
            System.out.println("星期五");
        }
    },
    SATURDAY("Saturday","星期六"){
        @Override
        public void show() {
            System.out.println("星期六");
        }
    },
    SUNDAY("Sunday","星期日"){
        @Override
        public void show() {
            System.out.println("星期日");
        }
    };

    private final String weekendCode;
    private final String weekendName;
    private Weekend(String weekendCode, String weekendName){
        this.weekendCode = weekendCode;
        this.weekendName = weekendName;
    }
}
```

## 开发中枚举类的用法

**在开发中，枚举类经常搭配switch...case语句，那么在switch...case中如何使用枚举类？**

一般获取到的是枚举类的对象中的实参列表的实参值，JDK提供的switch...case匹配的是**枚举常量名**，所以我们还需要在枚举类中提供一个方法，通过实参值来获取到对应的枚举常量，从而匹配swicth...case中不同的枚举常量，执行不同的代码。

案例：

定义枚举类：

```java
public enum Weekend {
    MONDAY("Monday","星期一"),
    TUESDAY("Tuesday","星期二"),
    WEDNESDAY("Wednesday","星期三"),
    THURSDAY("Thursday","星期四"),
    FRIDAY("Friday","星期五"),
    SATURDAY("Saturday","星期六"),
    SUNDAY("Sunday","星期日");

    private final String weekendCode;
    private final String weekendName;
    private Weekend(String weekendCode, String weekendName){
        this.weekendCode = weekendCode;
        this.weekendName = weekendName;
    }

    /**
     * 根据传入的weekendCode获取枚举值
     * @param weekendCode
     * @return
     */
    public static Weekend getWeekendByCode(String weekendCode){
        for (Weekend weekend : Weekend.values()) {
            if (weekend.getWeekendCode().equals(weekendCode)){
                return weekend;
            }
        }
        return null;
    }
}
```

根据从数据库中获取的weekendCode，获取对应的枚举类，使用switch...case语句，执行不同的代码：

```java
public class EnumTest {
    @Test
    public void test(){
        //假设以下的值是从数据库中获取到了枚举类的属性值
        String code = "Saturday";

        //此时，我们要去判断，当前的获取到的值属于哪一个枚举对象
        //不同的枚举对象，会去执行不同的代码
        Weekend weekend = Weekend.getWeekendByCode(code);
        if (weekend != null) {
            switch (weekend){
                case MONDAY -> {
                    System.out.println("星期一");
                    break;
                }
                case TUESDAY -> {
                    System.out.println("星期二");
                    break;
                }
                case WEDNESDAY -> {
                    System.out.println("星期三");
                    break;
                }
                case THURSDAY -> {
                    System.out.println("星期四");
                    break;
                }
                case FRIDAY -> {
                    System.out.println("星期五");
                    break;
                }
                case SATURDAY -> {
                    System.out.println("星期六");
                    break;
                }
                case SUNDAY -> {
                    System.out.println("星期日");
                    break;
                }
            }
        }else {
            System.out.println("获取的数据有误，请检查！");
        }
    }
}
```

这就是在开发中，枚举类搭配swicth...case语句的用法

当然，还可以使用另一种方式去根据数据库中的值获取对应的枚举类：

可以将枚举类中的属性设置成与枚举类对象的name值一致，这样就可以通过枚举类的valueOf()方法，获取对应的枚举类对象，而不需要在枚举类中定义一个单独的方法去获取，例如：

```
public enum Weekend {
    MONDAY("MONDAY","星期一"),
    TUESDAY("TUESDAY","星期二"),
    WEDNESDAY("WEDNESDAY","星期三"),
    THURSDAY("THURSDAY","星期四"),
    FRIDAY("FRIDAY","星期五"),
    SATURDAY("SATURDAY","星期六"),
    SUNDAY("SUNDAY","星期日");

    private final String weekendCode;
    private final String weekendName;
    private Weekend(String weekendCode, String weekendName){
        this.weekendCode = weekendCode;
        this.weekendName = weekendName;
    }
}
```

对于上例中，weekendCode的值与枚举类的name值一致，可以直接通过枚举类.valueOf(name)获取对应的枚举类对象了。

---

# 注解（也称为元数据）

详解请查看[Java注解入门到精通，这一篇就够了_java注解精通联系-CSDN博客](https://blog.csdn.net/KingBoyWorld/article/details/105337011)

## 注解概述

### 为什么要学注解？

在日常开发中，基本都是在使用别人定义或是各种框架的注解，比如Spring框架中常用的一些注解：`@Controller`、`@Service`、`@RequestMapping`，以此来实现某些功能，但是却不知道如何实现的，所以如果想学习这些框架的实现原理，那么注解就是我们必知必会的一个点。其次，我们还可以使用注解来自定义一些功能，比如在某个方法上加上一个自定义注解，就可以实现方法日志的自动记录打印。所以，如果你想走上人生巅峰，更好的利用框架，那么学习注解都是前提。

### 什么是注解？

在Java中，注解其实就是写在接口·、类、属性、方法上的一个标签，或者说是一种特殊形式的注释，与普通的//或/**/不同的是：普通注释不会对代码运行产生影响，只是给程序员看的代码解释；而注解在<strong>代码运行时</strong>是可以被<strong>反射</strong>读取并执行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。

举一个例子`@Override`就是一个注解，它的作用是告诉阅读者（开发人员、编译器）这个方法重写了父类的方法，对于开发人员只是一个标志，而编译器则会多做一些事情，编译器如果发现方法标注了这个注解，就会检查这个方法是否真的重写了父类的方法，如果没有就会直接报错。而如果不添加`@Override`注解，程序也是可以正常运行的，但是缺乏了对于方法是否重写的检查，使得有时想去覆盖父类中的方法但是却新建了一个方法，可能会造成错误。

> 在spring框架中·加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。

上面的说法是为了方便理解，那么下面来个稍微正式一点的：**注解是提供一种为程序元素设置元数据的方法**，元数据即为描述数据的数据，例如对于一个图片来说，图片本身就是一个数据，其属性就是图片的元数据，就是描述图片的数据。

**Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。**



### 注解的重要性

在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在`JavaEE/Android中注解占据了更重要的角色`，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的`繁冗代码`和`XML配置`等。

未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。`注解是一种趋势`，一定程度上可以说：`框架 = 注解 + 反射 + 设计模式`。



### Java注解Annotation的作用

* **生成文档是最常见的，也是Java最早提供注解的作用，比如文档注释中的@author；**

```
@author 标明开发该部分的作者，多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向，也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明，如果没有参数就不能写
@return 对方法返回值的说明，如果方法的方绘制类型是void就不能写
@exception 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出异常就不能写
```

例如：

```java
package com.annotation.javadoc;
/**
 * @author 尚硅谷-宋红康
 * @version 1.0
 * @see Math.java
 */
public class JavadocTest {
	/**
	 * 程序的主方法，程序的入口
	 * @param args String[] 命令行参数
	 */
	public static void main(String[] args) {
	}
	
	/**
	 * 求圆面积的方法
	 * @param radius double 半径值
	 * @return double 圆的面积
	 */
	public static double getArea(double radius){
		return Math.PI * radius * radius;
	}
}
```



* **在编译时进行格式检查（JDK内置的三个基本注解）**

  例如：@Override用于限定重写父类方法

  ```java
  public class AnnotationTest{
   
  	public static void main(String[] args) {
  		@SuppressWarnings("unused")
  		int a = 10;
  	}
  	@Deprecated
  	public void print(){
  		System.out.println("过时的方法");
  	}
   
  	@Override
  	public String toString() {
  		return "重写的toString方法()";
  	}
  }
  ```

  

* **跟踪代码依赖性，实现替代配置文件功能**

  比较常见的是spring2.5开始的基于注解配置，作用就是减少配置，以下的案例就是spring重病关于“事务”的管理

  ```java
  @Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)
  public void buyBook(String username, String isbn) {
  	//1.查询书的单价
      int price = bookShopDao.findBookPriceByIsbn(isbn);
      //2. 更新库存
      bookShopDao.updateBookStock(isbn);	
      //3. 更新用户的余额
      bookShopDao.updateUserAccount(username, price);
  }
  ```

  ```java
  <!-- 配置事务属性 -->
  <tx:advice transaction-manager="dataSourceTransactionManager" id="txAdvice">
         <tx:attributes>
         <!-- 配置每个方法使用的事务属性 -->
         <tx:method name="buyBook" propagation="REQUIRES_NEW" 
  	 isolation="READ_COMMITTED"  read-only="false"  timeout="3" />
         </tx:attributes>
  </tx:advice>
  ```

  

* **编译时动态处理**，如动态生成代码，如@Data注解；**运行时动态处理，作为额外信息的载体**，如获取注解信息

### 注解的分类

注解可以分为以下三类：

* **标准注解**——Java提供的基础注解，标明过期的元素/标明是复写父类的方法/标明抑制警告。
* **元注解**——定义注解的注解，标明该注解的使用范围、生命周期等。

* **自定义注解**——用户根据自己的需求定义的注解。

![img](.\images\fdea7756884343f59df8da5a7728a019~noop.image)

### 标准注解

![img](.\images\b8467d67488b45aaac66103d2b76eb7c~noop.image)

#### 1、@Override

* 用于检测被标记的方法是否为有效的重写方法，如果不是，则报编译错误！
* 只能标记在方法上。
* 它会被编译器程序读取。

案例：

```java
class Parent{
    public void test(){
    }
}

class Child extends Parent{
    @Override
    public void test(){
    }
}
```



#### 2、@Deprecated

* 用于表示被标记的数据已经过时了，已经不推荐使用了

> 被@Deprecated修饰的数据虽然已经过时，但是还是可以用的，在JDK版本更迭中，有些旧的代码被新代码所取代，但是为了保障已有的程序不会发生错误，旧代码会被保留下来，此时就会使用到@Deprecated注解，故旧代码不推荐使用是因为有新的代码可以替换，但是还是可以用。

* 可以用来修饰属性、方法、构造器、类、包、局部变量、参数。
* 它会被编译器程序读取。

案例：

```java
@Deprecated
class TestClass{
    
    @Deprecated
    public void method(){
    }
}
```

此时去创建TestClass对象或者调用method()方法时，编译器中都会将其用删除线划去：

![image-20231129111236470](.\images\image-20231129111236470.png)

![image-20231129111310896](.\images\image-20231129111310896.png)

#### 3、@SuppressWarnings

* 抑制编译警告。当我们不希望看到警告信息的时候，可以使用SuppressWarnings注解来抑制警告信息。

* 可以用于修饰类、属性、方法、构造、局部变量、参数

* 它会被编译器程序读取。

* 可以指定的警告类型有：

  - all，抑制所有警告

  - unchecked，抑制与未检查的作业相关的警告

  - unused，抑制与未用的程式码及停用的程式码相关的警告

  - deprecation，抑制与淘汰的相关警告

  - nls，抑制与非 nls 字串文字相关的警告

  - null，抑制与空值分析相关的警告

  - rawtypes，抑制与使用 raw 类型相关的警告

  - static-access，抑制与静态存取不正确相关的警告

  - static-method，抑制与可能宣告为 static 的方法相关的警告

  - super，抑制与置换方法相关但不含 super 呼叫的警告

  - ...

示例代码：

```java
public class CommentTest {
    @Test
    public void test(){
        //抑制已弃用代码的警告
        //values值若有多个，使用value={"",""}的格式
        @SuppressWarnings("deprecation")
        TestClass test = new TestClass();
    }
}
```



### 元注解

用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。

元注解是最基本不可分解的注解，我们不**能去改变它只能使用它来定义自定义的注解**。

元注解包含以下五种：

> * **@Retention**：用于描述注解的生命周期。
> * **@Target**：用于描述注解的使用范围
> * **@Documented**：表明这个注解应该被javadoc工具记录
> * **@Inherited**：子类会继承父类所标注的注解

其中最常用的是`@Retention`和`@Target`，下面分别介绍一下这五种元注解。

#### 1、@Retention

共有三种值，通过枚举类型RetentionPolicy的3个常量对象来指定：

> * **`SOURCE`**（源代码）
> * **`CLASS`**（字节码）
> * **`RUNTIME`**（运行时）

只有将注解设置成**`RUNTIME`**阶段才能被反射读取到。

例如：

![image-20231129154414618](.\images\image-20231129154414618.png)

从编写Java代码到运行主要周期为**`源文件`** -> **`CLass文件`** -> **`运行时数据`**，@Retention则标注了注解的信息要保留到哪个阶段，分别对应的value取值为**`SOURCE`** -> **`CLASS`** -> **`RUNTIME`**。

* SOURCE 源文件java文件，生成的class文件中就没有该信息了
* CLASS class文件中会保留注解，但是JVM加载运行时就没有了
* RUNTIME 运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的

#### 2、@Target

翻译为目标，描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上（类、方法、属性、局部变量、参数...）

![image-20231129200308816](.\images\image-20231129200308816.png)

value是一个数组，可以有多个取值，说明同一个注解可以同时标注在不同的元素上。value的取值如下：

|       值        |               说明                |
| :-------------: | :-------------------------------: |
|      TYPE       |       类、接口、注解、枚举        |
|      FIELD      |               属性                |
|     METHOD      |               方法                |
|    PARAMETER    |             方法参数              |
|   CONSTRUCTOR   |             构造函数              |
| LOCAL_VARIABLE  | 局部变量（如循环变量、catch参数） |
| ANNOTATION_TYPE |               注解                |
|     PACKAGE     |                包                 |
| TYPE_PARAMETER  |          泛型参数 jdk1.8          |
|    TYPE_USE     |          任何元素 jdk1.8          |

#### 3、@Inherited

是否可被标注类的子类继承。被@Inherited修饰的注解是具有继承性的，在自定义的注解标注到某个类时，该类的子类会继承这个自定义注解。这里需要注意的是**只有当子类继承父类的时候，注解才会被继承**，类实现接口，或者接口继承接口，都是无法获得父接口上的注解声明的。

![img](.\images\format,png)

#### 4、@Documented

是否在生产的JavaDoc文档中体现，被标注该注解后，生成的javadoc中，会包含该注解。



### 自定义注解

一个完整的注解应该包含三个部分：

（1）声明

（2）使用

（3）读取

#### 声明自定义注解

**格式**：

```java
【元注解】
【修饰符】 @interface 注解名 {
	修饰符 返回值 属性名() 默认值;
    修饰符 返回值 属性名() 默认值;
}
```

首先注解的修饰符一般是public的，定义注解一般都是要给三方使用的，不是public没有意义。定义注解时使用**`@interface`**，可以猜出来和接口是有一些说不清道不明的关系的，其实注解就是一个接口，在程序运行时，JVM会为其生成对应的代理类。

* 自定义注解可以通过四个元注解@Retention，@Target，@Inherited，@Documented分别说明它的生命周期，使用位置，是否被继承，是否被生产到API文档中。
* Annotation的成员在Annotation定义中以五参数有返回值的抽象方法的形式来声明，又称为配置参数。返回值的类型必须是基本数据类型、Class类型、enum类型、Annotation类型以及这些类型的数组。
* 可以使用default关键字为抽象方法指定默认返回值。
* 如果定义的注解中包含抽象方法，那么在使用时必须为其制定返回值，除非有默认值。格式为：**`方法名=返回值`**，如果只有一个抽象方法需要赋值，且方法名为value，则可以省略"value="，**所以如果注解中只有一个抽象方法成员，建议使用方法名value**。

案例：

```java
@MyAnnotation("chengJiaWei")
public class StudentTest {

    @Column(columnName = "sid",columnType = "int")
    private int id;
    @Column(columnName = "sname@e", columnType = "varchar(20)")
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
```

#### 读取和处理自定义注解

自定义注解必须配上注解的信息处理流程才有意义。

我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的生命周期必须是RetentionPolicy.RUNTIME。

具体的读取和处理自定义注解的方式见反射中。



---

# 单元测试

Junit4版本，要求@Test标记的方法必须满足如下要求：

> * **所在的类必须是public的，非抽象的，包含唯一的无参构造器。**
> * **@Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。**
>



---

# 包装类

## 为什么需要使用包装类？

Java提供了两个类型系统，基本数据类型与引用数据类型。使用基本数据类型在于效率，然而当要使用只针对对象设计的API或新特性（例如泛型），怎么办呢？这个时候就需要将基本数据类型转换成包装类。例如：

```java
//情况1：方法形参
Object类的equals(Object obj)

//情况2：方法形参
ArrayList类的add(Object obj)
//没有如下的方法：
add(int number)
add(double d)
add(boolean b)

//情况3：泛型
Set<T>
List<T>
Cllection<T>
Map<K,V>
```

## 有哪些包装类

Java针对八种基本数据类型，定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。

![image-20231130092712801](.\images\image-20231130092712801.png)

封装以后，内存结构对比：

```java
public static void main(String[] args){
	int num = 520;
	Integer obj = new Integer(520);
}
```

原本的基本数据类型，数据保存在栈中；而转换为包装类后，数据保存在堆中，栈中的引用指向了堆中的对象。

<img src=".\images\image-20220514163725830.png" alt="image-20220514163725830" style="zoom:80%;" />



## 包装类与基本数据类型之间的转换

### 1、装箱（不推荐）

**装箱指把基本数据类型转为包装类对象**。转为包装类对象，是为了使用专门为对象设计的API和特性

**方式：**

> 1. **使用包装类的构造函数**（JDK9之后不建议这样使用）
> 2. **使用包装类的<font color="red">valueOf()</font>方法**

案例：

```java
@Test
public void test(){
    //使用包装类的构造方法
    Integer i1 = new Integer(100);
    Double d1 = new Double(1.1);

    //使用包装类的valueOf()方法
    Character c1 = Character.valueOf('A');
    Long l1 = Long.valueOf(10L);
}
```



### 2、拆箱（不推荐）

**拆箱指把包装类堆拆为基本数据类型**。转为基本数据类型，一般是因为需要运算，Java的大多数运算符是为基本数据类型设计的。比较、算式等。

**方式：**

> **使用包装类的<font color="red">xxxValue()</font>方法**

案例：

```java
@Test
public void test2(){
    Integer i1 = new Integer(10);
    int i2 = i1.intValue();
}
```



### 3、自动装箱与拆箱（推荐）

对于上述的两种基本数据类型与引用数据类型之间转换的方式，都不推荐。

由于我们经常要做基本类型与包装类之间的转换，从`JDK5.0 `开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
@Test
public void test2(){
    ArrayList<Integer> arrayList = new ArrayList<>();
    Integer i1 = 12; //相当于Integer i1 = Integer.valueOf(12)
    arrayList.add(i1);
    i1 = i1 + 3; 
    int i2 = i1; //相当于int i2 = intValue(i1)
    Integer i3 = i2 + 5; //相当于Integer i3 = Integer.valueOf(Integer.valueOf(i2) + 5)
    arrayList.add(i2);
    arrayList.add(i3);
}
```

这样一来，基本数据类型与其包装类之间可以直接自动地转换，不需要也不推荐使用方法进行转换。

> 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱，如果是与不同基本数据类型，需要进行强转。

```java
Integer i = 1;
Double d1 = 1;//错误的，1是int类型
Double d2 = (double)1; //正确，进行了强转
```

**所谓的自动装箱与拆箱，本质上在底层调用的就是valueOf()和xxxValue()方法：**

![image-20231130110707340](.\images\image-20231130110707340.png)

![image-20231130110804273](.\images\image-20231130110804273.png)

## 基本数据类型、包装类与字符串之间的转换

由于自动装箱和拆箱的存在，基本数据类型与包装类之间的转换变得十分容易，甚至可以看成一种类型，那么对于与字符串之间的转换来说，只需要看成是一种与字符串的转换，那么我们就学习平时最常使用到的即可。

> 1. **使用String类型的<font color="red">`valueOf()`</font>静态方法将基本数据类型（包装类）转换成String类型**
>
> 2. **使用相应包装类的<font color="red">`parseXxx(String)`</font>静态方法将String类型转换成基本数据类型（包装类）**

注意：这里有一个比较特殊，就是将String类型转换成char类型，使用的是String类型中的charAt(int index)返回指定索引处的字符。

案例：

```java
@Test
public void test(){
    String s1 = String.valueOf(123);
    String s2 = String.valueOf(false);
    String s3 = String.valueOf('a');

    System.out.println(s1);
    System.out.println(s2);
    System.out.println(s3);

    int i1 = Integer.parseInt(s1);
    boolean b1 = Boolean.parseBoolean(s2);
    char c1 = s3.charAt(0);

    System.out.println(i1);
    System.out.println(b1);
    System.out.println(c1);
}
```



## 转换总结

![image-20220813012801907](.\images\image-20220813012801907.png)



**注意点：**

> 由于包装类是引用数据类型，作为类的成员变量时其默认值是null，而不是基本数据类的0或者false。



## 包装类的特点

### 自动装箱或valueOf()方法创建包装类的特点

使用自动装箱的方式去创建包装类，实际上在底层还是会去调用valueOf()方法创建。

![image-20231130215144910](C:/Users/14036/Desktop/markdown笔记/JavaSE/images/image-20231130215144910.png)

当满足i >= IntegerCache.low && i <= IntegerCache.high时，获得的Integer对象从现有的cache数组中获取的。其中Integer包装类中low的值是-128，high的值是127。

让我们来看看cache数组：

![image-20231130215726147](C:/Users/14036/Desktop/markdown笔记/JavaSE/images/image-20231130215726147.png)

以上这段代码的含义就是，cache数组实际上就是一个Integer数组，保存的是-128 ~127区间以内的Integer对象，在Integer类加载的时候就会被创建出来。

> **当我们使用自动装箱（或者valueOf()方法)的方式去创建Integer对象时，如果数值满足在`-128~127`区间以内，是直接从cache数组中获取已创建的Integer对象。**
>
> **当值不在上述区间内时，自动装箱（valueOf()方法）获取到的包装类对象，则是通过new一个新的包装类对象的方式。**

这么做的好处是有利于节省内存空间。

以上也是一种设计模式：享元设计模式。

那么，根据以上的情况，有可能出现以下这些面试题：

```java
Integer a = 1;
Integer b = 1;
System.out.println(a == b);

Integer i = 128;
Integer j = 128;
System.out.println(i == j);

Integer m = new Integer(1);
Integer n = 1;
System.out.println(m == n);

Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x == y);
```

按照一般的想法来说，以上每一个Integer对象都属于新的对象，按理应该都是false才对。

但是，由于享元的设计，实际上输出的结果为：

```
true
false
false
false
```

原因就在于使用自动装箱或者valueOf()的方式创建Integer包装类对象时，若数值范围在-128~127内，则会从数组中获取Integer对象，而不是去新建一个。那么第一个a对象和b对象都是从数组中获取到的同一个对象，所以二者相等。

而i和j均超过了127，那么底层实际是去new一个对象的，所以二者不同。

对于m来说，它是new出来的，肯定和n不是同一个对象。

x和y更不用说了。

包装类缓存数值的范围都是多少呢？

#### 包装类缓存对象

| 包装类    | 缓存对象    |
| --------- | ----------- |
| Byte      | -128~127    |
| Short     | -128~127    |
| Integer   | -128~127    |
| Long      | -128~127    |
| Float     | 没有        |
| Double    | 没有        |
| Character | 0~127       |
| Boolean   | true和false |

注意，对于Float和Double来说，没有缓存对象，每一个使用自动装箱方式创建的包装类都是新new的。

```java
Double d1 = 1.0;
Double d2 = 1.0;
System.out.println(d1==d2);//false
```



### 包装类与包装类之间，以及与基本数据类型运算的特点

我们先来说结论：

包装类与基本数据类型进行运算时，**`默认会对包装类进行拆箱`**，之后再进行运算。 

同理，如果是包装类与包装类之间进行运算，**`也会对两个包装类先进行拆箱转换成基本数据类型进行`**。

这是一种设定，在进行运算设定为会对包装类进行拆箱，而不是对基本数据类型进行装箱，我觉得是拆箱的成本比较低，装箱还需要去创建一个包装类对象。

案例：

```java
Integer x = 1000;
int y = 1000;
System.out.println(x == y);//true

Integer m = 1000;
double n = 1000;
System.out.println(m == n);//true

Integer a = 10;
Double b = 20.0;
System.out.println(a + b);//30.0
```

以上结果原因就在于，包装类与基本数据类型进行运算时，会对包装类进行拆箱，拆箱之后再使用其对应的基本数据类型进行运算。

同理，如果是包装类与包装类之间进行运算时，也会对包装类先进行拆箱，转换成基本数据类型，然后再进行运算（可能涉及者基本数据类型的自动类型提升）。（当然，如果是==运算，比较的是类对象的地址值，而不会进行拆箱）

## 包装类的其他API

### 数据类型的最大最小值

```java
Integer.MAX_VALUE和Integer.MIN_VALUE
    
Long.MAX_VALUE和Long.MIN_VALUE
    
Double.MAX_VALUE和Double.MIN_VALUE
```

### 字符转大小写

```
Character.toUpperCase('x');

Character.toLowerCase('X');
```

### 整数转进制

```java
Integer.toBinaryString(int i) 
    
Integer.toHexString(int i)
    
Integer.toOctalString(int i)
```

### 比较的方法

```java
Double.compare(double d1, double d2)
    
Integer.compare(int x, int y)
```

## 包装类的不可变性

Integer等包装类对象是“不可变”对象，即一旦修改，实际上就是创建了一个新对象，而不是在原有对象的基础上进行修改。类似于String类型。

案例：

```java
public class TestExam {
	public static void main(String[] args) {
		int i = 1;
		Integer j = new Integer(2);
		Circle c = new Circle();
		change(i,j,c);
		System.out.println("i = " + i);//1
		System.out.println("j = " + j);//2
		System.out.println("c.radius = " + c.radius);//10.0
	}
	
	public static void change(int a ,Integer b,Circle c ){
		a += 10;
//		b += 10;//等价于  b = new Integer(b+10);
		c.radius += 10;
		/*c = new Circle();
		c.radius+=10;*/
	}
}
class Circle{
	double radius;
}
```

