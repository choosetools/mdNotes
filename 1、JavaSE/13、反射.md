[TOC]



# 反射的概念

## 反射出现的背景

Java程序中，所有的对象都有两种类型：`编译时类型`和`运行时类型`，而很多时候对象的编译时类型和运行时类型**不一致**。例如：Object obj = new String("hello");

例如：某些变量或形参的声明类型是Object类型，但是程序却需要调用该对象运行时类型的方法，该方法不是Object中的方法，那么如何解决呢？

解决这个问题，有两种方案：

方案一：在编译和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先试用instanceof运算符进行判断，再利用强转类型转换符将其转换成运行时类型的变量即可。

方案二：编译时根本无法预知该对象和类的真实信息，程序只能依靠`运行时信息`来发现该对象和类的真实信息，这就必须使用反射。



## 反射概述

Reflection（反射）是被视为`动态语言`的关键，反射机制允许程序在`运行期间`借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。`这个对象就像是一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射`。

总而言之，当我们想在运行的时候去获取对象所属类的信息时，就可以使用到反射。

<img src=".\images\image-20220417161529285.png" alt="image-20220417161529285" style="zoom:80%;" />

**从内存加载上看反射**：

![image-20220524101448625](.\images\image-20220524101448625.png)

**使用案例：**

创建一个Person类：

```java
@Data
public class Person {
    private String name;
    public int age;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    public Person() {
    }

    public void show(){
        System.out.println("你好，我是一个Person");
    }
    
    private Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    private String showNation(String nation){
        return nation;
    }
}
```

我们使用之前的方式使用类：

```java
@Test
public void test1(){
    //1、创建Person类的实例
    Person p1 = new Person();

    //2、调用属性
    p1.age = 10;
    System.out.println(p1.age);

    //3、调用方法
    p1.show();
}
```

对于上述的操作，使用反射实现：

```java
@Test
public void test2() throws Exception {
    //1、创建Person类的对象
    //使用newInstance()方法创建对象在JDK9之后不建议使用（被划了一条横线）
    Class<Person> clazz = Person.class;
    //在调用newInstance()方法时，实际上也是去调用构造器
    Person person = clazz.newInstance();

    //2、调用属性
    //比如要去调用age属性，那么我就需要去获取叫age名字的属性
    Field ageField = clazz.getField("age");
    ageField.set(person, 10);
    System.out.println(ageField.get(person));

    //3、调用方法show()
    //先去类中获取叫show的方法，因为show()方法可能有多个（重载）
    //所以还需要形参列表表示调用的是重载方法中的哪一个
    Method showMethod = clazz.getMethod("show");
    //调用方法，还需要传入实参
    showMethod.invoke(person);
}
```

我们使用之前的方式，无法在类外去调用类中的私有结构。

但是**我们可以使用反射，调用类中`私有`的结构**。

案例：

以下所有的构造器、属性和方法都是私有的

```java
@Test
public void test() throws Exception {
    Class<Person> clazz = Person.class;
    //1、调用私有构造器，创建Person的实例
    //注意，这里不能使用newInstance()，因为newInstance()方法的意思是调用空参的构造器
    //使用getDeclaredConstructor()方法可以去获取构造器Constructor对象，因为构造器可能重载，所以要传入形参指定哪一个构造器
    //Declared的意思是已声明的
    Constructor<Person> constructor = clazz.getDeclaredConstructor(String.class, int.class);
    
    //如果当前类无法访问到该构造器，则需要设置setAccessible为true，这样就可以访问到了
    constructor.setAccessible(true);
    
    //然后再使用Constructor的newInstance()方法创建对象实例，传入的是构造器的实参
    Person person = constructor.newInstance("cheng", 24);
    System.out.println(person);
    
    

    //2、调用私有的属性name
    Field nameField = clazz.getDeclaredField("name");
    nameField.setAccessible(true);
    nameField.set(person, "jia");
    System.out.println(nameField.get(person));
    
    

    //3、调用私有的方法
    Method showNation = clazz.getDeclaredMethod("showNation", String.class);
    showNation.setAccessible(true);
    Object object = showNation.invoke(person, "helloJava");
    System.out.println(object);
}
```

**通过使用反射前后的例子对比，有几个问题：**

1. 面向对象中创建对象，调用指定结构（属性、方法）等功能，可以不使用反射，也可以使用反射。请问有什么区别？

   答：不使用反射，我们需要考虑封装性。比如：出了Person类之后，就不能调用Person类中私有的结构；使用反射，我们可以调用运行时类中任意的构造器、属性、方法。包括了私有的属性、方法和构造器。

2. 以前创建对象并调用方法的方式，与现在通过反射创建对象并调用方法的方式对比的话，哪种用的多？

   答：从我们作为程序员开发者的角度来讲，我们开发中主要是完成业务代码，对于相关的对象、方法的调用都是确定的。所以，我们使用非反射创建的方式多一些。

   因为反射体现了动态性（可以在运行时动态地获取对象所属的类，动态地调用相关的方法），所以在设计框架的时候，会大量的使用反射。意味着，如果需要学习框架源码，就需要学习反射。

   框架 = 注解 + 反射 + 设计模式

3. 单例模式中，私有化类的构造器了。此时，可以通过反射区创建单例模式类的多个对象吗？

   答：是的。

4. 通过反射，可以调用类中私有的结构，是否与面向对象的封装性有冲突？是不是Java语言设计存在BUG？

   不存在BUG。

   封装性，体现的是是否建议我们调用内部api的问题。比如：private声明的结构，意味着不建议调用。

   反射，体现的是我们能否调用的问题。因为类的完整结构都加载到了内存中，所以我就有能力进行调用。





## Java反射机制研究及应用

Java反射机制提供的功能：

* 在运行时判断任意一个对象所属的类
* 在运行时构造任意一个类的对象
* 在运行时判断任意一个类所具有的成员变量和方法
* 在运行时获取泛型信息
* 在运行时调用一个对象的成员变量和方法
* 在运行时处理注解
* 生产动态代理



## 反射相关的主要API

* **`java.lang.Class`**：代表一个类

* **`java.lang.reflect.Method`**：代表类的方法

* **`java.lang.reflect.Field`**：代表类的成员变量

* **`java.lang.reflect.Constructor`**：代表类的构造器

  ......

## 反射的优缺点

**优点**：

* 提高了Java程序的灵活性和扩展性，`降低了耦合性`，提高了`自适应能力`
* 允许程序创建和控制任何类的对象，无需提前`硬编码`目标类

**缺点**

* 反射的`性能较低`。
  * 反射机制主要应用在堆灵活性和扩展性要求很高的系统框架上
* 反射会`模糊`程序内部逻辑，`可读性较差`。





# 理解Class类并获取Class实例

## 1、从类的加载上理解Class类

当我们去运行Java程序时，会针对编写好的`.java`源文件进行编译（使用`javac.exe`），生成一个或多个`.class`字节码文件。接着，我们使用`java.exe`命令对指定的`.class`文件进行解释运行。这个解释运行的过程中，我们需要将`.class`字节码文件加载（使用类的加载器）到内存中（存放在方法区）。加载到内存中的`.class`文件对应的结构即为`Class`的一个实例。

比如：加载到内存中的Person类或String类或User类，都作为Class的一个一个的实例

Class clazz1 = Person.class;//运行时类

Class clazz2 = Animal.class;



在Object类中定义了以下的方法，此方法将被所有子类继承：

```java
public final Class getClass();
```

以上的方法返回的类型是一个Class类。**`Class类是描述类的类`**。此类是Java反射的源头，实际上所有反射从程序的运行结果来看很好理解：即：`可以通过对象反射获取类`。

<img src=".\images\image-20220417162559217.png" alt="image-20220417162559217" style="zoom:80%;" />

对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定结构的有关信息。

* Class本身也是一个类
* Class对象只能由系统建立对象
* 一个加载的类在JVM中只有一个Class实例
* 一个Class对象对应的是一个记载到JVM中的一个.class文件
* 每个类的实例都会记得自己是由哪个Class实例所生成
* 通过Class可以完整地得到一个类中的所有被加载的结构
* Class类是Reflection的根源，针对任何你想加载、运行的类，唯有先获得相应的Class对象。



## 2、获取Class实例的方式（要求掌握前三种）

* **方式一：`调用运行时类的静态属性class。`**

```java
Class<Person> clazz1 = Person.class;
```

* **方式二：`调用运行时类对象的getClass()方法。`**

```java
Person p1 = new Person();
Class<? extends Person> clazz2 = p1.getClass();
```

* **方式三：`调用Class类中的静态方法forName(String className)`（推荐使用）**

  其中，传入className是类的全类名（包括类所在的包）

```java
Class<?> clazz3 = Class.forName("org.example.Person");
```

* 方式四：使用类的加载器的方式

```java
Class<?> clazz4 = ClassLoader.getSystemClassLoader().loadClass("org.example.Person");
```

在实际开发中，我们最常使用的是第三种方式创建Class实例，因为第三种是根据传入的类全名创建的，更能体现动态性。



**说明：**运行时类在内存中会缓存起来，在整个运行期间，只会加载一次。所以，**无论是使用何种方式去获取类对应的`Class`实例，都是同一个**。

代码案例：

```java
@Test
public void test1() throws ClassNotFoundException {
    //1、调用运行时类的静态属性：class
    Class<Person> clazz1 = Person.class;

    //2、调用运行时类对象的getClass()方法
    Person person = new Person();
    //这个意思是这个泛型可以接收泛型类是Person类及Person类的子类
    Class<? extends Person> clazz2 = person.getClass();

    //返回true，那么实际上获取到的是同一个Class对象
    //因为类只会加载一次，所以类对应的Class对象永远只有一个
    System.out.println(clazz1 == clazz2);//true

    //3、调用Class的静态方法forName(String className)
    //传入的className是类的名称，要包含类的路径，即类的全类名
    //接收使用的是<?>泛型进行接收，该泛型对象表示可以接收任何类型的泛型对象
    Class<?> clazz3 = Class.forName("org.example.Person");
    System.out.println(clazz3 == clazz2);//true

    //4、使用类的加载器的方式
    Class<?> clazz4 = ClassLoader.getSystemClassLoader().loadClass("org.example.Person");
    System.out.println(clazz4 == clazz1);
}
```

打印结果：

<img src=".\images\image-20240127195727991.png" align="left">



## 3、哪些类可以有Class对象

简而言之，所有Java类型！

包括：

* class：外部类，成员内部类，静态内部类，局部内部类，匿名内部类

* interface：接口

* []：数组

* enum：枚举

* annotation：注解

* primitive type：基本数据类型

* void

举例：

```java
Class c1 = Object.class;
Class c2 = Comparable.class;
Class c3 = String[].class;
Class c4 = int[][].class;
Class c5 = ElementType.class;
Class c6 = Override.class;
Class c7 = int.class;
Class c8 = void.class;
Class c9 = Class.class;

int[] a = new int[10];
int[] b = new int[100];
Class c10 = a.getClass();
Class c11 = b.getClass();
// 只要元素类型与维度一样，就是同一个Class
System.out.println(c10 == c11);
```

有这么多种创建Class实例的方式，以及这么多类型可以去创建Class实例，那么怎样认为他们创建的Class实例是同一个呢？

> **`只要元素类型与维度是一样的，就是同一个Class`**。

比如：

int[] a = new int[10];

int[] b = new int[100];

int[][\] c = new int[10\][\];

其中，根据a和b获取到的Class实例就是同一个，a和c获取到的Class实例则不是同一个，因为a和b的元素类型（int类型数组）和维度（一维）都是一样的，不管二者是否大小一致，都是获取同一个Class实例。



# 类的加载过程与ClassLoader类的加载器

## 1、类的生命周期

类在内存中完整的生命周期：加载 → 使用 → 卸载。其中，加载过程又分为：`装载`、`链接`、`初始化`三个阶段。

![image-20220417173459849](.\images\image-20220417173459849.png)

## 2、类的加载过程

当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过`装载`、`链接`、`初始化`三个步骤来对类进行初始化。如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。

<img src=".\images\image-20220417171411631.png" alt="image-20220417171411631" style="zoom: 50%;" />

类的加载分为三个阶段：

1. **`装载（Loading)`**

   将类的`class`文件读入到内存中，并为之创建一个`java.lang.Class`对象。此过程由类加载器完成。

2. **`链接（Linking）`**

* `验证Verify`：确保加载的类信息符合JVM规范。例如：以cafebabe开头，没有安全方面的问题。
* `准备Prepare`：正式为类的静态**变量分配内存**并**设置静态变量默认初始值**的阶段，这些内存都将在方法区中进行分配。
* `解析Resolve`：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。

3. **`初始化（Initialization）`**

* 执行类构造器`<clinit>()`方法的过程。类构造器`<clinit>()`方法是由**编译期自动收集类中所有静态变量的赋值动作和静态代码块中的语句合并产生的**。（类构造器是构造类信息的，不是构造该类对象的构造器）

* 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。

* 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确加锁和同步。

  只要类中包含静态变量的显式赋值或包含静态代码块，那么就会生成<clinit>()方法。

  ![image-20240127224940375](.\images\image-20240127224940375.png)

例如：

```java
public class Order{
	static int orderDesc = 1;
	
	static{
		orderDesc = 2;
	}
}
```

对于上类来说，静态变量orderDesc在链接阶段（Linking）的准备阶段（Prepare），会赋值一个默认初始值0.

然后在初始化阶段（Initialization）会将显式初始化以及静态代码中的初始化工作完成，即对于赋值1和赋值2在初始化阶段完成。



## 3、类加载器（ClassLoader）

<img src=".\images\image-20220417173647473.png" alt="image-20220417173647473" style="zoom: 50%;" />

### 3.1、类加载器的作用

将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。

即，作用就是：

> **`将类读入内存，并生成对应的Class对象`**

类缓存：标准的JavaSe类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。

<img src=".\images\image-20220417173616344.png" alt="image-20220417173616344" style="zoom: 50%;" />



### 3.2、类加载器的分类（JDK8为例）

JVM支持两种类型的类加载器，分别为`引导类加载器（Bootstrap ClassLoader）`和`自定义类加载器（User-Defined ClassLoader）`。

从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：

<img src=".\images\image-20220417173819953.png" alt="image-20220417173819953" style="zoom: 50%;" />

1. **`启动类加载器（又称为引导类加载器，Bootstrap ClassLoader）`**
   * 这个类加载器使用`C/C++`语言实现的，嵌套在JVM内部。获取它的对象时往往返回`null`。
   * 它用来加载**Java的核心类库**（`JAVA_HOME/jre/lib/rt.jar`或`sun.boot.class.path`路径下的内容）。用于提供JVM自身需要的类。
   * 并不继承自java.lang.ClassLoader，没有父加载器。
   * 处于安全考虑，Bootstrap启动类加载只加载包名为`java`、`javax`、`sun`等开头的类。
   * 加载扩展类加载器和应用程序类加载器，并指定为他们的父加载器。

以下的加载器都是Bootstrap ClassLoader的子加载器（但不是子类）。

2. **`扩展类加载器（Extension ClassLoader）`**
   * Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
   * 继承于`ClassLoader`类，**父加载器为启动类加载器**Bootstrap ClassLoader。
   * 负责加载从`java.ext.dirs`系统属性所指定的目录中的类库，或从JDK的安全目录的`jre/lib/ext`子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

![image-20220417174032702](.\images\image-20220417174032702.png)

3. **`应用程序类加载器（或称为系统类加载器，Application ClassLoader/System ClassLoader）`**
   * java语言编写，由sun.misc.Launcher$AppClassLoader实现
   * 继承于`ClassLoader`类，**父加载器为扩展类加载器ExtClassLoader**
   * 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，即**`用户自定义类默认使用的就是系统类加载器加载`**。
   * 应用程序中的类加载器默认是系统类加载器
   * 它是用户自定义类加载器的默认父加载器
   * 通过`ClassLoader`的**`getSystemClassLoader()`**方法可以获取到该类加载器。

**使用案例：**

```java
//获取系统类加载器
ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();
System.out.println(classLoader1);//sun.misc.Launcher$AppClassLoader@18b4aac2

ClassLoader classLoader2 = classLoader1.getParent();
System.out.println(classLoader2);//sun.misc.Launcher$ExtClassLoader@1f32e575

ClassLoader classLoader3 = classLoader2.getParent();
System.out.println(classLoader3);//null
```

系统类加载器，也叫作应用程序类加载器AppClassLoader，其父加载器是扩展类加载器`ExtClassLoader`。扩展类加载器的父加载器是启动类加载器`Bootstrap ClassLoader`，由于启动类加载器使用的是`C/C++`来实现的，所以获取其对象返回的结果是`null`。

**注意：**

> 上述加载器对象调用的`getParent()`获取到的是当前加载器的**父加载器**，而不是**父类**。上述加载器之间并没有子父类的关系。

从类的继承关系来说，扩展类加载器其实和系统类加载器之间是兄弟类关系：

![image-20240128125948607](.\images\image-20240128125948607.png)

但是扩展类加载器实际上是系统类加载器的`父加载器`，内部类似于这种结构：

```java
class ClassLoader {
	ClassLoader parent;
	
	public ClassLoader(ClassLoader parent){
		this.parent = parent;
	}
}
//在创建系统类加载器时，将扩展类加载器作为构造器的参数传入：
ClassLoader systemClassLoader = new ClassLoader(extClassLoader);
```

为什么要将它们设置成这样的结构，让别人误以为它们之间是继承关系呢？

这里涉及到一个机制：**`双亲委派机制`**

这里就不做过多解释了。



测试案例：用户自定义的类使用的是何种类加载器

```java
@Test
public void test2() throws ClassNotFoundException {
    Class<Person> clazz1 = Person.class;
    ClassLoader classLoader1 = clazz1.getClassLoader();
    System.out.println(classLoader1);

    Class<?> clazz2 = Class.forName("java.lang.String");
    ClassLoader classLoader2 = clazz2.getClassLoader();
    System.out.println(classLoader2);
}
```

打印结果：

<img src=".\images\image-20240128114505234.png" align="left">

由上述打印结果可知：

当我们自定义类的Class对象去获取类加载器时，获取到的类加载器是系统类加载器；当我们使用系统类String的Class对象获取类加载器时，返回的是null。

由此，我们可以得到：

> **`用户自定义的类，使用的是系统类加载器加载；`**
>
> **`Java类库中的类，使用的是启动类加载器加载。`**



4. **用户自定义类加载器（了解）**

   * 在Java的日常应用程序开发中，类的加载几乎是由上述三种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。
   * 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。
   * 同时，自定义加载器能够实现`应用隔离`，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。
   * 自定义加载器还能实现`数据的加密`。
   * 自定义类加载器通常需要继承于`ClassLoader`。

   一个运行时类只加载一次，这是相对于同一个类加载器而言的；当我们有多个类加载器，就可以对同一个类多次进行加载。

   这也就是为什么要自定义加载器的原因。为什么要多次加载同一个类呢？因为类可能有多种版本。当我们去更新数据的时候，可能需要获取两次不同的版本，就需要去加载同一个类两次，这就需要用到自定义加载器。



### 3.3、查看某个类的类加载器

**（1）获取默认的系统类加载器**

```java
ClassLoader classLoader = ClassLoader.getSystemClassLoader
```

**（2）查看某个类是由哪种类加载器加载的**

```java
//先获取类的Class对象，再调用Class对象的getClassLoader()方法获取加载该类的类加载器
ClassLoader classLoader = Class.forName("exer2.ClassLoaderDemo").getClassLoader();

//如果是启动类加载器加载的类，则会得到null，启动类加载器加载Java核心类库
ClassLoader classLoader1 = Class.forName("java.lang.Object").getClassLoader();
```

**（3）获取某个类加载器的父加载器**

```java
//调用加载器对象的getParent()方法
ClassLoader parentClassLoader = classLoader.getParent();
```



### 3.4、加载器的应用：使用ClassLoader获取流

关于类加载器的一个主要方法：**`getResourceAsStream(String str)`**，获取类路径下的指定文件的输入流。

```
InputStream is = this.getClass().getClassLoader.getResourceAsStream("exer2\\test.properties");
```

**`该方法可以用来获取配置文件的数据。`**

举例：使用ClassLoader获取配置文件的数据

配置文件的信息：

<img src=".\images\image-20240128142500496.png" align="left">

使用原本的文件IO流的方式获取配置文件数据的方式：

```java
@Test
public void test4() throws IOException {
    Properties properties = new Properties();
    //下面是使用IO流的方式获取配置文件的方法
    FileInputStream fis = new FileInputStream(new File("info.properties"));

    properties.load(fis);

    String nameValue = properties.getProperty("name");
    String pwdValue = properties.getProperty("password");
    System.out.println(nameValue + ":" + pwdValue);
}
```

打印结果：

<img src=".\images\image-20240128142519710.png" align="left">

**使用加载器获取配置文件数据的方式：**

```java
@Test
public void test5() throws IOException {
    Properties properties = new Properties();
    //下面是使用ClassLoader的方式获取配置文件的方法
    InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("info1.properties");
    properties.load(is);
    String nameValue = properties.getProperty("name");
    String pwdValue = properties.getProperty("password");
    System.out.println(nameValue + ":" + pwdValue);
}
```

打印结果：

<img src=".\images\image-20240128142840437.png" align="left">

**注意**：**`这里的配置文件需要存放在当前module下的src目录下。`**

因为getResourceAsStream()方法默认的相对路径是在当前module下的src目录下（但是我经过实际的测试，配置文件需要放在当前module下的target目录下的classes目录，可能是配置的问题）

![image-20240128142830768](.\images\image-20240128142830768.png)







# 反射的应用

有了Class对象，能做什么呢？

下面，根据自定义类Person，去获取该类的信息：

```java
public class Person extends Creature<String> implements Comparable<Person>, MyInterface{
    private int age;
    private String name;

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Person() {
    }

    @Override
    public int compareTo(Person o) {
        return 0;
    }

    @Override
    public void method() {

    }
}
```





## 1、应用一：创建运行时类的对象（重要）

这是反射机制应用最多的地方，创建运行时类的对象有两种方式：

### 方式一：直接调用Class对象的newInstance()方法（不推荐）

Class类中的newInstance()方法：

```java
@Deprecated(since="9")
public T newInstance()
    throws InstantiationException, IllegalAccessException
```

**使用步骤：**

1）获取该类型的`Class`对象

2）调用`Class`对象的`newInstance()`方法创建对象

**注意：**

使用该方式，通过Class对象创建运行时类对象时，要求：

> 1. **`运行时类中必须有一个无参的构造器，`**
> 2.  **`当前位置的访问权限足够。`**

因为实际上，Class对象调用`newInstance()`方法**实际上就是去调用类中的`空参构造器`创建**的。



代码案例：

```
Class<Person> clazz = Person.class;
//创建Person类的实例
Person p1 = clazz.newInstance();
System.out.println(p1);
```

打印结果：

<img src=".\images\image-20240129104734084.png" align="left" style="zoom:50%;" >



**该方法会抛出两个异常：**

`InstantiationException`和`IllegalAccessException`。

这两个异常分别代表着调用该方法时，类不满足相应条件的情况。

* 当运行时类中**不包含空参构造器**时，会报`InstantiationException`

* 当前调用位置**没有访问该构造器的权限**时，会报`IllegalAccessException`

该方法在JDK9之后就已经过时了，替换成了通过Constructor类调用newInstance()方法创建运行时类对象。



---



### 方式二：通过获取构造器对象来进行实例化（推荐）



> **使用步骤**：
>
> * 1、获取该类型的`Class`对象。
> * 2、通过Class对象的`getDeclaredConstructor(Class... parameterTypes)`取得本类的指定形参类型的构造器
> * 3、向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数所对应的Class类型的实例。
> * 4、调用`Constructor`对象的`newInstance()`方法实例化运行时类对象，向`newInstance()`方法中传入使用构造器创建对象时所需的实参数据。



> 若当前位置没有访问运行时类构造器的权限，可以调用Constructor对象的**`setAccessible(true)`**方法，获取权限。



* **代码案例：**

在Person类中有一个private权限的构造器：

```java
private Person(String name, int age) {
    this.name = name;
    this.age = age;
}
```

如果我们要使用该构造器通过反射的方式创建运行时类对象，该怎么做呢？以下是实现代码

```java
@Test
public void test6() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
    //1、创建类的Class对象
    Class<Person> clazz = Person.class;
    
    
    //2、通过调用Class类中的getDeclaredConstructor()方法，创建Constructor对象
    //该方法中传入要使用的构造器形参列表所对应的Class对象
    Constructor<Person> constructor = clazz.getDeclaredConstructor(String.class, int.class);
    

    //3、由于该构造器是private类型，当前位置没有权限访问，所以需要调用Constructor的setAccessible(true)获取权限
    constructor.setAccessible(true);
    

    //4、调用Constructor类的newInstance()方法，表示使用该构造器创建运行时类对象
    //传入的参数即为使用该构造器创建对象所需的实参
    Person person = constructor.newInstance("cheng", 24);


    System.out.println(person);
}
```

打印结果：

<img src=".\images\image-20240129163954565.png" align="left">





### 回忆：JavaBean中要求给当前类提供一个公共的空参构造器。有什么用？

**场景一：**子类对象在实例化时，子类的构造器的首行默认调用父类空参的构造器。

**场景二：**在反射中，经常用来创建运行时类的对象，那么我们要求各个运行时类都提供一个空参的构造器，便于我们编写运行时类对象的代码。

这个时候，我们使用的是Class对象的`newInstance()`方法创建运行时类对象。（但是不推荐这样创建运行时类对象，推荐先通过Class对象创建Constructor类对象，再去创建运行时类对象）



## 2、应用二：获取运行时类的内部结构

可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）以及注解（类上的、方法上的、属性上的）。

### 2.1、相关API

以下的API不完整，详情请查看具体举例。

> * `public Class<?>[] getInterfaces()`：获取运行时类实现的**全部接口**。
>
> * `public Class<? super T> getSuperClass()`：获取运行时类所**继承的父类**



> * `public Constructor<T>[] getConstructors()`：返回此Class对象所表示的类的**所有public的构造方法**。
> * `public Constructor<T>[] getDeclaredConstructors()`：返回此Class对象表示的类声明的**所有构造方法**。
> * **Constructor类中常用的三个方法**：
>   * `public int getModifiers()`：获取构造器的修饰符
>   * `public String getName()`：获取的构造器的名称（返回的是全类名）
>   * `public Class<?>[] getParameterTypes()`：获取构造器的参数类型
>



> * `public Method[] getDeclaredMethods()`：返回此Class对象所表示的类或接口的**全部方法**
>* `public Method[] getMethods()`：返回此Class对象所表示的类或接口及其所有父类/实现接口中的**所有public的方法**，不包括抽象方法。若对父类/接口中的方法进行了重写，则两个方法都会获取。
> * **Method类中常用的四个方法：**
>  * `public Class<?> getReturnType()`：获取返回值的类型
>   * `public Class<?>[] getParameterTypes()`：获取全部的参数类型
>  * `public int getModifiers()`：获取方法的修饰符类型
>   * `public Class<?>[] getExceptionTypes()`：获取方法抛出的所有异常类型



> * `public Field[] getFields()`：返回此Class对象所表示的类或接口及其父类/父接口中**所有的public属性**，包括static类型的。
> * `public Field[] getDeclaredFields()`：返回此Class对象表示的类或接口的**全部属性**，包括static类型。
> * **Field类中，常用的三个方法：**
>   * `public int getModifiers()`：获取属性的权限修饰符。
>   * `public String getName()`：获取属性的名称。
>   * `public Class<?> getType()`：获取属性的类型。
>



> * `getAnnotation(Class<T> annotationClass)`
> 
> * `getDeclaredAnnotations()`
> 
> * `getAnnotations()`
> 
>* 上述的三种方法均为获取类的注解信息。要想在反射中获取运行时类的注解信息，要求**注解的生命周期要设置成`RUNTIME`。**
> 
>* 注解的生命周期包括SOURCE、CLASS和RUNTIME。
> 
>* 例如：
> 
>  @Retention(RetentionPolicy.RUNTIME)
> 
>  public @interface MyAnnotation{}
> 



> * `Type getGenericSuperClass()`：获取当前类**带泛型的父类**，例如：com.atguigu.java1.Creature<java.lang.String>
> * 若我们去获取带泛型的类型的泛型类型，需要将**Type类型强转为ParameterizedType类型**，然后调用该类型的`getActualTypeArguments()`方法获取实际的泛型类型参数数组。
> 



> * `Package getPackage()`：获取类所在的包



### 2.2、细节问题：

#### Class类中含Declared的方法与不含Declared的方法比较：

Class类型中，对于获取运行时类属性、方法以及构造器的方法中，都包含两种：一个是不含Declared的，一种是包含Declared。

**不含`Declared`的方法**，指的是获取**运行时类及其父类/父接口**中**`public`权限修饰符**的属性、方法以及构造器，包括静态的；

**含`Declared`的方法**，指的是获取**运行时类**中**所有权限修饰符**的属性、方法以及构造器，包括静态的。

当我们使用包含Declared的方法获取到属性、方法或构造器时，要去访问，此时若当前位置原本是没有权限的，需要使用到**`setAccessible(true)`**方法。



#### 对getModifiers()获取数据的权限修饰符方法解释：

在Constructor、Method以及Field类中，都包含一个`getModifiers()`方法，该方法的作用是获取权限修饰符，返回的是一个int类型，我们可以使用Modifier.toString()方法，将该int类型转换成权限符的字符串类型返回。

案例：

```java
Class<Person> clazz = Person.class;
for (Field f : clazz.getDeclaredFields()) {
    //Field中的getModifiers()方法，用于获取属性的权限修饰符
    //返回的是一个int类型
    int modifiers = f.getModifiers();
    
    //使用Modifier中的toString()方法，可以将这个int类型转换成相应的权限字符串显示
    System.out.println(modifiers + ":" + Modifier.toString(modifiers));
}
```

打印结果：

<img src=".\images\image-20240129203519749.png" align="left">

上图告诉了我们一些信息，当getModifiers()返回0时，表示缺省；返回1时，表示public；返回2时，表示private；返回10时，表示private static。

**其他返回值所代表的权限修饰符：**

```
0x是十六进制
缺省             = 0x00000000;  0    
PUBLIC           = 0x00000001;  1    1
PRIVATE          = 0x00000002;  2	10
PROTECTED        = 0x00000004;  4	100
STATIC           = 0x00000008;  8	1000
FINAL            = 0x00000010;  16	10000
```

使用getModifiers()方法获取到的数值，实际上依据上述的情况，结合自身的权限，**相加所得**。

比如：设置了一个属性的权限修饰符为`public static final`，那么使用getModifiers()获取到的值就是 1 + 8 + 16 = `25`。



### 2.3、实现案例（可以直接看案例）

#### 获取类中的所有属性及相关细节

```java
public class FieldTest{
	@Test
    public void test1(){
        Class clazz = Person.class;
        //getFields()：获取到运行时类本身及其所有的父类/父接口中声明为public权限的属性
        Field[] fields = clazz.getFields();
        for(Field f : fields){
            System.out.println(f);
        }
        
        //getDeclaredFields()：获取当前运行时类中声明的所有属性
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
            System.out.println(f);
        }
    }
    
    @Test
    public void test2(){
        Class clazz = Person.class;
        Field[] declaredFields = clazz.getDeclaredFields();
        for(Field f : declaredFields){
			//获取权限修饰符
            int modifier = f.getModifiers();
            System.out.println(Modifier.toString(modifier));
            
            //数据类型
            Class type = f.getType();
            System.out.println(type.getName());
            
            //变量名
            String fName = f.getName();
            System.out.println(fName);
        }
    }
}
```

#### 获取所有的方法及相关细节

```java
public class MethodTest {
	@Test
    public void test1(){
        Class clazz = Person.class;
        //getMethods()：获取到运行时类本身及其所有父类/接口中所有声明为public权限的方法
        Method[] methods = clazz.getMethods();
        for(Method m : methods){
            System.out.println(m);
        }
        
        //getDeclaredMethods()：获取当前运行时类中声明的所有方法
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for(Method m : declaredMethods) {
            System.out.println(m);
        }
    }
    
    
    //获取类中方法的所有信息，打印结果类似于下面：
    //注解信息
    //权限修饰符 返回值类型 方法名(参数类型1 参数1, 形参类型2 参数2,...) throws 异常类型...{}
	@Test
	public void test2() {
		Class clazz = Person.class;
		Method[] declaredMethods = clazz.getDeclaredMethods();
		for (Method m : declaredMethods) {
			// 1.获取方法声明的注解
			Annotation[] annos = m.getAnnotations();
			for (Annotation a : annos) {
				System.out.println(a);
			}

			// 2.权限修饰符
			System.out.print(Modifier.toString(m.getModifiers()) + " ");

			// 3.返回值类型
			System.out.print(m.getReturnType().getName() + " ");

			// 4.方法名
			System.out.print(m.getName());
			System.out.print("(");
			// 5.形参列表
			Class[] parameterTypes = m.getParameterTypes();
			if (!(parameterTypes == null && parameterTypes.length == 0)) {
				for (int i = 0; i < parameterTypes.length; i++) {

					if (i == parameterTypes.length - 1) {
						System.out.print(parameterTypes[i].getName() + " args_" + i);
						break;
					}

					System.out.print(parameterTypes[i].getName() + " args_" + i + ",");
				}
			}

			System.out.print(")");

			// 6.抛出的异常
			Class[] exceptionTypes = m.getExceptionTypes();
			if (exceptionTypes.length > 0) {
				System.out.print("throws ");
				for (int i = 0; i < exceptionTypes.length; i++) {
					if (i == exceptionTypes.length - 1) {
						System.out.print(exceptionTypes[i].getName());
						break;
					}
					System.out.print(exceptionTypes[i].getName() + ",");
				}
			}
			System.out.println();
		}
	}
}
```

单元测试test2()中，对Person类的打印结果案例为：

![image-20240129220950045](.\images\image-20240129220950045.png)



#### 获取其他结构（构造器、父类、接口、包、注解等）

```java
public class OtherTest {
	/*
		获取当前类中的所有构造器
	*/
    @Test
    public void test1(){
        Class clazz = Person.class;
        Constructor[] cons = clazz.getDeclaredConstructors();
        for(Constructor c : cons){
            System.out.println(c);
        }
    }
    
    
    /*
    	获取运行时类的父类
    */
    @Test
    public void test2(){
        Class clazz = Person.class;
        Class superclass = clazz.getSuperclass();
        System.out.println(superclass);
    }
    
    
    /*
    	获取运行时类所在的包
    */
    @Test
    public void test3(){
        Class clazz = Person.class;
        Package pack = clazz.getPackage();
        System.out.println(pack);
    }
    
    
    /*
    	获取运行时类的注解
    */
    @Test
    public void test4(){
        Class clazz = Person.class;
        Annotation[] annos = clazz.getAnnotations();
        for(Annotation anno : annos) {
            System.out.println(anno);
        }
    }
    
     /*
    	获取运行时类所实现的接口
     */
    @Test
    public void test5(){
        Class clazz = Person.class;
        Class[] interfaces = clazz.getInterfaces();
        for (Class anInterface : interfaces) {

            System.out.println(anInterface);
        }
    }
    
    
     /*
    	获取运行时类的带泛型的父类
     */
    @Test
    public void test6(){
        Class clazz = Person.class;
        Type genericSuperclass = clazz.getGenericSuperclass();
        System.out.println(genericSuperclass);//com.atguigu.java1.Creature<java.lang.String>
    }
}
```

#### 获取泛型父类信息

示例代码去获取泛型父类信息：

以下的代码可以看做是固定的，我们在使用的时候直接套用就行

```
/* Type：
 * （1）Class
 * （2）ParameterizedType   
 * 		例如：Father<String,Integer>
 * 			ArrayList<String>
 * （3）TypeVariable
 * 		例如：T，U,E,K,V
 * （4）WildcardType
 * 		例如：
 * 		ArrayList<?>
 * 		ArrayList<? super 下限>
 * 		ArrayList<? extends 上限>
 * （5）GenericArrayType
 * 		例如：T[]
 * 	
 */
public class TestGeneric {
	public static void main(String[] args) {
		//需求：在运行时，获取Son类型的泛型父类的泛型实参<String,Integer>
		
		//（1）还是先获取Class对象
		Class clazz = Son.class;//四种形式任意一种都可以
		
		//（2）获取泛型父类
		Type type = clazz.getGenericSuperclass();
        
        
		// Father<String,Integer>属于ParameterizedType
        //这里若父类是带泛型的，则可以强转为ParameterizedType
		ParameterizedType pt = (ParameterizedType) type;
		
		//（3）获取泛型父类的泛型实参列表，因为可能有多个泛型，所以返回的是一个数组类型
		Type[] typeArray = pt.getActualTypeArguments();
		for (Type type2 : typeArray) {
			System.out.println(type2);
		}
	}
}

//泛型形参：<T,U>
class Father<T,U>{
	
}
//泛型实参：<String,Integer>
class Son extends Father<String,Integer>{
}
```



#### 获取内部类或外部类信息

public Class<?>[] getClasses()：返回所有公共内部类和内部接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。

public Class<?>[] getDeclaredClasses()：返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。

public Class<?> getDeclaringClass()：如果此 Class 对象所表示的类或接口是一个内部类或内部接口，则返回它的外部类或外部接口，否则返回null。

Class<?> getEnclosingClass() ：返回某个内部类的外部类

```java
	@Test
	public void test5(){
		Class<?> clazz = Map.class;
		Class<?>[] inners = clazz.getDeclaredClasses();
		for (Class<?> inner : inners) {
			System.out.println(inner);
		}
		
		Class<?> ec = Map.Entry.class;
		Class<?> outer = ec.getDeclaringClass();
		System.out.println(outer);
	}
```





## 3、应用三：调用运行时类的指定结构（重要）

### 3.1、调用指定属性

#### 相关API

**Class类中的API：**

* `public Field getField(String name)`：获取运行时类中指定的public类型属性。
* **`public Field getDeclaredField(String name)`**：获取运行时类中指定的属性。

getField()方法不具备通用性，只适用于权限修饰符为public类型的属性，所以，我们在实际开发中基本上都是使用`getDeclaredField()`方法来获取属性。



**Field类中的相关API：**

* **`public void setAccessible(boolean flag)`**：该方法用于设置访问的权限。默认参数为false，当我们没有权限访问到该属性时，需要传入true。
* **`public Object get(Object obj)`**：获取指定obj上的此Field属性。
* **`public void set(Object obj, Object value)`**：设置指定对象obj上此Field的属性内容。



#### 使用反射调用运行时类指定属性的步骤

若对于调用运行时类中**非静态的属性**。比如在下例中，age属性是private的，且非静态，则代码实现：

```java
@Test
public void test2() throws Exception {
    //1、创建运行时类的对象
    Class<Person> clazz = Person.class;
    Constructor<Person> constructor = clazz.getDeclaredConstructor();
    //确保构造器是可访问的
    constructor.setAccessible(true);
    Person person = constructor.newInstance();

    //2、调用Class对象的getDeclaredField()方法，创建指定属性
    Field ageField = clazz.getDeclaredField("age");

    //3、确保该属性可以访问到
    ageField.setAccessible(true);

    //4、调用运行时类的属性
    ageField.set(person, 20);
    System.out.println(ageField.get(person));
}
```



若想要调用运行时类中**静态的属性**，则需要进行修改：

Field类的`set()`与`get()`方法传入的是**运行时类的类类型（Class类型）**，而不是运行时类的对象了，因为静态属性只与类有关，与对象无关。

案例步骤代码实现如下：

```java
@Test
public void test3() throws Exception{
    //1、创建运行时类的Class类型对象
    Class<Person> clazz = Person.class;
    
    //2、调用Class对象的getDeclaredField()方法，创建指定属性
    Field timeField = clazz.getDeclaredField("time");

    //3、确保该属性可以访问到
    timeField.setAccessible(true);

    //4、调用运行时类的属性，传入的是运行时类的Class类型对象
    timeField.set(clazz, 123123L);
    System.out.println(timeField.get(clazz));
}
```







---

### 3.2、调用指定方法

<img src=".\images\image-20220417181700813.png" alt="image-20220417181700813" style="zoom:80%;" />

**调用过程代码案例：**

* **1）创建类的类对象以及运行时类对象**

```java
//创建运行时类的Class对象
Class<Person> clazz = Person.class;
Constructor<Person> constructor = clazz.getDeclaredConstructor();

//确保构造器是可访问的
constructor.setAccessible(true);
//创建运行时类对象
Person person = constructor.newInstance();
```



* **2）调用Class对象的getDeclaredMethod()方法创建方法的Method对象**

```java
//调用getDeclaredMethod()方法，获取指定方法的Method类型对象
//第一个参数传入的是方法的名称，由于方法可能会有重载，所以第二个参数传入方法形参的Class类型
Method showNationMethod = clazz.getDeclaredMethod("showNation", String.class);
```

* **3）确保该Method对象可以被访问**

```java
//确保此方法是可访问的
showNationMethod.setAccessible(true);
```

* **4）调用Method对象的invoke()方法，执行相应的方法**

```java
//调用invoke()方法执行运行时类的方法
// invoke()第一个参数传入的是运行时类的对象，后面的参数传入的是执行该方法的实参
//有返回值，则使用Object接收invoke()的返回值，若Method对应的方法的返回值类型为void，则invoke()返回值为null
Object object = showNationMethod.invoke(person, "nihao!");
System.out.println(object);
```



> 如果方法的权限修饰符修饰的范围不可见，也可以调用`setAccessible(true)`
>
> 如果方法是静态方法，使用运行时类的Class对象代替运行时类对象，此时就不需要创建运行时类的对象了





---

### 3.3、关于setAccessible方法的使用

* Method和Field、Constructor对象都有setAccessible()方法
* setAccessible启动和禁用访问安全检查的开关。
* 参数为true则指示反射的对象在使用时应该取消Java语言访问检查。
  * 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置成true。
  * 使得原本无法访问的私有成员也可以访问。
* 参数值为false则指示反射的对象应该实施Java语言访问检查。

## 4、应用四：读取注解信息

### 演示

**声明自定义注解：**

```java
@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
    String value();
}
```

```java
@Inherited
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    String columnName();
    String columnType();
}
```

* 自定义注解可以通过四个元注解@Retention，@Target，@Inherited，@Document分别说明它的生命周期，使用位置，是否被继承以及是否被生成到API文档中。
* 可以用default关键字为抽象方法指定默认返回值
* 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个默认方法需要赋值，且方法名为value，可以省略"value="，所以如果注解只有一个抽象方法成员，建议使用方法名value。



**在类中使用自定义注解**

```java
@Data
@Table("t_stu")
public class Student {
    @Column(columnName = "sid", columnType = "int")
    private int id;

    @Column(columnName = "sname", columnType = "varchar(20)")
    private String name;
}
```

**使用反射获取类中的注解信息**：

```java
@Test
public void test(){
    Class<Student> clazz = Student.class;
    //获取类上的注解信息
    Table tableAnnotation = clazz.getAnnotation(Table.class);
    if (tableAnnotation != null){
        System.out.println("类上的Table注解的value属性值为：" + tableAnnotation.value());
    }

    //获取所有属性的注解信息
    for (Field field : clazz.getDeclaredFields()) {
        Column columnAnnotation = field.getAnnotation(Column.class);
        if (columnAnnotation != null){
            System.out.println("属性" + field.getName() + "上的注解信息为：" + columnAnnotation.columnName() + "->" + columnAnnotation.columnType());
        }
    }
}
```

打印结果：

![image-20240130192530023](.\images\image-20240130192530023.png)







# 体会反射的动态性

**体会1：**

```java
public class ReflectionTest {

    //体会反射的动态性：动态的创建给定字符串对应的类的对象
    public <T> T getInstance(String className) throws Exception {

        Class clazz = Class.forName(className);

        Constructor constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true);
        return (T) constructor.newInstance();

    }

    @Test
    public void test1() throws Exception {
        String className = "com.atguigu.java1.Person";
        Person p1 = getInstance(className);
        System.out.println(p1);
    }
}
```

**体会2：**

```java
public class ReflectionTest {
    //体会反射的动态性：动态的创建指定字符串对应类的对象，并调用指定的方法
    public Object  invoke(String className,String methodName) throws Exception {
        Class clazz = Class.forName(className);
        Constructor constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true);
        //动态的创建指定字符串对应类的对象
        Object obj = constructor.newInstance();

        Method method = clazz.getDeclaredMethod(methodName);
        method.setAccessible(true);
        return method.invoke(obj);
    }

    @Test
    public void test2() throws Exception {
        String info = (String) invoke("com.atguigu.java1.Person", "show");

        System.out.println("返回值为：" + info);

    }
}
```

**体会3：**

```java
public class ReflectionTest {
	@Test
    public void test1() throws Exception {
        //1.加载配置文件，并获取指定的fruitName值
        Properties pros = new Properties();
        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("config.properties");
        pros.load(is);
        String fruitStr = pros.getProperty("fruitName");
        //2.创建指定全类名对应类的实例
        Class clazz = Class.forName(fruitStr);
        Constructor constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true);
        Fruit fruit = (Fruit) constructor.newInstance();
        //3. 调用相关方法，进行测试
        Juicer juicer = new Juicer();
        juicer.run(fruit);

    }

}

interface Fruit {
	public void squeeze();
}

class Apple implements Fruit {
	public void squeeze() {
		System.out.println("榨出一杯苹果汁儿");
	}
}

class Orange implements Fruit {
	public void squeeze() {
		System.out.println("榨出一杯桔子汁儿");
	}
}

class Juicer {
	public void run(Fruit f) {
		f.squeeze();
	}
}

```

其中，配置文件【config.properties】存放在当前Module的src下

```
com.atguigu.java1.Orange
```



