## 内存泄露与内存溢出的区别与联系，以及该如何解决

### 一、**什么是内存泄露与内存溢出？**

**内存泄露（memory leak）**：是指程序在申请内存后，无法释放已申请的内存空间，导致**系统无法及时回收内存并分配给其他进程使用**。通常少次数的内存无法及时回收并不会对程序造成什么影响，但是如果内存本身就比较少，并且内存多次无法正常回收时，就会导致内存不够用，最终导致内存溢出。

**内存溢出（out of memory）**：是指**程序申请内存的时候，没有足够的内存供申请者使用**，导致数据无法正常存储到内存中。也就是说当只有一个int类型的存储数据大小的空间时，但是却要去存储一个long类型的数据，这样就会导致内存溢出。

比如，当方法无限递归时，就会发生栈内存溢出，即栈空间全都被使用了，没有足够的空间供之后的方法使用，就会发生栈内存溢出。

### 二、**内存泄露和内存溢出的关系以及区别**

1.  **关系：**内存泄露最终会导致内存溢出，由于系统的内存是有限的，如果过度占用资源而不及时释放，最后会导致内存不足，从而无法给所需要存储的数据提供足够的内存，从而导致内存溢出。导致内存溢出的原因也可能是由于在给数据分配大小时没有根据实际要求进行分配，最后导致分配的内存无法满足数据的要求，从而导致内存溢出。
2.  **区别：**内存泄露是由于GC（垃圾回收机制）无法及时或者无法识别可以回收的数据进行及时的回收，导致内存的浪费；内存溢出是由于数据所需的内存无法得到满足，导致数据无法正常地存储到内存中。多次内存泄露会导致内存溢出。

### 三、**内存泄露发生的原因及解决方法**

1.  内存泄露也许是因为活动已经被使用完毕，但是在其他地方被引用，导致无法对其进行回收，我们只需要给对活动进行引用的类独立出来或者将其变为静态类，该类随着活动的结束而结束，也就没有了当活动结束但仍然被其他类引用的情况。
2.  资源性对象在不使用的时候，应该调用它的close()函数将其关闭。
3.  集合容器中的内存泄露，我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。需要在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。
4.  WebView造成的泄露，当我们不使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存，否则其长期占用的内存也不能被回收，从而造成内存泄露。我们应该为WebView另外开启一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。

### 四、**内存溢出的原因及解决方法：**

1. 内存溢出原因：

   1.  内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
   2.  集合类中又对对象的引用，使用完后未清空，产生了堆积，使得JVM不能回收。
   3.  代码中存在死循环或循环产生过多重复的对象实体。
   4.  使用第三方软件中的BUG。
   5.  启动参数内存值设定的过小。

2. 内存溢出的解决方案：

   第一步：修改JVM启动参数，直接增加内存。（-Xms，-Xmx参数一定不要忘记加。）

   第二步：检查错误日志，查看“OutOfMemory"错误钱是否有其他异常或错误。

   第三步：对代码进行走查和分析，找出发生内存溢出的位置。

---

## 标识符命名规范

* **`包名`**`：多单词组成时所有的字母都小写：xxxyyyzzz。`

  `例如：java.lang.com.bookname`

* **`类名、接口名`**`：多单词组成时，所有单词的首字母大写：XxxYyyZzz`

  `例如：HelloWorld，String，System`

* **`变量名、方法名`**`：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz`

  `例如：age，name，bookName，binarySearch`

* **`常量名`**`：所有字母都大写，多单词时每个单词使用下划线链接：XXX_YYY_ZZZ`

  `例如：MAX_VALUE，PI，DEFAULT_CAPACITY`

---

## 插件codeGeeX的使用

[爆肝 72小时，教你使用CodeGeex AI编程\_程序员caspar的博客-CSDN博客](https://blog.csdn.net/caspar_notes/article/details/132798074)

---

## 赋值运算符不会改变运算结果的数据类型

赋值运算符：

| 赋值运算符 |                           符号解释                           |
| :--------: | :----------------------------------------------------------: |
|    `+=`    | 将符号`左边的值`和`右边的值`进行`相加`操作，最后将结果`赋值给左边的变量` |
|    `-=`    | 将符号`左边的值`和`右边的值`进行`相减`操作，最后将结果`赋值给左边的变量` |
|    `*=`    | 将符号`左边的值`和`右边的值`进行`相乘`操作，最后将结果`赋值给左边的变量` |
|    `/=`    | 将符号`左边的值`和`右边的值`进行`相除`操作，最后将结果`赋值给左边的变量` |
|    `%=`    | 将符号`左边的值`和`右边的值`进行`取余`操作，最后将结果`赋值给左边的变量` |

这些赋值运算符与普通的运算有些不同：

普通的运算可能涉及到范围较小的基础变量存储范围较大的变量数值造成编译错误的问题；但赋值运算符不存在，相当于赋值运算符添加了一道强转。（与++ 、--运算符一样，不会改变数据的类型）

例如：

```java
byte b1 = 10;
b1 = b1 + 1;//此时会发生报错，因为1相当于int类型的数据，不能使用byte存储运算结果。

byte b2 = 10;
b2 += 1;//此时不会发生报错，因为赋值运算符不会改变数据的类型，你可以看成在上列式子的基础上增加了一个强转
```

**赋值运算符不会改变数据的类型**

---

## 二进制、十进制、八进制与十六进制详解

### **一、计算机底层如何存储二进制数？**

计算机底层使用**二进制补码**的形式进行存储的，最高位是符号位。

- 正数：最高位是0
- 负数：最高位是1

**规定**：

- 正数的原码、反码、补码相同，称为三码合一。
- 负数的补码与反码、原码不一样：

- - 负数的**原码**：把十进制转换成为二进制，然后最高位设置为1.
  - 负数的**反码**：在原码的基础上，最高位不变，其余位取反。
  - 负数的**补码**：在反码的基础上，最高位不变，反码+1。

比如：

使用byte来存储：-1

原码：1000 0001

反码：1111 1110

补码：1111 1111

再比如：

使用byte存储-128

原码：1000 0000

反码：1111 1111

补码：1000 0000，因为byte只有8位bit，所以当1111 1111 + 1多出来的一位就会被舍去。

案例：

```java
int i1 = 128; 

byte b1 = (byte) i1; 

System.out.println(b1);
```

输出结果：

-128

结果是-128的原因就很容易知道了，原因就是：强制类型转换，是直接截取对应字节的值到另一个变量中的，而int类型的128在计算机底层存储占有4个字节，最后几位的存储是1000 0000，强转给byte后，会直接截取后8位bit数据，最高位为符号位，所以保留下来的数据转换成十进制就是-128。

### 二、二进制、十进制、八进制与十六进制之间的转换

![](.\images\截图1.png "二进制转十进制")

![](.\images\截图2.png)

![](.\images\截图3.png)

![](.\images\截图4.png)

![](.\images\截图5.png)

![](.\images\截图6.png)

![](.\images\截图7.png)

![](.\images\截图8.png)

---

## 关于浮点型数据精度以及产生误差的说明

- 并不是所有小数都可以精确的使用二进制浮点数表示，**二进制浮点数不能精确的表示0.1、0.01、0.001这样10的负次幂**。
- float、double的精确度很差，如果需要**精确数字计算**或者**保留指定位数**的精度，需要使用**BigDecimal**类。

例如：

```
//测试1：（解释见章末企业真题：为什么0.1 + 0.2不等于0.3）
System.out.println(0.1 + 0.2);//0.30000000000000004

//测试2：
float ff1 = 123123123f;
float ff2 = ff1 + 1;
System.out.println(ff1);//1.2312312E8
System.out.println(ff2);//1.2312312E8
System.out.println(ff1 == ff2);//true
```

以上出现这些问题的原因都在于浮点数的精度较差，无法精确地表示数字。

### 问题：为什么Java有时候可以精确地表示浮点数，有时不能？

比如：在Java中设置double = 0.1，然后打印出来，仍然是0.1.但是按照2进制浮点数的表示法，是无法精确表示0.1的只能精确表示类似0.5,0.25这样的数，再比如0.4 / 4 = 0.1，而0.4 - 0.3 = 0.10000000000000003。为什么Java有时可以精确表示0.1，有时又无法精确表示？

**解释：**

1、在声明double = 0.1时，其实理论上并不能这么声明，因为浮点数中没有0.1，但是编译器总不能这样就报错吧，于是编译器将0.1转换为了最接近0.1的一个浮点数。

2、在打印Java小数的时候，我们可以发现一个现象，那就是打印出来的小数精度都是一样的，都是16位数，例如：

```
public static void main(String[] args) {
    System.out.println(1d / 1212311);
    System.out.println(2d / 3322);
    System.out.println(3d / 3123);
}
```

输出：

```
8.248708458473115E-7
6.020469596628537E-4
9.606147934678194E-4
```

至于为什么是16位，我猜测有两个原因：

1. 1.

   总有一个精度来对应除不尽的情况。

2. 2.

   因为16为精度的十进制刚好可以区分双精度的浮点数，双精度浮点数的尾数是52为，2的52次方也是16位，这样就可以避免大小不同的浮点数打印出来一样的值。

然后解释为什么会出现0.4 / 4 = 0.1，0.4 - 0.3 = 0.1000...003的情况：

因为在将其转换为字符串的过程中，Java耍了点小聪明。它会将看起来疑似是“整”的浮点数进行特殊处理，转换为“整”的十进制小数形式。Java只会打印出来16位精度的数，它会打印出最接近该浮点数的16为精度的10进制数。

比如0.1，如果内部表示直接转换过来可能是0.1000000...0111，这种情况下，最后两位的数值太小，Java就会认为是精度不够导致的，于是转成字符串的时候会将其转为0.1。

而0.4 / 4以及 0.4 - 0.3也是同样的道理，可能0.4 / 4的结果为0.1000...0010，与0.1很接近，被认为是“整”的小数0.1；而0.4 - 0.3 的结果为0.1000...00300，误差较大，被认为不是0.1，打印出来就直接将原值打印了。

注：以上的结果均是猜测的值，并不是真实的数据，能够说明问题即可。

总结：小数进行计算的时候，最好都使用BigDecimal类进行精确计算。

---

## **逻辑运算符中的a^b**

**逻辑运算符：**

​    ![](.\images\截图9.png)

异或运算符：**^**

**当符号左右两边布尔值不同时，结果为true。当两边布尔值相同时，结果为false。**

其实类似于 != 不等于运算符

但是!=可以适用在基础数据类型以及引用数据类型

但是^异或只能适用在布尔型

---

## 位运算符

### 一、**基本语法：**

![](.\images\截图10.png)

![](.\images\截图11.png)

**位运算符的运算过程都是基于底层二进制补码进行的。**

### **（1）左移：<<**

运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用）

例如：

> 3 << 4 类似于 3 * 2的4次幂 => 3 * 16 => 48

![](.\images\截图12.png)

> -3 << 4 类似于 -3 \* 2的4次幂 => -3 * 16 => -48

![](.\images\截图13.png)

### **（2）右移**

运算规则：在一定范围内，数据每向右移动一位，相当于原数据/2。（正数、负数都适用）

注意：**如果不能整除，向下取整**。

例如：

> 69>>4  类似于  69/2的4次 = 69/16 =4

![](.\images\截图14.png)

> -69 >> 4 类似于 -69 / 2的四次幂 = -69 / 16 = -5

![](.\images\截图15.png)

对于左移<<与右移>>运算符，它们用于进行乘2的n次幂以及除以2的n次幂的运算速度比乘法除法的运算速度快，但也就仅仅快一点点。

**使用左移、右移运算符时，需要注意可能字符移动后会超出字符长度**，此时就会出现错误

例如：

```java
System.out.println(10 << 100);
```

此时输出结果为：

> 160

明显结果是错误的，原因就在于二进制补码向左移动了太多位，导致超出了int类型数据存储的长度，导致发生数据错误。

所以**左移、右移运算符是有一定范围的，在使用时不能超出该范围**。

### **（3）无符号右移：>>>**

运算规则：往右移动后，左边出来的位直接补0。（正数、负数都适用）

![](.\images\截图16.png)

![](.\images\截图17.png)

![](.\images\截图18.png)

![](.\images\截图19.png)

![](.\images\截图20.png)

![](.\images\截图21.png)

![](.\images\截图22.png)

![](.\images\截图23.png)

![](.\images\截图24.png)

![](.\images\截图25.png)

---

## Java取整规则：向下取整

Java中的除法运算法则是：未除尽的数向下取整

例如：

```
int i1 = 10 / 3; //3.33333333333
int i2 = 11 / 3; //3.666666666667
System.out.println(i1);
System.out.println(i2);
```

输出结果：

```
3
3
```

出现这种情况的原因是：

Java除法余数取整规则是**向下取整**

这一规则也适用于右移运算符（除以2的n次幂）

---

## 三元运算符的效率略高于if...else...

---

## switch...case语句的注意点

1. switch(表达式)中表达式的值必须是下述几种类型之一：

   **byte、short、char、int、枚举以及String类型。**

   注意表达式不能是浮点型或者布尔类型。

   为什么不能是浮点型或者布尔类型呢？

   浮点型数据的精度是很差的，十进制的小数不一定都有二进制数与之对应，当case时有可能十进制数是一样的，但是二进制数不一样的情况出现；也有可能出现十进制小数一样，但二进制数不一样的形式出现。

   布尔类型要么是true

   

   ------

2. case子句中的值必须是常量，不能是变量名或不确定的表达式值或范围。

3. 同一个switch语句，所有case子句中的常量值互不相同。

4. break语句用来了执行完一个case分支后使程序跳出switch语句块；

   如果没有break，程序会顺序执行到switch结尾。

---

## 带标签的break和continue的使用

break和continue是老生常谈的东西，break终止这层循环，包括之后的本层循环；continue终结本次循环的语句，继续之后的本层循环。

在只有一层循环的时候，带标签和不带标签是没有区别的，以下都使用break试验：

```java
public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        System.out.println("i = " + i);
        if (i == 3) {
            break;
        }
    }
    tag:
    for (int j = 0; j < 10; j++) {
        System.out.println("j = " + j);
        if (j == 3) {
            break tag;
        }
    }
}
```

输出是：

```text
i = 0
i = 1
i = 2
i = 3
j = 0
j = 1
j = 2
j = 3
```

同时IDE也智能地提示这是一个不必要的标签

但对于两层及以上的嵌套循环，标签就有用了，先看不带标签的：

```java
public static void main(String[] args) {
    for (int i = 0; i < 3; i++) {
        System.out.println("i = " + i);
        for (int j = 0; i < 3; j++) {
            System.out.println("j = " + j);
            if (j == 1) {
                break;
            }
        }
    }
}
```

输出是：

```text
i = 0
j = 0
j = 1
i = 1
j = 0
j = 1
i = 2
j = 0
j = 1
```

可见，这个break只是终结了本层循环，对于它的上层无能为力，再看带有标签的：

```java
public static void main(String[] args) {
    tag:
    for (int i = 0; i < 3; i++) {
        System.out.println("i = " + i);
        for (int j = 0; i < 3; j++) {
            System.out.println("j = " + j);
            if (j == 1) {
                break tag;
            }
        }
    }
}
```

输出为：

```text
i = 0
j = 0
j = 1
```

总结一下，带标签的break和continue影响的范围是紧接着标签后的那个整体的语句块。

---

## 数组

### 一、数组的特点

1. 我们使用数组，就是看中：`数组通过下标（或索引）的方式调用指定位置的元素速度很快`。但是，数组的一大`缺点就是长度确定，不可修改`。
2. 数组本身是`引用数据类型`，而数组中的元素可以是`任何数据类型`，包括基本数据类型和引用数据类型。
3. 创建数组对象会在内存中开辟一整块`连续的空间`。占据的空间的大小，取决于数组的长度和数组中元素的类型。
4. 数组中的元素在内存中是依次紧密排列的，有序的。
5. 数组名中引用的是这块连续空间的首地址。

### 二、一维数组的声明与初始化

**语法**：

```
声明：
数据类型[] 数组名称;
例如：
int[] age;

初始化：
1.静态初始化：初始化时也赋值
数据类型[] 数组名 = new 数组类型[]{元素1, 元素2, 元素3...}；
或
数组类型[] 数组名 = {元素1, 元素2, 元素3...};
例如：
int[] age = new int[]{1, 2, 3};

2、动态初始化：初始化与赋值操作分开
数组类型[] 数组名 = new 数组类型[长度];
之后可以使用循环遍历的方式或直接赋值的方式进行赋值
例如：
int[] age = new int[3];
age[0] = 1;
age[1] = 2;
age[2] = 3;
```



### 三、数组的遍历

将数组中的每个元素分别获取出来，就是`遍历`。for循环与数组的遍历是绝配。

**举例**

```
public class ArrayTest4 {
    public static void main(String[] args) {
        int[] arr = new int[]{1,2,3,4,5};
        //打印数组的属性，输出结果是5
        System.out.println("数组的长度：" + arr.length);

        //遍历输出数组中的元素
        System.out.println("数组的元素有：");
        for(int i=0; i<arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
```



### 四、数组元素的默认值

数组是引用类型，当我们使用动态初始化方式创建数组时，元素只是默认值。数组元素的默认值为：

![](.\images\1561509460135.png)

**注意：**

```
数组如果不进行初始化，数组中的元素是有默认值的；

但是对于变量（基本数据类型与引用数据类型）来说：
1.如果变量是局部变量，那么必须初始化才可以使用；
2.如果变量是全局变量，如果未进行初始化，也有默认值，默认值与数组元素默认值一致。
```

### 五、一维数组内存分析

#### java中内存结构是如何划分的？

将内存区域划分为5个部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区。

| 区域名称   | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| `虚拟机栈` | 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完，自动释放。 |
| `堆内存`   | 存储对象（包括数组对象），new来创建的，都存储在堆内存。      |
| `方法区`   | 存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据。 |
| 本地方法栈 | 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 |
| 程序计数器 | 程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址 |

与数组有关的内存结构：

* 虚拟机栈：用于存放方法中声明的局部变量。
* 堆：用于存放数组的实体（即数组中的所有元素）

例如：int[]  arr = new int[]{1, 2, 3};

那么在虚拟机栈里面，存放的是arr这个数组名；

堆里面就存放着1,2,3。



#### 一维数组在内存中的存储

一维数组内存图

```java
public static void main(String[] args) {
  	int[] arr = new int[3];
  	System.out.println(arr);//[I@5f150435
}
```

程序执行流程：

1. main方法进入方法栈执行
2. 创建数组，JVM会在堆内存中开辟空间，存储数组；arr变量存储在栈中
3. 数组在内存中会有自己的内存地址，使用十六进制数表示
4. 数组中有3个元素，因为没有进行赋值，所以有默认值0
5. JVM将堆中数组的内存首地址赋值给栈中的变量arr
6. 变量arr保存的是数组内存中的地址值，不是具体的数值，因此是引用数据类型

![](.\images\数组内存图.png)

两个数组之间相互独立：

```java
public static void main(String[] args) {
    int[] arr = new int[3];
    int[] arr2 = new int[2];
    System.out.println(arr);
    System.out.println(arr2);
}
```

<img src=".\images\数组内存图2.jpg" style="zoom:67%;">

两个数组指向同一个地址：

```java
public static void main(String[] args) {
    // 定义数组，存储3个元素
    int[] arr = new int[3];
    //数组索引进行赋值
    arr[0] = 5;
    arr[1] = 6;
    arr[2] = 7;
    //输出3个索引上的元素值
    System.out.println(arr[0]);
    System.out.println(arr[1]);
    System.out.println(arr[2]);
    //定义数组变量arr2，将arr的地址赋值给arr2
    int[] arr2 = arr;
    arr2[1] = 9;
    System.out.println(arr[1]);
}
```

int arr2 = arr，不是将arr里面的数组值赋值给arr2，而是将arr的地址值赋值给arr2，让arr2指向arr的数组地址。

<img src="./images/数组内存图3.jpg" style="zoom:60%;">

### 六、二维数组的声明与初始化

二维数组和一维稍微有点不一样，二维数组可以看作多个一维数组，而这里面的一维数组长度可以互不相同。

**声明与初始化**：

```
声明：
int[][] arr;

初始化：
1.静态初始化
int[][] arr = {{1,2,3},{4,5,6},{7,8,9,10}};
int[][] arr = new int[][]{{1,4}, {43,66}, {5, 89, 10, 5}};

错误写法：
int[][] arr = new int[3][]{{1,2,3},{4,5,6},{7,8,9,10}};
这是错误的，静态初始化右边的[]中不能写数字，这和一维数组是一样的，一维数组静态初始化时[]中也不能写数字。

2.动态初始化
int[][] arr = new int[m][n];这里的n可写可不写
arr[0] = new int[]{1, 2, 4};
或
arr[0] = new int[3];
arr[0][0] = 1;
的方式进行赋值

当n写了，表明二维数组中的每一个一维数组都有相同的元素
当n没有写，二维数组中的每个一维数组都可以有随意的数量。
```

注：`int[][]arr = new int[][3]; ` //非法

所以我们可以使用二维数组，来保存一组一组的数据，并且这些组中元素的数量可以不同。



注意：

当我们去动态声明了二维数组时，还需要再给里面的一维数组声明，否则就是未声明就使用，例如：

```java
int[][] arr = new int[3][];
arr[0][0] = 3;
这种写法是错误的，会报空指针异常，因为arr[0]他也是一个一维数组，需要声明后才能使用，并且需要指明该一维数组的长度，即：
arr[0] = new int[3];
arr[0][0] = 3;
这样才是正确的。
```

* 二维数组中每个一维数组默认初始化值都是null。

* 需要对二维数组中的每一个一维数组分别进行初始化。

  ```
  public class Test22TwoDimensionalArrayUse {
      public static void main(String[] args){
          int[][] scores = {
                  {85,96,85,75},
                  {99,96,74,72,75},
                  {52,42,56,75}
          };
  
          //[[：代表二维数组，I代表元素类型是int
          System.out.println(scores);//[[I@15db9742
          System.out.println("一共有" + scores.length +"组成绩.");
        
          //[：代表一维数组，I代表元素类型是int
          System.out.println(scores[0]);//[I@6d06d69c
          System.out.println(scores[1]);//[I@7852e922
          System.out.println(scores[2]);//[I@4e25154f
          //System.out.println(scores[3]);//ArrayIndexOutOfBoundsException: 3
      
          System.out.println("第1组有" + scores[0].length +"个学员.");
          System.out.println("第2组有" + scores[1].length +"个学员.");
          System.out.println("第3组有" + scores[2].length +"个学员.");
      
          System.out.println("第1组的每一个学员成绩如下：");
          //第一行的元素
          System.out.println(scores[0][0]);//85
          System.out.println(scores[0][1]);//96
          System.out.println(scores[0][2]);//85
          System.out.println(scores[0][3]);//75
          
          //java.lang.ArrayIndexOutOfBoundsException: 4
        //System.out.println(scores[0][4]);
      }
  
  }
  ```

  

### 七、二维数组默认初始化值

二维数组不同的初始化方式有着不同的默认初始化值：

```java
int[][] arr = new int[3][2];
System.out.println(arr);
System.out.println(arr[0]);
System.out.println(arr[0][0]);

System.out.println("*********************************");

arr = new int[3][];
System.out.println(arr);
System.out.println(arr[0]);
System.out.println(arr[0][0]);
```

输出结果：

<img src=".\images\Snipaste_2023-10-18_19-43-29.png">

原因：

1. 当使用int[ \][ ] arr = new int[m\][n]的方式创建二维数组时，因为此时列值确定了（一维数组的长度），所以二维数组下的一维数组的长度也就确定了，此时二维数组下的一维数组也就完成了初始化，所以一维数组中的元素也就有了默认的初始值0。arr存储的是二维数组的地址值，arr[0]存储的则是二维数组下第一个元素（第一个一维数组）的地址值，arr[0\][0]存储的则是一维数组的默认初始值。
2. 当使用int[ \][ ] arr = new int[m\][ ]的方式创建二维数组时，因为此时的列值没有确定，即二维数组下每个一维数组的长度未确定，即未进行初始化，所以二维数组下的每个元素（一维数组的值）也就存储不了一维数组的地址值，即为null，但是因为二维数组确定了，所以arr可以存储二维数组的地址值。

### 八、二维数组内存解析

<img src=".\images\Snipaste_2023-10-18_19-51-55.png">

<img src=".\images\Snipaste_2023-10-18_19-56-30.png">

#### 1. 使用静态初始化的方式创建二维数组

例：

```java
int[][] arr = {
    {1},
    {2,2},
    {3,3,3},
    {4,4,4,4},
    {5,5,5,5,5}
};
```

<img src=".\images\1562112672215.png">

#### 2.使用动态初始化的方式创建二维数组（确定行数和列数）

例：

```
//1、声明二维数组，并确定行数和列数
int[][] arr = new int[4][5];

//2、确定元素的值
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr.length; j++) {
        arr[i][j] = i + 1;
    }
}
```

![](.\images\1562113179785.png)

#### 3.使用动态初始化的方式创建二维数组（仅确定行数）

```
//1、声明一个二维数组，并且确定行数
//因为每一行的列数不同，这里无法直接确定列数
int[][]  arr = new int[5][];

//2、确定每一行的列数
for(int i=0; i<arr.length; i++){
    /*
			arr[0] 的列数是1
			arr[1] 的列数是2
			arr[2] 的列数是3
			arr[3] 的列数是4
			arr[4] 的列数是5
			*/
    arr[i] = new int[i+1];
}

//3、确定元素的值
for(int i=0; i<arr.length; i++){
    for(int j=0; j<arr[i].length; j++){
        arr[i][j] = i+1;
    }
}
```

![](.\images\1562113981079.png)



**注意：**

`引用类型的变量在赋值的时候（赋的是地址值），会去校验是否与当前引用类型相同，如果相同才能够赋值，否则在编译期间就会报错。`

比如：

```
int[][] arr = new int[4][];
int[] arr2 = new int[3];
arr = arr2;
```

这种就会直接在编译期间报错，因为arr和arr2虽然都是int类型的数组，但是一个是一维数组一个是二维数组，类型不同，不能赋值。



### 九、数组的工具类Arrays

java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。比如：

* `数组元素拼接`：**toString**
  * static String toString(int[] a)：字符串表示形式由数组的元素列表组成，括在方括号（"[]"）中，相邻元素用字符","（逗号加空格）分隔。形式为：[元素1, 元素2, 元素3...]
  * static String toString(Object[] a)：字符串表示形式由数组的元素列表组成，括在方括号（"[]"）。相邻元素用字符","(逗号加空格）分隔。元素将自动调用自己从Object继承的toString方法将对象转为字符串进行拼接，如果没有重写，则返回类型@hash值，如果重写则按重写返回的字符串进行拼接。

* `数组排序` **sort**

  * static void sort(int[] a) ：将a数组按照从小到大进行排序
  * static void sort(int[] a, int fromIndex, int toIndex) ：将a数组的[fromIndex, toIndex)部分按照升序排列
  * static void sort(Object[] a) ：根据元素的自然顺序对指定对象数组按升序进行排序。
  * static <T> void sort(T[] a, Comparator<? super T> c) ：根据指定比较器产生的顺序对指定对象数组进行排序。

* `数组元素的二分查找` **binarySearch**

  **使用前提**：数组是有序的

  * static int binarySearch(int[] a, int key)  、static int binarySearch(Object[] a, Object key) ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数。

* `数组的复制` **copyOf**

  * static int[] copyOf(int[] original, int newLength)  ：根据original原数组复制一个长度为newLength的新数组，并返回新数组
  * static <T> T[] copyOf(T[] original,int newLength)：根据original原数组复制一个长度为newLength的新数组，并返回新数组
  * static int[] copyOfRange(int[] original, int from, int to) ：复制original原数组的[from,to)构成新数组，并返回新数组
  * static <T> T[] copyOfRange(T[] original,int from,int to)：复制original原数组的[from,to)构成新数组，并返回新数组

* `比较两个数组是否相等` **equals**

  * static boolean equals(int[] a, int[] a2) ：比较两个数组的长度、元素是否完全相同
  * static boolean equals(Object[] a,Object[] a2)：比较两个数组的长度、元素是否完全相同

* `填充数组 `**fill**

  * static void fill(int[] a, int val) ：用val值填充整个a数组
  * static void fill(Object[] a,Object val)：用val对象填充整个a数组
  * static void fill(int[] a, int fromIndex, int toIndex, int val)：将a数组[fromIndex,toIndex)部分填充为val值
  * static void fill(Object[] a, int fromIndex, int toIndex, Object val) ：将a数组[fromIndex,toIndex)部分填充为val对象

### 十、 数组中的常见异常

#### 8.1 数组角标越界异常

当访问数组元素时，下标指定超出[0, 数组名.length-1]的范围时，就会报数组下标越界异常：ArrayIndexOutOfBoundsException。

```java
public class TestArrayIndexOutOfBoundsException {
    public static void main(String[] args) {
        int[] arr = {1,2,3};
       // System.out.println("最后一个元素：" + arr[3]);//错误，下标越界
      //  System.out.println("最后一个元素：" + arr[arr.length]);//错误，下标越界
        System.out.println("最后一个元素：" + arr[arr.length-1]);//对
    }
}

```

创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 `ArrayIndexOutOfBoundsException`  数组越界异常。在开发中，数组的越界异常是**不能出现**的，一旦出现了，就必须要修改我们编写的代码。

#### 8.2 空指针异常

观察一下代码，运行后会出现什么结果。

```java
public class TestNullPointerException {
    public static void main(String[] args) {
        //定义数组
        int[][] arr = new int[3][];

        System.out.println(arr[0][0]);//NullPointerException
    }
}
```

因为此时数组的每一行还未分配具体存储元素的空间，此时arr\[0\]是null，此时访问arr\[0\]\[0\]会抛出`NullPointerException` 空指针异常。



**小结：空指针异常情况**

```java
		//举例一：
//		int[] arr1 = new int[10];
//		arr1 = null;
//		System.out.println(arr1[9]);
		
		//举例二：
//		int[][] arr2 = new int[5][];
//		//arr2[3] = new int[10];
//		System.out.println(arr2[3][3]);
		
		//举例三：
		String[] arr3 = new String[10];
		System.out.println(arr3[2].toString());
```

