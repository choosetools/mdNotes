# 一、页的概述

索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的`存储引擎`负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据，Memory使用内存来存储数据。

由于**`InnoDB`**是MySQL的**默认存储引擎**，所以本章剖析InnoDB粗出引擎的数据存储结构。

## 1、磁盘与内存交互基本单位：页

InnoDB将数据划分为若干个页，InnoDB中页的大小默认为**`16KB`**。

**以`页`作为磁盘和内存之间交互的基本单位**。也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**`在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页`**。一个页可以存储多个行记录。

> 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。

### **对数据库读取页理解：**

数据库缓冲池存在着**`预读`**的机制，每次从磁盘上IO时，**不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到数据库缓冲池中**。

正因为有了磁盘IO预读机制，所以才有了减少磁盘IO的可能，因为一次磁盘IO操作，可以查找到物理存储中相邻的一大片数据。一次磁盘IO操作可以取出物理粗出中相邻的一大片数据，如果查询的索引数据（就是B+树中从根节点一直到叶子节点整个过程中查询的节点数）都集中在该区域，那么只需要一次磁盘IO，否则就需要多次磁盘IO。

也就是说，如果在底层，一个索引中的页都物理存储集中在一片区域，有可能一次磁盘IO就直接将该索引中的页都读取到内存中了，只需要进行一次磁盘IO，但这是最理想状态，最不理想的状态就是一次只读取了索引中的一个页，每进行到B+树上的一层节点都要去进行一次磁盘IO。

**会将如果不考虑预读的话，一次读取是一页，也就是 16K，也就是对应 mysql B+ 树上的一个节点。**



## 2、页结构概述

![image-20240405104301332](.\images\image-20240405104301332.png)

页a、页b、页c...页n这些页可以`不在物理结构上相连`，只要通过`双向链表`相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个`单向链表`，每个数据页都会为存储在它里边的记录生成一个`页目录`，在通过主键查找某条记录的时候可以在页目录中使用`二分法`快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。

## 3、页的大小

不同的数据库管理系统页的大小不同，比如在MySQL的InnoDB存储引擎中，默认页的大小是**`16KB`**，我们可以通过下面的命令来进行查看：

```sql
show variables like '%innodb_page_size%';
```

![image-20240405121159838](.\images\image-20240405121159838.png)

SQL server中页的大小为`8KB`，而在Oracle中我们用术语"`块`"（Block）来代表"页"，Oracle支持的块大小为2KB，4KB，8KB，16KB，32KB和64KB.



## 4、页的上层结构

![image-20240405121000129](.\images\image-20240405121000129.png)

**`区（Extent）`**是比页大一级的存储结构，在InnoDB存储引擎中，`一个区会分配64个连续的页`。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。

**`段（Segment）`**是由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区和区之间是相邻的。`段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。`当我们创建数据表、索引的似乎，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

**`表空间（Tablespace）`**是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为`系统表空间`、`用户表空间`、`撤销表空间`、`临时表空间`等。比如：如果使用系统表空间，则数据和索引都存放在ibdata1文件中，如果使用独立表空间，则数据和索引都存储在.idb文件中。



# 二、页的内部构造

页如果按类型划分的话，常见的有`数据页（保存B+树节点）`、`系统页`、`Undo页`和`事务数据页`等。数据页是我们最常使用的页。

数据页的16KB大小存储空间被划分为七个部分，分别是文件头（File Header）、 页头（Page Header）、最大最小记录（Infimum+Supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。

页结构示意图如下所示：

![image.png](.\images\12343433.png)

其中，`File Header`、`Page Header`、`File Trailer`的大小是固定的，分别为38、56、8字节。`User Records`、`Free Space`、`Page Directory`这些部分为实际的行记录存储空间，因此大小是动态的。

这七个部分作用分别如下，我们简单梳理如下表所示：

![image-20240405135047564](.\images\image-20240405135047564.png)

我们可以把这七个结构分成3个部分。

## 第一部分：文件头部和文件尾部

### File Header文件头部

**作用：**

用于描述各种页的通用信息。（比如页的编号、其上一页下一页的页号等）

**大小：**

固定占用**`38个字节`**。

**构成：**

|                名称                | 占用的空间大小 |                             描述                             |
| :--------------------------------: | :------------: | :----------------------------------------------------------: |
|     `FIL_PAGE_SPACE_OR_CHKSUM`     |    `4`字节     |                   页的校验和（checksum值）                   |
|         `FIL_PAGE_OFFSET`          |    `4`字节     |                             页号                             |
|          `FIL_PAGE_PREV`           |    `4`字节     |                        上一个页的页号                        |
|          `FIL_PAGE_NEXT`           |    `4`字节     |                        下一个页的页号                        |
|            FIL_PAGE_LSN            |    `8`字节     |              页面被最后修改时对应的日志序列位置              |
|          `FIL_PAGE_TYPE`           |    `2`字节     |                          该页的类型                          |
|      FIL_PAGE_FILE_FLUSH_LSN       |    `8`字节     | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` |    `4`字节     |                       页属于哪个表空间                       |

来看看其中重要的组成部分：

* **1、`FIL_PAGE_OFFSET`（4字节）：页号。**

  每一个页都有一个单独的页号，用于定位页的。InnoDB通过页号来唯一定义一个页。

* **2、`FIL_PAGE_TYPE`（2字节）：页的类型，使用这个来代表当前页的类型。**

  所有的页类型如下所示：

  | 类型名称                | 十六进制 | 描述                             |
  | ----------------------- | -------- | -------------------------------- |
  | FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没有使用             |
  | `FIL_PAGE_UNDO_LOG`     | 0x0002   | Undo日志页                       |
  | FIL_PAGE_INODE          | 0x0003   | 段信息节点                       |
  | FIL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer空闲列表            |
  | FIL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer位图                |
  | `FIL_PAGE_TYPE_SYS`     | 0x0006   | 系统页                           |
  | FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据                     |
  | FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息                   |
  | FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页                       |
  | FIL_PAGE_TYPE_BLOB      | 0x000A   | 溢出页                           |
  | `FIL_PAGE_INDEX`        | 0x45BF   | 索引页，也就是我们所说的`数据页` |

  其中，使用的最多的页类型就是FIL_PAGE_INDEX，即数据页。

* **3、`FIL_PAGE_PREV`（4字节）和`FIL_PAGE_NEXT`（4字节）：上一个页和下一个页的页号，用于指向上一个页和下一个页（双向链表）。**

  InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页都串联起来了，保证这些页之间`在逻辑上是连续的`。

  ![image-20240405141012289](.\images\image-20240405141012289.png)

* **4、`FIL_PAGE_SPACE_OR_CHKSUM`（4字节）：页面的校验和。**

  **什么是校验和？**

  就是对于一个很长的字符串或者字节串来说，我们会通过某种算法（比如Hash算法）来计算出一个值来代表这个字节串，这个值就称为校验和。

  在比较两个字节串之前，先去比较这两个字节串的校验和，如果校验和都不一样，则这两个字节串一定是不等的，省去了直接比较两个长字节串的时间损耗。

  文件头部（File Header）和文件尾部（File Trailer）都有校验和属性：FIL_PAGE_SPACE_OR_CHKSUM。

  **作用：**

  InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到内存中。但是，如果在同步到一半断电了，这个时候就会造成页传输不完整。

  为了检测一个页是否完整，这个时候就可以通过`文件头与文件尾的校验和做比对`，如果两个值不相等，则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。

  **具体的：**

  每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页的最前边，所以File Header的校验和会先同步到磁盘中，当完全写完时，校验和也会被写到磁盘中页的尾部，如果完全同步成功，则磁盘中页头部和页尾部的校验和应该是一样的。如果写了一半断电了，那么磁盘中File Header中校验和是修改过的页，File Trailer中校验和是原先的页，二者不同，意味着同步中出现了问题。这里的校验方式就是采用Hash算法进行校验。

* **5、`FIL_PAGE_LSN`（8字节）：页面被最后修改时对应的日志序列位置。**

  这个部分也是为了校验页的完整性的，如果页头部和尾部的LSN值不一致的话，就说明同步过程中出现了问题。



### File Trailer文件尾部

**作用：**

这部分配合着File Header使用，**用于校验页是否完整**，防止页在刷入磁盘的过程中，由于意外情况导致了失败，从而造成数据不一致的情况，也就是形成了脏页。

**大小：**

固定**`8个字节`**

**构成：**

前4个字节代表页的`校验和`，这部分是和File Header中的校验和相对应的。

后4个字节代表页面最后修改时对应的`日志序列位置（LSN）`，用于与首部的LSN值校验，如果校验不成功，说明同步过程中出现了问题。







---

## 第二部分：空闲空间、用户记录和最小最大记录

### Free Space空闲空间

**存储记录变化过程：**

我们自己存储的记录会按照指定的行格式存放到User Records（用户记录）部分。但是在一开始生成页的时候，其实并没有User Records这个部分，`每当我们插入一条数据，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分给User Records部分`。当插入第一条数据时，就会将其记录成为最小最大记录，每次插入数据，都会重新计算最小最大记录，并使用单向链表将它们`逻辑上排列在一起`。当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。

![image-20240405155040595](.\images\image-20240405155040595.png)



### User Records用户记录

User Records中的这些记录按照指定的行格式，一条一条地排列在User Records部分，相互之间形成单向链表。

> 用户记录中的数据，**在`物理结构`上按照插入的先后顺序依次排列，在`逻辑结构上`按照主键的先后顺序依次排列（单链表）**。

具体的信息请查看行格式中记录头信息部分。



### Infimum + Supremum最小最大记录

InnoDB每个数据页中有两个虚拟的记录行，用来限定记录的边界。**`Infimum`记录是比该页中任何主键值都要小的记录，`Supremum`记录是比该页中任何主键值都要大的记录**。这两个记录在页创建时被建立，并且在任何情况下不会被删除。

并且由于这两天记录不是我们定义的记录，所以它并不存放在User Records部分，他们被单独放在一个称为Infimum + Supremum的部分。

Infimum和Supremum都是由**`5字节`**的记录头和**`8字节`**的一个固定的部分组成，最小记录的固定部分就是表示`单词infimum`，最大记录的固定部分就是表示`单词supremum`。由于不存在可变长度字段或可为空的字段，自然就不存在可变长度字段列表和NULL值列表了。

Infimum和Supremum记录的结构如下图所示。需要注意，Infimum记录头的`record_type=2`，表示最小记录；`head_no=0`，表示在当前页中该记录位于第一位。Supremum记录头的`record_type=3`，表示最大记录；`head_no=1`，表示在当前页中该记录位于第二位。

![image-20240405163810252](.\images\image-20240405163810252.png)

加上Infimum和Supremum记录后，页中的记录看起来就像下图。**Infimum记录头的next_record指向该页主键最小值的记录，该页主键最大的记录的next_reocrd则指向Supremum**，Infimum和Supremum构成了记录的边界。同时注意，记录头中head_no的顺序，Infimum和Supremum是排在最前面的。

![image-20240405164027725](.\images\image-20240405164027725.png)









---

## 第三部分：页目录和页面头部

### Page Directory页目录

**为什么需要页目录？**

在页中，记录是以`单向链表`的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是`检索效率不高`，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，`专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率`。



现在有一个**需求**：根据主键值查找页中的某条记录，如何实现快速查找呢？

比如：

```sql
SELECT * FROM page_demo WHERE c1 = 3;
```

方式一：顺序查找：

 从Infimum记录（最小记录）开始，沿着链表一直往后找，总有一天可以找到（或许找不到），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大的顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，就可以停止查找了，因为该节点后边的节点的主键值是依次递增的。

如果一个页中存储了很多记录，这样查找的性能很差。

**`方式二：使用页目录，二分法查找`**

1. 将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为"已删除"的记录。

2. 第一组，也就是最小记录所在的组只有一条记录

   最后一组，也就是最大记录所在的组，会有1-8条记录；

   其余组的数量在4-8条之间

这样做的好处就是，除了第一组以外，其余组的记录数会尽量评分。

3. 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为`n_owned`字段。
4. **页目录用来存储每组最后一条记录的`地址偏移量`**，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为**`槽（slot）`**，每个槽相当于指针指向了不同组的最后一个记录。

![image-20240405210848860](.\images\image-20240405210848860.png)

> **注意：**
>
> **槽的值，指的是组中最大记录的地址偏移量，这里的地址偏移量，指的是`从页面的0字节开始，到记录中真实数据位置的节点数`。**
>
> 比如，槽0的值是99，代表从页面0字节开始数，到最小记录中表示'infimum'开头位置的节点数。

例如：

![image-20240405211509496](.\images\image-20240405211509496.png)

从这个图中，我们需要注意这么几点：

* 现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。
* 注意最小和最大记录的头信息中的`n_owned`属性
  * 最小记录的n_owned值为1，这就嗲表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身
  * 最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录

**问题**：为什么最小记录的n_owned值为1，而最大记录的n_owned为5呢？

InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1~8条之间，剩下的分组中记录的条数范围之内在4~8条之间。



用箭头指向的方式替代数字，这样更易于我们理解，修改后如下：

![image-20240405212450349](.\images\image-20240405212450349.png)





**页目录分组的个数如何确定？**

分组是按照下边的步骤进行的：

* 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们属于两个分组。
* 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加一条记录，直到该组中的记录数等于8个。
* 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。
* 因为插入数据是往后面继续插入的，所以实际上插入的组都是包含最大记录的组，一直在最大记录组中添加，直到最大记录组中的记录数达到8个之后再往其中添加时，就会将其拆分成两个组，不包含最大记录的组4个记录，包含最大记录的组5个记录，循此往复。



**`页目录结构下如何快速查找记录？`**

现在想page_demo表中添加更多的数据。如下：

```sql
INSERT INTO page_demo
VALUES
(5, 500, 'zhou'), 
(6, 600, 'chen'), 
(7, 700, 'deng'), 
(8, 800, 'yang'), 
(9, 900, 'wang'), 
(10, 1000, 'zhao'), 
(11, 1100, 'qian'), 
(12, 1200, 'feng'), 
(13, 1300, 'tang'), 
(14, 1400, 'ding'), 
(15, 1500, 'jing'), 
(16, 1600, 'quan');
```

添加了12条记录，现在页里一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：

![image-20240405213407214](.\images\image-20240405213407214.png)

这里只保留了16条记录的记录头信息中的n_owned和next_record属性，省略了各个记录之间的箭头。

因为各个槽代表的记录主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找。5个槽的编号分别是0、1、2、3、4。比如此时，我们要去找主键值为6的记录，**过程**是这样的：

1. 使用二分法进行查找，设置low=0，high=4.
2. 计算中间槽的位置：(0+4)/2=2，查看槽2对应记录的主键值为8，由于8>6，所以要查找的数据在左侧，设置high=2，low不变。
3. 重新计算中间槽的位置：(0+2)/2=1，查看槽1对应的主键值为4，因为4<6，所以设置low=1，high不变。
4. 因为high-low的值为1，所以确定主键值为6的记录在槽2对应的组中（槽1对应的组中最大记录主键值为4）。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。

但是，我们之前说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？因为每个槽是紧挨着的，我们去拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以，我们可以从这条记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。

由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录代价是很小的。

**小结：**

在一个数据页中查找指定主键值的记录过程分为两步：

1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的next_record属性遍历该槽所在的组中的各个记录。





### Page Header页面头部

为了能得到一个数据页中**存储记录的状态信息**，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各个状态信息。

| 名称                | 占用空间大小 | 描述                                                         |
| ------------------- | ------------ | ------------------------------------------------------------ |
| `PAGE_N_DIR_SLOTS`  | 2字节        | 在页目录中的槽数量                                           |
| `PAGE_HEAP_TOP`     | 2字节        | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space   |
| `PAGE_N_HEAP`       | 2字节        | 本页中的记录的数量（包括最小、最大以及标记为删除的记录）     |
| `PAGE_FREE`         | 2字节        | 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record会组成一个单链表，这个单链表可以被重新利用） |
| `PAGE_GARBAGE`      | 2字节        | 已删除记录占用的字节数                                       |
| `PAGE_LAST_INSERT`  | 2字节        | 最后插入记录的位置                                           |
| `PAGE_DIRECTION`    | 2字节        | 记录插入的方向。假如新插入的记录比上一条记录的主键值大，就说这条记录的插入方向是右，反之则是左 |
| `PAGE_N_DIRECTION`  | 2字节        | 一个方向连续插入的记录数量，假如连续几次插入的记录方向是一致的，就将条数记录下来，如果最后一条记录方向改变的话，这个值会被清零重新统计 |
| `PAGE_N_RECS`       | 2字节        | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| `PAGE_MAX_TRX_ID`   | 8字节        | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| `PAGE_LEVEL`        | 2字节        | 当前页在B+树中所处的层级，叶子节点位于树中的第0层            |
| `PAGE_INDEX_ID`     | 8字节        | 索引ID，表示当前页属于哪个索引                               |
| `PAGE_BTR_SEG_LEAF` | 10字节       | B+树叶子段的头部信息，仅在B+树的ROOT页定义                   |
| `PAGE_BTR_SEG_TOP`  | 10字节       | B+树非叶子段的头部信息，仅在B+树的ROOT页定义                 |







---

## 从数据页的角度看B+数如何查询

一棵B+树按照节点类型可以分为两部分：

1. 叶子节点，B+树最底层的节点，节点的高度为0，存储行记录。
2. 非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。

![image-20240405222553560](.\images\image-20240405222553560.png)

当我们从页结构来理解B+树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：

**`1、B+树是如何进行记录检索的？`**

如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用`二分查找`的方式先找到一个粗略的记录分组，然后再在分组中通过`链表遍历`的方式查找记录。

**`2、普通索引和唯一索引在查询效率上有什么不同？`**

普通索引，即普通列的索引，比如last_name。

唯一索引，即具有唯一约束列的索引。

我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？

唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读取出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以，对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。





# 三、InnoDB行格式（或记录格式）

mysql5.0之后的默认行格式为`Compact`，5.7之后的默认行格式为`dynamic`。

我们平时的数据以行为单位向表中插入数据，这些记录子啊磁盘上的存放方式也被成为行格式或者记录格式。InnoDB存储引擎设计了4中不同类型的行格式，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式。

查看MySQL8的默认行格式：

![image-20240405235546390](.\images\image-20240405235546390.png)

也可以使用如下语法查看具体表使用的行格式：

```sql
SHOW TABLE STATUS LIKE '表名'\G
```

例如：

![image-20240405235937262](.\images\image-20240405235937262.png)





## 如何指定行格式？

**在创建或修改表的语句中指定行格式：**

```sql
#创建时
CREATE TABLE 表名(
	列的信息
)ROW_FORMAT = 行格式名称;

#修改时
ALTER TABLE 表名 ROW_FORMAT = 行格式名称;
```



举例：

创建一个表，使用Compact的行格式

```sql
CREATE TABLE record_test_table(
	col1 VARCHAR(8),
	col2 VARCHAR(8) NOT NULL,
	col3 CHAR(7),
	col4 VARCHAR(8)
)ROW_FORMAT = Compact;
```

此时，创建出来的表的行格式就是Compact：

![image-20240406000552793](.\images\image-20240406000552793.png)

我们也可以创建出来表后，去修改表的行格式，比如将行格式修改成Dynamic：

```sql
ALTER TABLE record_test_table ROW_FORMAT = Dynamic;
```

此时，去查看表中的属性时，就可以看到行格式修改成了Dynamic：

![image-20240406000847605](.\images\image-20240406000847605.png)







## Compact行格式

在MySQL5.1-5.7版本之间，MySQL默认的行格式为Compact。一条完整的记录可以被范围记录的`额外信息`和记录的`真实数据`两大部分。

![image-20240405165331760](.\images\image-20240405165331760.png)





---

### 1、变长字段长度列表

MySQL支持一些变长的数据类型，例如`VARCHAR(M)`、`VARBINARY(M)`、`TEXT类型`、`BLOB类型`，这些数据类型修饰列被称为**变长字段**。

比如说创建一个表时，表中有字段last_name类型为VARCHAR(15)，但是last_name字段并不占用15个字符长度，而是根据实际的字符占用，只不过是规定15封顶，不可超过15个字符。

变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数页存起来。

> **在Compact行格式中，把所有变长字段的真实数据`占用的字节长度`都存放在记录的开头部位，从而形成一个变长字段长度列表。**

**注意：**这里面存储的变长长度和字段`顺序是反的`。比如两个varchar字段在表结构的顺序是：第一个字段a，实际长度为10；第二个字段b，实际长度为15。那么在变长字段长度列表中存储的长度顺序就是15,10，是反过来的。



**举例：**

表结构是：

```sql
CREATE TABLE record_test_table(
	col1 VARCHAR(8),
	col2 CARCHAR(8) NOT NULL,
	col3 CHAR(8),
    col4 CARCHAR(8)
)CHARSET = ascii ROW_FORMAT = Compact;
```

现往其中插入数据：

```sql
INSERT INTO record_test_table
VALUES('zhangsan', 'lisi', 'wangwu', 'songhk');
```

因为record_test_table表中的col1、col2、col4都是VARCHAR(8)类型的（col3是CHAR(8)类型，CHAR类型的数据是固定长度的，所以不存放在变长字段长度列表中），所以这三个列的值**实际占用的`字节`长度**需要保存在记录开头处。

由于这个表，使用的是ascii编码，一个字符占用1个字节进行编码。

| 列名 | 存储内容   | 内容长度（十进制表示） | 内容长度（十进制表示） |
| ---- | ---------- | ---------------------- | ---------------------- |
| col1 | 'zhangsan' | 8                      | 0x08                   |
| col2 | 'lisi'     | 4                      | 0x04                   |
| col4 | 'songhk'   | 6                      | 0x06                   |

又因为这些长度值需要**按照列的`逆序`存放**，所以最后变长长度列表的字节串用十六进制表示的效果就是：

06 04 08

把这个字节串组成的变长字段长度列表填入用户记录的示意图，效果就是：

![image-20240406110139505](.\images\image-20240406110139505.png)





---

### 2、NULL值列表

Compact行格式会把**`可以为NULL`**的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储NULL的列，则NULL值列表也不存在了。

**问：为什么要定义NULL值列表？**

比如：数据表中有4个字段，往数据表中插入两条数据：

'a','b','c','d'

'e',NULL,NULL,'f'

那么NULL值在底层是如何进行存储的？数据都是需要对齐的，若使用一个特定的符号放到NULL的位置上，很浪费空间；若直接让后面非NULL的值往前移动，占用NULL的位置，则这样就有可能会出现错误，比如上例中'f'往前移动，这样MySQL就不知道这个'f'是第四个字段的值还是第二个。所以，我们需要去标识这些数据哪些是非空数据，哪些是空数据。

**即：**

之所以要存储NULL是因为数据需要对齐，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据的头部开辟出来一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据。

> **格式如下：**
>
> 1. 二进制为的值为1时，代表该列的值为NULL。
> 2. 二进制位的值为0时，代表该列的值不为NULL。
>
> 
>
> **注意：**
>
> * NULL值列表仅针对**可以为NULL值**的列，若列是**`非空约束列`**或者**`主键列`**，则不在该范围内。
>
> * NULL值列表的顺序与变长字段长度列表的顺序一样，都是按照**`列的逆序`**存放的。

例如：字段a、b、c，其中a是主键，在某一行中存储的数依次是a=1，b=null，c=2。那么Compact行格式中NULL值列表中存储的是01。第一个0表示c不为null，第一个1表示b是null。按照列的逆序存放。

这里之所以没有a是因为主键肯定是非NULL的，所以在NULL值列表的数据中会自动跳过主键。



**案例：**

创建表：

```sql
CREATE TABLE record_test_table(
	col1 VARCHAR(8),
	col2 CARCHAR(8) NOT NULL,
	col3 CHAR(8),
    col4 CARCHAR(8)
)CHARSET = ascii ROW_FORMAT = Compact;
```

插入数据：

```sql
INSERT INTO record_test_table(col1, col2, col3, col4) 
VALUES
('zhangsan', 'lisi', 'wangwu', 'songhk'), 
('tong', 'chen', NULL, NULL);
```

实际上，第一条记录的NULL值列表为：

![image-20240406112826584](.\images\image-20240406112826584.png)

因为都不为NULL，所以NULL值列表中的值都是0.



第二条记录的NULL值列表为：

![image-20240406112851390](.\images\image-20240406112851390.png)

col3和col4的值为null，按照逆序排序，先放col4，再放col3，最后放col1。



注意不包括col2列，因为col2设置了NOT NULL约束，所以col2一定不为NULL，所以NULL值列表中不会包含col2是否为NULL。





---

### 3、记录头信息

创建一个表：

```sql
CREATE TABLE page_demo(
	c1 INT,
    c2 INT,
    c3 VARCHAR(100),
    PRIMARY KEY(c1)
)ROW_FORMAT = Compact;
```

这个表中记录的行格式示意图：

![image-20240405174719135](.\images\image-20240405174719135.png)

这些记录头信息各个**属性**如下：

| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| 预留位1        | 1                 | 没有使用                                                     |
| 预留位2        | 1                 | 没有使用                                                     |
| `delete_mask`  | 1                 | 标记该记录是否被删除                                         |
| `min_rec_mask` | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | 4                 | 组中最后一个记录存储该组一共有多少条记录                     |
| `head_no`      | 13                | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
| `next_reocrd`  | 16                | 表示下一条记录的相对位置                                     |

简化后的行格式示意图：

![image-20240405175438293](.\images\image-20240405175438293.png)

往表中插入数据：

```sql
INSERT INTO page_demo 
VALUES
(1, 100, 'song'),
(2, 200, 'tong'),
(3, 300, 'zhan'),
(4, 400 ,'lisi');
```

插入数据后，图示结果如下：

![image-20240405175621668](.\images\image-20240405175621668.png)

现在解释一下这几个属性。

* <font style="background-color:yellow">**`delete_mask`**</font>

这个属性，用于标记当前记录**是否被删除**了，占用1个二进制位。

当值为`0`时，代表记录没有被删除。

当值为`1`时，代表记录被删除掉了。

**被删除的记录为什么还在页中存储呢？**

你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上`需要重新排列，导致性能消耗`（记录按照插入的顺序在物理磁盘上存储）。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个`新的链表`（垃圾链表），在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉，比如删除了主键为10的数据，此时又插入了一个主键为10的新记录时，就会在原有的基础上进行覆盖。



* <font style="background-color:yellow">**`min_rec_mask`**</font>

min_rec_mask用于**标记B+树中每一层非叶子节点的最小记录**，此时的值为1，否则为0.

比如：

![image-20240405180946030](.\images\image-20240405180946030.png)

上图中被红色框起来的记录，min_rec_mask的值为1，那么其他所有记录的值都为0。

我们自己插入的四条记录的min_rec_mask的值都是0，因为它们实际上都是存放在叶子节点上的。



* <font style="background-color:yellow">**`record_type`**</font>

record_type用来表示当前记录的**类型**，一共有4种类型的记录：

`0`：表示普通记录

`1`：表示B+树非叶子节点记录

`2`：表示最小记录

`3`：表示最大记录

![image-20240405181600917](.\images\image-20240405181600917.png)

如上图所示，红色框起来的值就是record_type的值。

2表示该页中的最小记录

1表示该记录是非叶子节点的记录（目录项）

3表示该页中的最大记录

0表示该记录是叶子节点的记录（数据项）



- <font style="background-color:yellow">**`heap_no`**</font>

heap_no属性表示该记录在页中的**位置**。

![image-20240405175621668](.\images\image-20240405175621668.png)

如上图所示，第一条记录的heap_no是2，第二条记录的heap_no是3，第三条记录的heap_no是4，第四条记录的heap_no是5。

**注意**：这里的位置指的是**`物理`上的位置**，不是逻辑上的位置，即按照插入的顺序排列。

比如说，我们插入的数据顺序是：

```sql
INSERT INTO page_demo 
VALUES
(4, 400 ,'lisi');
(3, 300, 'zhan'),
(2, 200, 'tong'),
(1, 100, 'song'),
```

那么实际上，id为4的记录heap_no值为2，id为3的记录heap_no值为3......

但是，在逻辑上来说，id为4的记录实际上排在最后。

**问题**：heap_no值为0和1的记录呢？

MySQL会自动给每个页加两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为`伪记录`或`虚拟记录`。这两个伪记录一个代表最小记录，一个代表最大记录，即Infimum与Supremum。最小记录和最大记录的heap_no值分别为0和1，也就是说**它们实际在物理上位置最靠前**。

![image-20240405182845484](.\images\image-20240405182845484.png)



- <font style="background-color:yellow">**`n_owned`**</font>

页目录中，每个组的最后一条记录的头信息n_owned字段中，**存储着该组一共有多少条记录**，这个n_owned字段就是存储组中记录数量的字段。

**问题**：为什么要将记录进行分组呢？

我们通过使用二分法，在页目录中去查找匹配的主键值。如果不使用分组，那页目录中就需要存储页中所有记录的主键值，当页中的记录非常多时，页目录所占用的空间就非常大，这是得不偿失的。所以，我们可以对页中的记录进行分组操作，4~8个记录为一组，每个组看作是一个槽，对这些组中最后一个记录的主键值进行二分法查找，这样一来，效率就会高很多。

所以，这也就是为什么只有少部分的记录中该字段有数据的原因，其他记录该字段的值都为0.



**详情请参考页目录`Page Directory`**



- <font style="background-color:yellow">**`next_record`**</font>

该属性表示从当前记录的真实数据到下一条记录的真实数据的**`地址偏移量`**。

比如：

![image-20240405175621668](.\images\image-20240405175621668.png)

第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个子节点便是下一条记录的真实数据。

**注意：下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值从小到大顺序的下一条记录。`（逻辑上的下一条记录）`**

规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录）。下图用箭头代替偏移量表示next_record

![image-20240405184634721](.\images\image-20240405184634721.png)

为了更好理解，下面演示一下删除和添加操作：

**演示：删除操作**

例如：

```sql
DELETE FROM page_demp WHERE c1 = 2;
```

删除第2条记录后的示意图就是：

![image-20240405184834264](.\images\image-20240405184834264.png)

从图中可以看出来，删除第2条记录前后主要发生了这些变化：

* 第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。
* 第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。（如果页中有多条被删除的记录，则next_record指向下一个被删除的记录）
* 第1条记录的next_record指向了第3条记录
* 最大记录的n_owned值从5变为了4.（组中的数据减少了一个）

`所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。`



**演示：添加操作**

在上面演示的基础上进行操作：

```sql
INSERT INTO page_demo VALUES(2, 200, 'tong');
```

我们来看一下记录的存储情况：

![image-20240405185420778](.\images\image-20240405185420778.png)

直接复用了原来被删除记录的存储空间。

**说明：**

当数据页中存在多条被删除的记录时，这些记录的next_record属性将会把这些删除掉的记录组成一个垃圾链表，以备之后复用这部分存储空间。





---

### 4、记录的真实数据

记录的真实数据除了我们定义的列数据以外，还会有三个隐藏列：

| 列名             | 是否必须 | 占用空间 | 描述                   |
| ---------------- | -------- | -------- | ---------------------- |
| `row_id`         | 否       | 6字节    | 行ID，唯一标识一条记录 |
| `transaction_id` | 是       | 6字节    | 事务ID                 |
| `roll_pointer`   | 是       | 7字节    | 回滚指针               |

实际上这几个列的真正名称是：`DB_ROW_ID`、`DB_TRX_ID`、`DB_ROLL_PRT`。

* **`DB_ROW_ID`**：一个表没有手动定义主键，则会选取一个Unique键作为聚簇索引中的主键，如果连Unique键都没有定义的话，则会为表默认添加一个名称row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会出现。
* **`DB_TRX_ID`**：每个事务都会分配一个事务ID，即记录一下当前这条记录是由哪条事务进行操作的，我们就把这个事务的事务ID写入到这个列中。
* **`DB_ROLL_PTR`**：回滚指针，指向undo log。例如，当我们对行记录进行修改后，这个行记录存放的是修改后的数据，我们要进行回滚，回滚成修改前的记录时，我们就需要修改的undo log信息，帮助我们进行回滚操作。

![image-20240424113910505](.\images\image-20240424113910505.png)

---

### 案例分析

创建表：

```sql
CREATE TABLE mytest(
col1 VARCHAR(10),
col2 VARCHAR(10),
col3 CHAR(10),
col4 VARCHAR(10)
)ENGINE=INNODB CHARSET=LATIN1 ROW_FORMAT=COMPACT;
```

插入数据：

```sql
INSERT INTO mytest
VALUES('a','bb','bb','ccc');
 
INSERT INTO mytest
VALUES('d','ee','ee','fff');
 
INSERT INTO mytest
VALUES('d',NULL,NULL,'fff');
```

让我们去查看一下，这个表创建出来的表空间文件mytest.ibd这个二进制文件，将二进制数据转换成十六进制后，获取到的内容如下：

![image-20240406124204532](.\images\image-20240406124204532.png)

首先我们来看看第一行数据：`a bb bb ccc`用户记录对应的编码：

![image-20240406124522967](.\images\image-20240406124522967.png)

**从左到右，编码依次是：**

* `03 02 01`：变长字段长度列表，若有，一个字段占用两个字节。在表mytest中，col1、col2和col4都是变长字段，占用的字节长度分别为1,2,3，转换成十六进制就是01、02和03，按照逆序排序就是03 02 01。

* `00`：NULL值列表，转换成二进制是0000 0000，由于字段没有值是NULL，所以NULL值列表的值为0.

* `00 00 10 00 2c`：用户记录头信息，固定5个字节长度，其中的2c代表下一个记录的偏移量，即当前记录的位置加上偏移量0x2c就是下条记录的起始位置。

* `00 00 00 2b 68 00`：表示row_id，由于该表中没有创建主键和unique键，所以InnoDB自动给我们创建了row_id表示主键，固定6字节。

* `00 00 00 00 06 05`：表示transaction_id，固定占用6字节。

* `80 00 00 00 32 01 10`：表示Roll Pointer，固定占用7字节。

* `61`：表示列1数据'a'

* `62 62`：表示列2数据'bb'

* `62 62 20 20 20 20 20 20 20 20`：表示列3数据'bb'，由于列3是CHAR(8)类型，所以固定占用8个字节，当数据未能完全占用其长度空间时，使用0x20来进行填充。

* `63 63 63`：表示列4数据'ccc'。



我们再来看看第三行数据d NULL NULL fff对应的编码：

![image-20240406125818285](.\images\image-20240406125818285.png)

由于第三行有NULL值，在变长长度字段列表中，就会将有NULL值的字段长度不再存储。

NULL标志位不再是00，而是06，转换为二进制为0000 0110，由于其是逆序的，所以实际上表示NULL的顺序是0110 0000，两个1代表着col2和col3是NULL值。在后面存储数据的部分，可以发现只存储了第一列和第四列的数据，而不包括为NULL值的第二列和第三列数据。

这个例子很好地说明了：`不管是CHAR类型还是VARCHAR类型，在Compact格式下NULL值都不占用任何存储空间。`





---

## 行溢出

`InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。`

**引入：**

很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节，这是真的么？如果我们使用ASCII字符集的话，一个字符代表一个字节，我们看看VARCHAR(65535)是否真的可用.

```sql
CREATE  TABLE  varchar_size_demo(
	c  VARCHAR(65535)
)CHARSET=ascii  ROW_FORMAT=Compact;
```

结果如下：

1118 - Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs

报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限的，除了BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度不能超过65535个字节。

这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占用空间以外，还需要记录的额外信息。

如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为变长字段长度列表占用2个字节，NULL值标识需要占用1个字节。此时，去创建表：

```sql
CREATE TABLE varchar_size_demo(
	c VARCHAR(65532)
)CHARSET = ASCII ROW_FORMAT = Compact;
```

如果有NOT NULL属性，此时就不需要NULL值标识，也就可以多存储一个字节，即65533个字节：

```sql
CREATE TABLE varchar_size_demo(
	c VARCHAR(65533)
)CHARSET = ASCII ROW_FROMAT = Compact;
```

通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这就有可能出现一个页存放不了一条记录，这种现象称为**`行溢出`**。

**如果出现行溢出现象，那MySQL是如何去解决这一问题的呢？**

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他页中进行**`分页存储`**，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节还包括这些分散在其他页面中的数据占用的字节数），从而可以找到剩余数据所在的页。

在`Dynamic`和`Compressed`行格式中，当前页中则不会存储该列的一部分数据，而将列中所有数据都存储在其他页中，当前页只存储其他页的地址和字节数信息。这被称为**`完全溢出`**。

**使用其他页存储当前页中列的信息的方式，称之为`页的扩展`**，举例如下：

![image-20240406142340153](.\images\image-20240406142340153.png)



> **四种行格式处理行溢出的不同之处：**
>
> `Compact`和`Redundant`如果遇到行溢出时，会先将一部分数据存储在当前页中，然后再将剩下部分的数据存放在其他页里，当前页中存放其他页的地址和所占用的字节数。
>
> 但是`Dynamic`和`Compressed`不同，Dynamic和Compressed采用了完全行溢出方式，在当前页中只存放溢出页的地址，实际的数据都存放在溢出页中。



---

## Dynamic和Compressed行格式

在MySQL8.0中，默认的行格式就是**`Dynamic`**。Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：

* `Compressed`和`Dynamic`两种记录格式对于处理行溢出数据采用了完全的行溢出方式。如图，在数据页中只存放20个20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。
* `Compact`和`Redundant`两种格式会在记录的真实数据处存储列的一部分数据（存放768个前缀字节）。

![image-20240406142729654](.\images\image-20240406142729654.png)



也就是说：

> Dynamic和Compressed行格式，除了在处理行溢出问题上与Compact有所不同之外，其余情况基本一致。Dynamic和Compressed采用的是**完全行溢出方式**，只存放溢出页的指针，不存放记录真实数据；Compact还会存放记录的一部分真实数据（768个前缀字节）





**Compressed与Dynamic不同的是：**

Compressed在Dynamic的基础上，采用了**`alib`**算法进行`压缩处理`，这样一来对于BLOB和TEXT这种大长度类型的数据能够更加有效地存储，占用更小的内存空间。





---

## Redundant行格式（了解即可）

Redundant是MySQL5.0版本之前InnoDB的行记录存储方式，MySQL5.0支持Redundant是为了兼容之前版本的页格式。

现在我们把表record_test_table的行格式修改为Redundant：

```sql
ALTER TABLE record_test_table ROW_FORMAT=Redundant;
```

![image-20240406145020319](.\images\image-20240406145020319.png)

从上图可以看到，不同于Compact行格式记录，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序`逆序放置`的。

下面，我们从各个方面看一下Redundant行格式有什么不同之处。



### 字段长度偏移列表

**字段长度偏移列表，存放的是各个字段（包括隐藏列）所占用的字节长度差值。**

按照列的顺序**`逆序放置`**。

字段长度信息得到了，那么我们就可以根据这个长度信息，计算获取到字段所在的位置，直接去底层获取各个字段的信息，就不需要知道字段实际占用几个字节，是不是NULL了。

但是，这有几个问题：

* 冗余。有一些固定的字段，比如CHAR(8)，这个字段就一定是占用8个字符长度的，不需要知道这个字段到底占用了几个字节，直接去读取就可以了，但是字段长度偏移列表中还是包含了这个字段的信息，就会显得冗余。还有隐藏列的信息，也没有必要存放在字段长度偏移列表中。
* "偏移"：Redundant采用了两个相邻数值的差值来计算各个列值的长度，不直观。



举例：

比如第一条记录的字段长度偏移列表就是：
2B 25 1F 1B 13 0C 06

因为它是逆序排放的，所以按照列的顺序排列就是：
06 0C 13 17 1A 24 25
按照两个相邻数值的差值来计算各个列值的长度的意思就是：



第一列(row_id)的长度就是 0x06个字节，也就是6个字节。
第二列(transaction_id)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。
第三列(roll_pointer)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。
第四列(col1)的长度就是 (0x1B - 0x13)个字节，也就是8个字节。
第五列(col2)的长度就是 (0x1F - 0x1B)个字节，也就是4个字节。
第六列(col3)的长度就是 (0x25 - 0x1F)个字节，也就是6个字节。
第七列(col4)的长度就是 (0x2B - 0x25)个字节，也就是6个字节。



### 记录头信息（record header）

不同于Compact行格式，Redundant行格式中的记录头信息固定用`6个字节`（48位），每位的含义如下表：

![image-20240406150025207](.\images\image-20240406150025207.png)

* 与Compact行格式的记录头信息对比来看，有两处不同：

  * Redundant行格式多了n_field和1byte_offs_flag这两个属性。
  
  * Redundant行格式没有record_type这个属性。

其中，n_fields：代表一行中列的数量，占用10位，这也很好地解释了为什么MySQL一个行支持最多的列为1023。另一个值为1byte_offs_flags，该值定义了偏移列表占用1个字节还是2个字节。当它的值为1时，表明使用1个字节存储。当它的值为0时，表明使用2个字节存储。

* 1byte_offs_flag的值是怎么选择的

我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条Redundant行格式记录的真实数据占用的总大小来判断的：

* 当记录的真实数据占用的字节数值不大于127（十六进制0x7F，二进制01111111）时，每个列对应的偏移量占用1个字节。

* 当记录的真实数据占用的字节数大于127，但不大于32767（十六进制0x7FFF，二进制0111111111111111）时，每个列对应的偏移量占用2个字节。

有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前768个字节和20个字节的溢出页面地址。因为字段长度偏移列表处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。

大家可以看出来，Redundant行格式还是比较简单粗暴的，直接使用整个记录的真实数据长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了）。

为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，Redundant行格式特意在`记录头信息`里放置了一个称之为1byte_offs_flag的属性：

* Redundant行格式中NULL值的处理

因为Redundant行格式并没有NULL值列表，所以Redundant行格式在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为NULL的依据，该比特位也可以被称之为NULL比特位。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1。如果为1，那么该列的值就是NULL，否则不是NULL。
这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制0x7F，二进制01111111）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的NULL比特位，用来标记该列的值是否为NULL。
但是还有一点要注意，对于值为NULL的列来说，该列的类型是否为定长类型决定了NULL值的实际存储方式，我们接下来分析一下record_test_table表的第二条记录，它对应的字段长度偏移列表如下：

A4 A4 1A 17 13 0C 06
按照列的顺序排放就是：

06 0C 13 17 1A A4 A4

我们分情况看一下：
如果存储NULL值的字段是定长类型的，比方说`CHAR(M)`数据类型的，则NULL值也将占用记录的真实数据部分，并把该字段对应的数据使用0x00字节填充。
如图第二条记录的c3列的值是NULL，而c3列的类型是`CHAR(10)`，占用记录的真实数据部分10字节，所以我们看到在Redundant行格式中使用0x00000000000000000000来表示NULL值。

另外，c3列对应的偏移量为0xA4，它对应的二进制实际是：10100100，可以看到最高位为1，意味着该列的值是NULL。将最高位去掉后的值变成了0100100，对应的十进制值为36，而c2列对应的偏移量为0x1A，也就是十进制的26。36 - 26 = 10，也就是说最终c3列占用的存储空间为10个字节。
如果该存储NULL值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间。

比如record_test_table表的c4列是VARCHAR(10)类型的，VARCHAR(10)是一个变长数据类型，c4列对应的偏移量为0xA4，与c3列对应的偏移量相同，这也就意味着它的值也为NULL，将0xA4的最高位去掉后对应的十进制值也是36，36 - 36 = 0，也就意味着c4列本身不占用任何记录的实际数据处的空间。

除了以上的几点之外，Redundant行格式和Compact行格式还是大致相同的。





# 四、区、段和碎片区

## 1、为什么要有区？

我们查询底层数据的时候，从磁盘中读取数据，是以页为单位进行I/O操作的。

如果出现下面这种情况，要去查询5<=id<=30的数据，此时可能需要将相邻的三个页中的数据都读取到内存中。由于页与页之间是双向链表的关系，是逻辑上的相邻，不是物理上的相邻，实际上这些页在物理磁盘上离得很远，此时，我们要读取页时，就需要在物理磁盘上`寻道和半圈旋转`，将这三个页传输到数据库缓冲池中，所花费的时间资源就非常多。

我们把上述的情况称为**`随机I/O`**。随机I/O是非常慢的。所以我们应该尽量让链表中相邻的页实际的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的**`顺序I/O`**。

所以，**我们在存放页的时候，要尽量让页在物理磁盘上，也能够按照逻辑上的顺序存放，这样一来，就能够减少随机I/O的次数**。

这个时候，就要引入**`区`**的概念，**一个区就是在物理位置上连续的64个页**。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=**`1MB`**。**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是`按照区为单位分配`**，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区，虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是可以消除很多随机I/O。

这样我们以区为单位进行I/O时，由于逻辑上相邻的页，在物理上也尽量相邻，此时如果我们要去使用相邻的页，这个时候就可以消除很多随机I/O。



## 2、为什么要有段？

我们进行I/O的时候读取区到内存中，区中存放的是B+树的页，这些页有可能是叶子节点，也有可能是非叶子节点。

而对于范围查询来说，其实就是对B+树中的节点进行顺序扫描，如果在区中不区分叶子节点和非叶子节点，比如要查询的内容包括叶子节点中的5个页面，但是由于区中只能包含4个页面，并且区中已经有了一个非叶子节点，此时第5个叶子节点就需要放在另一个区中，这对效率就会产生影响。

所以：

**InnoDB对B+树中的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。**

那么，称这些区的集合为一个**`段`（segment）**。**段是逻辑上的概念**。存放叶子节点的区集合是一个段，存放非叶子节点的区也是一个段。也就是说，一个索引会生成两个段，一个`叶子节点段`，一个`非叶子节点段`。

除了索引的叶子节点段和非叶子节点段，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有**`数据段`**、**`索引段`**、**`回滚段`**。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。

在InnoDB存储引擎中，对段的管理都是由存储引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。

**段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。**



## 3、为什么要有碎片区？

默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引（其他普通索引需要自己去创建），一个索引会生成两个段（一个叶子节点段，一个非叶子节点段），而段是以区为单位申请存储空间的，一个区默认占用1MB存储空间，所以**默认情况下一个只存了几条记录的小表也要2MB的存储空间吗？**以后每次添加一个索引都要多申请2MB的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。

为了考虑以完整的区为单位分配给某个段对于`数据量较小`的表太浪费存储空间的这种情况，InnoDB提出了一个**`碎片（fragment）区`**的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如碎片区中存储的有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。**`碎片区直属于表空间`**，并不属于任何一个段。

所以此后为某个段分配存储空间的策略是这样的：

* 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间。
* 当某个段已经占用了`32个碎片区页面`之后，就会申请以完整的区为单位来分配存储空间。

即：当我们去创建索引的时候，索引中的页面一开始是存放在碎片区里面，当继续往其中添加数据，直到占用了碎片区中32个页面时，就会去申请以完整的区去存储。

所以，现在段不能仅定义为是某些区的集合，更精确的应该是`某些零散的页面`以及`一些完整的区`的集合，某些索引中的页面没有占用到32个碎片区页面，也就没有以完整的区去存放，但此时也是属于段的。



## 4、区的分类

区大体上可以分为4种类型：

* **`空闲的区（FREE）`**：现在还没有用到这个区中的任何页面
* **`有剩余空间的碎片区（FREE_FRAG）`**：表示碎片区中还有可用的页面。
* **`没有剩余空间的碎片区（FULL_FRAG）`**：表示碎片区中所有页面都被使用，没有空闲页面。
* **`附属于某个段的区（FSEG）`**：每一个索引都可以分为叶子节点段和非叶子节点段。

处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，直属于表空间。而处于FSEG状态的区是附属于某个段的。

> 如果把表空间比作是一个集团军，段相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于FSEG的区全都隶属于某个段，而处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。

## 5、表空间

表空间可以看做是InnoDB存储引擎结构的最高层，所有的数据都存放在表空间中。

表空间是一个**`逻辑容器`**，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、独立表空间、撤销表空间和临时表空间等。

### 1、独立表空间

独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即：单表）可以在不同的数据库之间进行`迁移`。

空间可以回收（DROP TABLE操作可自己回收表空间，其他情况，表空间不能自己回收）。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine = innodb;回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。

**`独立表空间`**

独立表空间由段、区、页组成。

**`真实表空间对应的文件大小`**

我们到数据目录里看，会发现一个新建的表对应的.ibd 文件只占用了`96K`，才6个页面大小(MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些ibd文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。

> mysql 8.0之后，.frm文件和.ibd文件已经合并，新建一个表对应是7个页的大小。

**`查看InnoDB的表空间类型：`**

查看是否使用了独立表空间：

```sql
show variables like 'innodb_file_per_table';
```

![image-20240407003422712](.\images\image-20240407003422712.png)

可以看到innodb_file_per_table=ON，这就意味着每张表都会单独保存为一个.ibd文件。

### 2、系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。

**`InnoDB数据字典`**
每当我们向一个表中插入一条记录的时候，MySQL校验过程 如下
先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说:

> \- 某个表属于哪个表空间，表里边有多少列
> \- 表对应的每一个列的类型是什么
> \- 该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面
>
> \- 该表有哪些外键，外键对应哪个表的哪些列
> \- 某个表空间对应文件系统上文件路径是什么
>
> ......

上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为 **元数据**。lnnoDB存储引擎特意定义了一些列的 **内部系统表 (internalsystem table)**来记录这些这些元数据:

![img](.\images\9ba5edb460c44e369a05d05cf312e51c.png)

这些系统表也被称为 数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中 SYS_TABLES   SYS_COLUMNS  SYS_INDEXES   SYS_FIELDS 这四个表尤其重要，称之为基本系统表 (basic system tables)。

注意:用户是不能直接访问 innoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库**`information_schema`**中提供了一些以innodb_sys 开头的表:
![img](.\images\88077b4ab0ef4438ac7914a4658d47a9.png)

 在**`information_schema`**数据库中的这些以`INNODB_SYS`开头的表并不是真正的内部系统表(内部系统表就是上边以`SYS`开头的那些表)，而是在存储引擎启动时读取这些以 SYS 开头的系统表，然后填充到这些以INNODB_SYS 开头的表中。以INNODB_SYS 开头的表和以SYS 开头的表中的字段并不完全一样，但供大家参考已经足矣。




# 附录：数据页加载的三种方式

InnoDB从磁盘中读取数据的**`最小单位`**是数据页。而你想得到的id=xxx的数据，就是这个数据页众多行中的一行。在磁盘等物理从层面而言是按**数据页**形式进行存放的，当期加载到MySQL中我们称之为**缓存页**。

如果缓冲池中没有该页数据，那么缓冲池中有以下三种读取数据的方式，每种方式的读取效率都是不同的。



## 1、内存读取

如果该数据存在于内存中，基本上执行时间在1ms左右，效率还是很高的。

![img](.\images\3b8bcc4603144aa79bd29fe080dbf044.png)



## 2、随机读取

如果数据没有在内存中，就需要在磁盘上对该页进行查找。对于一个页面来说，整体时间预计在10ms左右，其中有6ms是磁盘的实际繁忙时间（包括了寻道和半圈旋转时间），有3ms是对可能发生的排队时间的估计值，另外还有1ms的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区。这10ms看起来很快，实际上对于数据库来说消耗的时间非常长了，因为这还只是一个页的读取时间。

假如要读取多个页，并且这些页实际物理存储在不同的区域，这个时候就只能使用随机读取，去一个一个地寻找这些页读取到内存中。

![img](.\images\3e238a7357cd4108a69df0bf53d44c05.png)



## 3、顺序读取

顺序读取其实是一种批量读取的方式，因为我们请求的数据在物理磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘I/O操作了。

**区**就是这样诞生的，区存储了64个连续的页，这样一来，我们读取数据时，直接读取区到内存中，当我们要进行范围查询时，就可以直接对区中连续的页进行查询。

如果一个磁盘的吞吐量是40MB/s，那么对于一个16KB大小的页来说，一次性可以读取2560（40MB/16KB）个页，相当于每个页的读取时间为0.4ms。

采用批量读取的方式，即使是从磁盘上进行读取，效率也比内存中单独读取一个页的效率要高。





## 对SQL查询效率的总结

SQL查询是一个动态的过程，从页的加载角度看，我们可以得到以下两点结论：

1. **`位置决定效率`**。如果页就在数据库`缓冲池`中，那么效率是最高的，否则还需要从`内存`或者`磁盘`中读取，当然针对于单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
2. **`批量决定效率`**。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率效率就会提升很多，甚至要快于单个页面在内存中随机读取。

我们要先考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

