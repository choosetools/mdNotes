# 逻辑架构与SQL执行流程剖析

### 服务器处理客户端请求

首先MySQL是典型的C/S架构，即`Client/Server架构`，服务器端程序使用的**`mysqld`**。

不论客户端进程和服务器进程是采用哪种方式进行通信的，最后实现的效果都是：**客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）**。

来看看MySQL架构图：

![image-20240329095013173](.\images\image-20240329095013173.png)

MySQL最重要、最与众不同的特性是它的**`存储引擎架构`**，这种架构将：**查询处理、其他系统任务、数据的存储与提取**三部分分离。所以，带来的好处就是可以在使用时**根据性能、特性，以及其他需求来选择数据存储方式**。

MySQL逻辑架构自上而下分为三层：

1. **连接层**
2. **服务层**
3. **存储引擎层**



## 三层逻辑架构

### 1、连接层

主要工作是：**连接处理、授权认证、安全防护等**。

系统（客户端）访问MySQL服务器之前，做的第一件事就是建立**`TCP`**连接。

经过三次握手建立连接成功后，**`MySQL`**服务器对`TCP`传输过来的账号密码做身份认证、权限获取。

* **`用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行。`**
* **`用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限。`**

`TCP`连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个**线程池**，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。

### 2、服务层server

服务层用于**处理核心服务**，如标准的SQL接口，并完成`缓存的查询`，SQL分析和优化、全局的和引擎依赖的缓存与缓冲器等等，所有的与存储引擎无关的工作，如过程、函数等，都会在这一层来处理。

在该层上，服务器会`解析查询`并创建相应的内部`解析树`，并对其完成`优化`，如确定查询表的顺序，是否利用索引等。最后生成相关的执行操作。

如果是SELECT语句，服务器还会`查询内部的缓存`。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。



### 3、存储引擎层

存储引擎层，存储引擎负责实际的**MySQL数据的存储与提取，服务器通过API与存储引擎进行通信**。不同的存储引擎功能和特性有所不同，这样可以根据实际需要有针对性的使用不同的存储引擎。

其架构模式是**`插件式`**的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine=memory，来制定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。

不同的存储引擎共有一个**服务层**，也就是从连接器到执行器的部分。现在，我们来讲讲这一部分每个组件的作用。



**小结：**

![image-20240329171234283](.\images\image-20240329171234283.png)

简化为三层结构：

1. 连接层：客户端和服务器端建立连接，客户端发送SQL至服务器端。
2. SQL层（服务层）：对SQL语句进行查询处理；与数据库文件的存储方式无关。
3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。





## 体系结构

对上述三个层次进行展开，就是MySQL的**`体系结构`**：

![img](.\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6YjM0ODExMDE3NQ==,size_16,color_FFFFFF,t_70)

**体系介绍：**

> **Client Connectors**
>
> 接入方。支持很多协议（JDBC、ODBC、.NET、PHP、Python、PERL、C等）
>
> 
>
> **Management Serveices & Utilities**
>
> 系统管理和控制工具，mysqldump、mysql复制集群、分区管理等
> 
>
> **Connection Pool**
>
> 连接池：管理缓冲用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求
>
> 
>
> **SQL Interface**
>
> SQL接口：接收用户的SQl命令，并且返回用户需要查询的结果
>
> 
>
> **Parser**
>
> 解析器，SQL命令传递到解析器的时候会被解析器验证和解析
>
> 
>
> **Optimizer**
>
> 查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化
>
> 
>
> **Cache和Buffer（高速缓存区）**
>
> 查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据
>
> 
>
> **pluggable storage Engines**
>
> 插件式存储引擎。存储引擎是MySQL中具体的与文件打交道的子系统
>
> 
>
> **File System**
>
> 文件系统，数据、日志（redo、undo）、索引、错误日志、查询记录、慢查询等。





## SQL执行顺序

![image-20240329171143020](.\images\image-20240329171143020.png)

### 连接器

第一步，你会先连接到这个数据库上，这个时候需要使用到的就是连接器。连接器的作用是与客户端建立连接、获取权限、维持和管理连接。连接命令是：

```shell
mysql -u$user -P$port -h$ip -p
```

输入完命令后，就需要在交互对话中输入密码。

连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的**`TCP`**握手后，连接器就要开始认证身份，这个时候会去验证输入的用户名和密码。

* 如果用户名或密码不对，报"`Access denied for user`"错误，客户端结束执行。
* 如果用户密码认证通过，连接器会到权限表里面查询所拥有的权限。之后，都将依赖于此时读取到的权限来判断。

所以，**`用户是否有权限，是根据登录时读取到的权限信息`**。

这也就意味着，一个用户成功建立连接之后，即便对这个用户的权限进行了修改，也不会影响到已经存在的连接。修改完成后，只有再建立新的连接才会使用新的权限设置。

连接完成后，如果没有后续的动作，连接就处于空闲状态，可以在`show processlist`命令中看到。文本中这个图是show processlist的结果，其中Command列显示为Sleep这一行，就表示现在系统里面有一个空闲连接。

![image-20240329145216756](.\images\image-20240329145216756.png)

客户端如果一直不使用，连接器就会自动断开。这个时间是由参数**`wait_timmeout`**控制的，默认是8个小时。在连接断开后，客户端再次发送请求的话，就会收到错误提醒：`Lost connection to MySQL server during query`。此时就需要进行重连了。

**长连接与短连接**

长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个链接。

短连接是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

建立连接的过程通常是比较复杂的，所以建立在使用时要尽量减少连接的动作，也就是尽量使用长连接。

但是全部使用长连接后，有时候MySQL会非常占用内存，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的，有些资源是需要在断开连接的时候才会释放，长时间积累下来导致内存占用太大，导致出现OOM（Out of memory）异常，从现象看就是MySQL异常重启了。

该如何解决呢？

1. 定期断开长连接。
2. 如果使用的是MySQL5.7或更高版本，在执行完一个较大操作后，通过执行`mysql_reset_connnection`来重新初始化连接资源。这个过程不需要重连和重新做版本验证，但是会将连接恢复到刚刚创建完的状态。



### 查询缓存

建立完连接后，就可以执行SQL语句了。执行逻辑就会来到第二步：查询缓存。

MySQL拿到一个查询请求后，会先到查询缓存中看看，之前是不是执行过这条语句。之前执行过的语句以及结果可能会以key-value对的形式，直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入到查询缓存中。可以看到，如果查询命中缓存，MySQL不需要执行后买你的复杂操作，就直接返回结果，效率会很高。

但是，**大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利**。

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能将缓存结果积累了，还没使用，就被更新一次性情况了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非有业务是一张静态表，很长时间才更新一次，比如系统配置表，这张表上的查询才适合使用查询缓存。

MySQL提供"按需使用"的方式：

可以将参数`query_cache_type`设置成**`DEMAND`**，这样对于默认的SQL语句都不使用查询缓存，而对于确定需要使用的缓存语句，可以使用`SQL_CACHE`显式指定，例如：

```sql
select SQL_CACHE * FROM T WHERE ID=10;
```

上面的含义是，将select * from T where ID=10;这一段SQL语句放入缓存中。

需要注意的是，**MySQL8.0不再支持查询缓存的功能**。



### 解析器

如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要你要做什么，因此需要对SQL语句进行解析。

分析器先会做"**`词法分析`**"。MySQL需要识别SQL语句里面的字符串分别是什么，代表什么含义。

例如：SELECT * FROM T WHERE ID=10;

MySQL从输入的select关键字识别出来，这是一个查询语句，把字符串T识别为“表名T”，把字符串ID识别为“列ID”。

做完这些识别后，就要做"**`语法分析`**"。根据词法分析的结果，语法分析会根据语法规则，判断输入的SQL语句是否满足MySQL语法。

如果SQL语句不正确，就会收到：`You have an error in your SQL syntax`的错误提醒。例如：

```sql
mysql> elect * from t where ID=1;

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```

一般语法错误会提示第一个出现错误的位置，所以需要关注的是"use near"的内容。

如果SQL语句正确，则会生成一个**`语法树`**，例如：

![image-20240329153959749](.\images\image-20240329153959749.png)



### 优化器

经过了分析器，MySQL知道要做什么了，在开始执行之前，还需要经过优化器的处理。

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如执行下面的语句，这个语句是执行两个表的join：

```sql
select * from test1 join test2 using(ID) 
where test1.name='zhangwei' and test2.name='mysql高级课程';
```

```tex
方案1：可以先从表 test1 里面取出 name='zhangwei'的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的值是否等于 'mysql高级课程'。
方案2：可以先从表 test2 里面取出 name='mysql高级课程' 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name的值是否等于 zhangwei。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。
```

在查询优化器中，可以分为**`逻辑查询`**优化阶段和**`物理查询`**优化阶段。



### 执行器

MySQL通过解析器知道了要做什么，通过优化器知道了该怎么做，现在就进入到执行器阶段，开始执行语句。

在执行之前需要判断该用户是否**`具备权限`**。如果没有，就会返回权限错误。

如果有权限，就打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口。

例如：

```sql
SELECT * from T where ID = 10;
```

在这个例子的表T中，ID字段假如没有索引，那么执行器的流程是这样的：

1. 调用Innodb引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行；
3. 执行器将上述遍历过程中所有满足条件的行组成的记录作为结果集返回给客户端。

至此，这个语句就执行完毕。如果ID字段有索引，执行的逻辑也差不多。



**总结：**
SQL语句在MySQL中的流程是：**`SQL语句 -> 查询缓存 -> 解析器 -> 优化器 -> 执行器`**。

![image-20240329171115867](.\images\image-20240329171115867.png)



### MySQL8.0中SQL执行流程演示

**首先**，我们去确认一下profiling是否开启。

```sql
select @@profiling;

show variables like 'profiling';
```

profiling的值为1时，表示记录SQL执行的各个环节。

profiling=0时表示关闭，我们需要把profiling打开，即设置为1.

```sql
set profiling = 1;
```

**之后**，我们去多次执行同一个SQL查询：

```sql
select * from employees;
```

**然后**，去查看当前会话执行的所有查询操作：

```sql
show profiles; #显示当前会话最近的几次查询操作
```

![image-20240402083214399](.\images\image-20240402083214399.png)

**最后**，我们去查看查询操作的执行计划

```sql
show profile; #表示查看最近一次查询的执行步骤
```

![image-20240402083629112](.\images\image-20240402083629112.png)

上面的结果表示的就是第8次查询的执行计划

当然也可以查询指定的Query ID，比如：

```sql
show profile for query 8;
```

我们继续查看query 2查询操作的执行步骤：

```sql
show profile for query 7;
```

![image-20240402083858832](.\images\image-20240402083858832.png)

可以看到，query8和query7都是select * from employees;操作，且步骤都是17步，即query7并没有产生缓存，都是执行完全部的SQL流程。**`MySQL8.0是不支持缓存的`**。





### MySQL5.7中SQL执行流程演示

**首先**，我们先去MySQL5.7中`开启查询缓存模式`，在如下设置：

在配置文件/etc/my.cnf中新增一行，表示开启查询缓存

```shell
query_cache_type=1
```

重启mysql服务

```shell
systemctl restart mysqld
```



**然后**，去开启查询执行计划，记录查询过程

```sql
mysql> set profiling = 1;
```



**之后**，执行select语句两次：

```sql
mysql> select * from employees;

mysql> select * from employees;
```

查看执行过的query语句：

```sql
show profiles;
```

![image-20240402085526633](.\images\image-20240402085526633.png)



**最后**，我们去分别查看一下query7和query6的执行过程：
query7:

```sql
show profile for query 7;
```

![image-20240402085630554](.\images\image-20240402085630554.png)

query 6：

```sql
show profile for query 6;
```

![image-20240402085654281](.\images\image-20240402085654281.png)

我们可以看到，第7次查询和第6次查询执行的是一样的语句，但是执行步骤要少得多。原因就在于，第7次查询是直接从缓存中换取数据的。



**注意：**

1. **`SQL必须是一致的，否则不能命中缓存。`**

2. **同样的开启缓存配置如果在MySQL8.0中添加，在重启服务时会发生错误。原因在MySQL8.0中是不存在`query_cache_type`参数的。**





# 数据库缓冲池

> MySQL的所有数据最终都会存储到磁盘，但是为了加快数据的查询，MySQL在内存中有一个组件，叫做数据库**缓冲池（Buffer Pool）**，当我们要修改某条数据时，会先查询缓冲池中这条数据是否存在，如果不存在，则将这条数据从磁盘加载到缓冲池中，并对它加锁，防止其他事务的修改，然后再进行下一步。
>
> 修改的操作也是在内存中进行的，先对内存中的数据进行修改，当事务提交之后，再将数据刷到磁盘中。

Innodb存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。如果是通过磁盘I/O的访问读取会消耗很多时间，而在内存中进行操作的话，效率会高很多。为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请**`占用内存来作为数据缓冲池`**，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。

简单来说，就是将磁盘中的数据缓存在内存中，让cpu执行操作，而缓存在内存中的数据，就是**数据库缓冲池**。

目的就是为了**`减少与磁盘直接进行I/O的时间`**。这种策略对提升SQL语句的查询性能来说至关重要。如果索引的数据在缓冲池中，那么访问的成本就会降低很多。



## 缓冲池 VS 查询缓存

**`缓冲池和查询缓存是一个东西吗？不是`**

### 1、缓冲池（Buffer Pool）

首先，我们需要在Innodb存储引擎中，缓冲池都包括了哪些。

在Innodb存储引擎中有一部分数据放到内存中，缓冲池则占了这部分内存的大部分，引用来存储各种数据的缓存，如下图所示：

![image-20240402093454206](.\images\image-20240402093454206.png)

从图中，你能看到Innodb缓冲池包括了数据页、索引页、插入缓存、锁信息、自适应Hash和数据字典信息等。

**`缓冲池的重要性：`**

对于使用Innodb作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以**`页`**的形式存放在**`表空间`**中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度很慢，CPU速度很快，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以，Innodb存储引擎在处理客户端请求时，当需要访问某个页的数据时，会将`完整的页的数据全部加载到内存`中，也就是说即便我们只需要访问一个页的一条记录，也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完整读写访问之后并不着急把该页对应的内存空间释放掉，而是将其`缓存`起来，这样一来，之后再次访问该页面时，就可以省去**`磁盘IO`**的开销了。

**`缓存原则：`**

**`位置 * 频次`**这个原则，可以帮助我们对I/O访问效率进行优化。

首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。

其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有200G，内存只有16G，缓冲池大小只有1G，就无法将所有的数据都加载到缓冲池里，这就涉及到优先级顺序，会`优先对使用频次高的热数据进行加载`。

**`缓冲池的预读特性：`**

了解了缓冲池的作用后，我们还需要了解缓冲池的另一个特性：`预读`。

缓冲池的作用就是提升I/O效率，而我们进行读取数据的数据存在一个“局部性原理”。也就是我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”机制提前加载，可以减少未来可能的磁盘I/O操作。

## 查询缓存

那什么是查询缓存呢？

查询缓存是提前把`查询结果缓存`起来。这样下次不需要执行就可以直接拿到结果。需要注意的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就失效了，因此命中率低。



## 缓冲池如何读取数据

缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。

缓存在数据库中的结构和作用如下图所示：

![image-20240402095305063](.\images\image-20240402095305063.png)

**如果我们执行SQL语句的时候更新了缓冲池中的数据，那么这些数据会马上同步到磁盘上吗？**

实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以**`一定频率刷新`**到磁盘上。注意并不是每次发生更新操作，就会立刻进行磁盘回写。缓冲池会采用一种叫做**`checkpoint的机制`**将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。

比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的页写回到磁盘上，然后再将缓冲池这些页释放掉。这里脏页（dirty page）指的是缓冲池中被修改的页，与磁盘上的数据页不一致。



## 查看/设置缓冲池的大小

如果使用的是MySQL MyISAM存储引擎，只缓存索引，不缓存数据，对应的键缓存参数为`key_buffer_size`，可以用它来查看。

如果使用的是Innodb存储引擎，可以通过查看`innodb_buffer_pool_size`变量来查看缓冲池的大小，命令如下：

```sql
show variables like 'innodb_buffer_pool_size';
```

![image-20240402100656102](.\images\image-20240402100656102.png)

你能看到此时InnoDBD的缓冲池大小为134217728/1024/1024=128MB。可以去修改缓冲池大小，比如修改为256MB，方法如下：

```sql
set global innodb_buffer_pool_size = 268435456;
```

或者修改配置文件：

```
[server]
innodb_buffer_pool_size=268435456
```

之后重启sql服务。

然后再来查看以下修改后的缓冲池大小，此时已成功修改为256MB：

![image-20240402100939857](.\images\image-20240402100939857.png)





## 多个Buffer Pool实例

Buffer Pool本质是InnoDB向操作系统申请的一块`连续的内存空间`，在多线程环境下，访问Buffer Pool中的数据都需要`加锁`处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们`拆分成若干个小的Buffer Pool`，每个Buffer Pool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。

我们可以在服务器启动的时候通过设置**`innodb_buffer_pool_instances`**的值来修改Buffer Pool的实例个数，比如说这样：

```properties
[server]
innodb_buffer_pool_instances=2
```

这样就表明我们要创建2个`Buffer Pool`实例

我们看下如何查看缓冲池的个数，使用命令：

```sql
show variables like 'innodb_buffer_pool_instances';
```

![image-20240402102300842](.\images\image-20240402102300842.png)

那么每个Buffer Pool实例实际上占用多少内存空间呢？其实使用这个公式算出来的：

```
innodb_buffer_pool_size/innodb_buffer_pool_instances
```

也就是总共的大小除以实例的个数，结果就是每个`Buffer Pool`实例占用的大小。

不过也不是说Buffer Pool实例创建的越多越好，分别`管理各个Buffer Pool也是需要性能开销`的。InnoDB规定：当Innodb_buffer_pool_size的值小于1G的时候设置多个缓冲池实例是无效的，InnoDB会默认把innodb_buffer_pool_instances的值修改为1.



## 引申问题

Buffer Pool是MySQL内存中十分核心的一个组成，可以将其想象成一个黑盒子。

**`黑盒子下更新数据流程`**

当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在，存储引擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在Buffer Pool，同样会先把数据加载进来，然后修改内存的数据。被修改的数据会在之后统一刷入磁盘中。

![image-20240402103746450](.\images\image-20240402103746450.png)

这个过程看似没啥问题，实则是有问题的。假如我们修改Buffer Pool中的数据成功，但是还没有从内存中刷入磁盘，MySQL服务器就挂了怎么办？按照上面的逻辑，这个时候更新的数据只存在于Buffer Pool中，如果此时MySQL宕机，这部分数据就将永远丢失。

再比如，更新到一半突然发生了错误，想要回滚之前的数据该怎么办？

这个时候就需要使用到日志的内容：**`Redo Log & Undo Log`**
