# 这章SQL命令总结

##### **登录MySQL服务器**

```shell
mysql -h hostname|hostIP -P port -u username -p password DatabaseName -e "SQL语句"
```

### 与用户以及用户权限有关

##### **创建用户**

```sql
CREATE USER '用户名'[@'主机名'] [IDENTIFIED BY '密码'];
```

##### **删除用户**

```sql
DROP USER '用户名'@'主机名';
```

##### **修改当前用户的密码**

```sql
ALTER USER USER() IDENTIFIED BY 'new_password';
```

##### **修改其他用户的密码**

```sql
ALTER USER 'username'@'hostname' [IDENTIFIED BY 'new_password'];
```

##### **授予用户权限**

```sql
GRANT 权限1,权限2,...权限n ON 数据库名称.表名称 TO 用户名@主机名 [IDENTIFIED BY '密码'];
```

##### **查看用户权限**

```sql
SHOW GRANTS;

#查看其他用户的权限
SHOW GRANTS FOR 用户名[@主机名];
```

##### **收回用户权限**

```sql
REVOKE 权限1,权限2,...权限n ON 数据库名称.表名称 FROM 用户名@主机地址;
```



### 与角色以及角色权限有关

##### **创建角色**

```sql
CREATE ROLE 'role_name'[@'host_name'];
```

##### **赋予角色权限**

```sql
GRANT 权限 ON 数据库名.表名 TO 角色名[@'host_name'];
```

##### **查看角色权限**

```sql
SHOW GRANTS FOR 角色;
```

##### **回收角色权限**

```sql
REVOKE 权限 ON 数据库名.表名 FROM 角色名[@'host_name'];
```

##### **删除角色**

```sql
DROP ROLE 角色1[, 角色2...];
```

##### **赋予角色用户**

```sql
GRANT role TO user;
```

要使用户的角色有效，需要激活角色。

##### **激活角色**

方式一：激活指定用户拥有的所有角色

```sql
SET DEFAULT ROLE ALL TO 用户名[@主机名];
```

方式二：激活所有角色，设置角色默认为激活状态。

```sql
SET GLOBAL activate_all_roles_on_login=ON;
```

##### **撤销角色用户**

```sql
REVOKE 角色 FROM 用户;
```





# 一、用户管理

MySQL用户可以分为`普通用户`和`root用户`。root用户是超级管理员，拥有所有权限、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。

**`MySQL提供了许多语句用来管理用户账号`**，这些语句可以用来管理包括登录和退出MySQL服务器、创建用户、删除用户、密码管理和权限管理等内容。

**`MySQL数据库的安全性需要通过账户管理来保证。`**

## 1、登录MySQL服务器

启动MySQL服务器后，可以通过mysql命令来登录MySQL服务器，完整的命令如下：

```shell
mysql -h hostname|hostIP -P port -u username -p password DatabaseName -e "SQL语句"
```

注意：-h、-P、-u、-e以及-p与后面的参数之间的空格，可加可不加。

下面介绍一下命令中的参数：

* **`-h`**：后面接主机名或者主机IP，hostname为主机，hostIP为主机IP，若不写默认是localhost。
* **`-P`**：后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。
* **`-u`**：后面接用户名，username为用户名。
* **`-p`**：后面可以跟着密码（不安全），也可以不写回车后再输入。
* **`DatabaseName`**：指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。
* **`-e`**：后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。

举例：

```shell
mysql -uroot -p -hlocalhost -P3306 mysql -e "select host, user from user"
```

这一个命令表示的是：使用root用户，连接到本机地址端口号为3306的mysql数据库中，数据库名为mysql，并且执行select host,user from user命令后退出MySQL服务器。

一般来说，我们只需要使用：

```sql
mysql -uroot -p
```

即可。表示使用root用户登录到localhost的3306端口的mysql数据库中。



## 2、创建用户create user

在MySQL数据库中，官方推荐使用**`CREATE USER`**语句来创建新用户。MySQL8版本溢出了PASSWORD加密方法，因此不再推荐使用INSERT语句直接操作MySQL中的user表来增加用户。

使用CREATE USER语句来创建新用户时，**`必须拥有CREATE USER权限`**。每添加一个用户，CREATE USER语句会在mysql.user表中添加一条新记录，但是**`创建的用户没有任何权限`**。如果添加的账户已经存在，CREATE USER语句就会返回一个错误。

CREATE USER语句的**基本语法**形式如下：

```sql
CREATE USER '用户名'[@'主机名'] [IDENTIFIED BY '密码'][,'用户名'[@'主机名'] [IDENTIFIED BY '密码']];
```

* 用户参数表示新建用户的账户，由`用户名（User）`和`主机名（Host）构`成；
* CREATE USER语句可以同时创建多个用户。



**案例：**

创建一个用户cheng，密码是061535asd，主机名为%

```sql
#默认host是%
create user 'cheng' identified by '061535asd';
```

这样一来，我们就创建了cheng这个用户。用户的信息存放在mysql数据库下的user表中。我们可以通过下面的方式来查看数据库中的所有用户：

```sql
select host, user from user;
```

<img src=".\images\image-20240327141732083.png" align="left">

其中，创建出来的cheng用户，host属性为%，表示的含义是可以使用任意地址信息登入；另外三个mysql.用户是系统自带的用户，其host属性均为localhost，表示的含义是只允许本地地址登录访问。

那我们还想去创建一个host为localhost的cheng用户可以吗？让我们测试一下

```sql
create user 'cheng'@'localhost' identified by '061535asd';
```

执行之后，发现居然创建成功了，我们去看一下user表中的数据：

<img src=".\images\image-20240327142325487.png" align="left">

发现现在有两个叫做cheng的用户了。

实际上，第一个cheng用户表示的是可以在任意地址登录访问的cheng。

第二个cheng用户表示的是在本机地址登录访问的cheng。

所以，我们可以得出一个结论：

> **MySQL数据库中，可以创建同名但不同主机名的用户。**





## 3、修改用户名（使用的很少）

**修改用户名**

例如：将只允许本机登录的cheng用户名修改为chengjiawei

```sql
#修改用户名
UPDATE mysql.user set user='chengjiawei' where user='cheng' and host = 'localhost';


#刷新，提交
flush privileges;
```

![image-20240327143919856](.\images\image-20240327143919856.png)

刷新之后，原本的cheng本机用户就被修改了用户名，变为了chengjiawei。



## 4、删除用户drop

#### 方式一：使用DROP方式删除（推荐）

**格式：**

```sql
DROP USER '用户名'@'主机名';
```

由于可能存在多个同名的用户，所以在删除用户的时候，不仅仅需要指明用户的用户名，还需要指明用户的主机名。举例：

```sql
DROP USER 'kangshifu'@'localhost';
```

注意：当有多个重名的用户，用户的主机名不一致时，使用DROP方式删除未指明主机名，则默认删除主机名为%的用户，即删除的是可以在任意地址登录的用户。

> **`在将用户账户从user表删除之前，应该收回用户的所有权限。`**

例如：

```sql
DROP USER 'cheng';
```

删除的就是host属性为%的cheng用户。



#### 方式二：使用DELETE方式删除（不推荐）

可以使用DELETE语句直接将用户的信息从mysql.user表中删除，但必须拥有对mysql.user表的DELETE权限。

DELETE语句的**基本语法**形式如下：

```sql
DELETE FROM mysql.user WHERE Host = 'hostname' AND User = 'username';
```

Host字段和User字段是user表的联合主键，因此两个字段的值才能唯一确定一条记录。

执行完DELETE命令后要使用FLUSH命令来使用户生效，命令如下：

```sql
flush privileges;
```

举例：

删除用户cheng，cheng的主机名为localhost

```sql
DELETE FROM mysql.user WHERE Host = 'localhost' AND User = 'cheng';

flush privileges;
```



> **注意：**
>
> 不推荐通过使用DELETE的方式删除用户，系统会有残留信息保留。而DROP USER命令会删除用户以及对应的权限，执行命令后会发现mysql.user表和mysql.db表中相应的记录都会被删除。
>
> 所以，推荐使用DROP USER来删除用户信息。



## 5、修改当前用户密码

使用`ALTER USER`修改用户密码是MySQL官方推荐的方式，此外，也可以通过`SET`语句修改密码。由于MySQL8中已经移除了PASSWORD()函数，因此不再使用UPDATE语句直接操作用户表修改密码。

1. **`使用ALTER USER密码修改当前用户密码`** 用户可以使用ALTER命令来修改自身密码，如下语句代表修改当前登录用户的密码。基本语法如下：

   ```sql
   ALTER USER USER() IDENTIFIED BY 'new_password';
   ```

   

2. **`使用SET语句来修改当前用户密码`** 

   ```sql
   SET PASSWORD = 'new_password';
   ```

   

## 6、修改其他用户密码

可以通过`ALTER语句`和`SET语句`来修改普通用户的密码。由于PASSWORD()函数已移除，因此使用UPDATE直接操作用户表的方式已不再使用。

**`1.使用ALTER语句来修改普通用户的密码`**

可以使用ALTER USER来修改普通用户的密码。

**基本语法形式如下：**

```sql
ALTER USER 'username'@'hostname' [IDENTIFIED BY 'new_password'][, 'username'@'hostname' [IDENTIFIED BY 'new_password']...];
```

例如：修改kangshifu用户的密码，将其改为"HelloWorld_123".

```sql
ALTER USER 'kangshifu'@'localhost' IDENTIFIED BY 'HelloWorld_123';
```



**`2.使用SET命令来修改普通用户的密码`**

使用root用户登录到MySQL服务器后，可以使用SET语句来修改普通用户的密码。

**SET语句的代码如下：**

```sql
SET PASSWORD FOR 'username'@'hostname' = 'new_password';
```

其中，username是普通用户的用户名，hostname是普通用户的主机名，new_password是新密码。

例如：修改kangshifu用户的密码，将其改为"HelloWorld_123".

```sql
SET PASSWORD FOR 'kangshifu'@'localhost' = 'HelloWorld_123';
```



**`3、使用UPDATE语句修改普通用户的密码（不推荐使用）`**

语法：

```sql
UPDATE MySQL.user SET authentication_string = PASSWORD("123456") WHERE Uer = 'username' AND Host = 'hostname';
```

这种方式不适用于MySQL8.0，因为不支持PASSWORD()函数。

执行完UPDATE语句后，需要执行`FLUSH PRIVILEGES`语句进行刷新。





# 二、权限管理与访问控制

关于MySQL的权限简单的理解就是MySQL允许你做权利以内的事情，不可以越界。比如只允许执行SELECT操作，那就不能执行UPDATE操作。只允许从某台机器上连接MySQL，就不能从除那台机器以外的机器连接MySQL。

## 1、权限管理

### 1.1、权限列表

MySQL有哪些权限？

```sql
SHOW PRIVILEGES;
```

![image-20240328113714419](.\images\image-20240328113714419.png)

查出来一共有62个权限，这些权限还可以分为**三种权限**：

| 权限分布 | 可能设置的权限                                               |
| -------- | ------------------------------------------------------------ |
| 表权限   | select, insert, update, delete, create, drop, grant, references, index, alter |
| 列权限   | select, insert, update, references                           |
| 过程权限 | execute, alter routine, grant                                |

### 1.2、权限授予的原则

权限控制主要是出于安全因素，因此需要遵循以下几个`经验原则`：

1. 只授予能`满足需要的最小权限`，防止用户做错事。比如用户只需要查询，那就只给select权限即可，不要给用户赋予update、insert权限。
2. 创建用户时候，`限制用户的登录主机`，一般是限制成指定IP或者内网IP段。
3. 为每个用户`设置满足密码复杂度的密码`。
4. `定期清理不需要的用户`，回收权限或删除用户。



### 1.3、授予权限 grant

> 给用户授予权限的方式有两种，分别是**`通过把角色赋予用户给用户授权`**和**`直接给用户授权`**。

用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。

**`授权命令：`**

```sql
GRANT 权限1,权限2,...权限n ON 数据库名称.表名称 TO 用户名@主机名;
```

我们在开发中，如果想给一个用户除了grant（授权）的权限以外，其他所有的权限，可以使用下面的SQL命令实现：

**授予用户所有库所有表的全部权限：**

```sql
GRANT ALL PRIVILEGES ON *.* TO 用户名@主机名;
```

**注意！注意！注意！**

在授予权限时，千万不要再加上[IDENTIFIED BY '密码']设置密码了，因为若加上密码相当于是创建用户并且授予权限的语法，而若原本用户以及存在，则会报错。在一般情况下，都是先使用CREATE方法创建用户，然后再使用GRANT语法授予权限，所以在授予权限时不要加上[IDENTIFIED BY '密码']语句了。

**说明：**

* 这里的全部权限唯独不包括`grant`权限。这里的`ALL PRIVILEGES`表示所有的权限。这里的`*`表示所有的意思。
* 如果授权时，未发现有该用户，则会直接去创建一个用户。

* `ON`用来指定权限针对哪些库和表，授予的权限针对的是某表的授权，我们要去指定数据库和表名。
* `TO`表示将权限赋予某个用户。
* 如果需要赋予包括GRANT的权限，添加参数"`WITH GRANT OPTION`"这个选项即可，表示该用户可以将自己拥有的权限授权给别人。经常有人在创建操作用户的时候不指定`WITH GRANT OPTION`选项导致该用户不能使用GRANT命令给其他用户授权。
* 可以使用GRANT重复给用户添加权限，`权限叠加`，比如先给用户添加了一个SELECT权限，然后又给用户添加一个INSERT权限，该用户就拥有了SELECT和INSERT权限，而不是权限覆盖。

> 我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。
>
> * 所谓的横向分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；
> * 所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改、能删除。



---

**案例1：**

新创建了一个用户cheng，我们在root用户下查看该用户的信息：

```sql
create user 'cheng'@'%' identified by '061535asd';
```

<img src=".\images\image-20240328115723215.png" align="left">

此时，我们去登录cheng用户，然后在该用户下查看所有的数据库：

<img src=".\images\image-20240328115758088.png" align="left">

发现只能看到一个数据库information_schema，所有其他的数据库因为没有权限而都被隐藏了。

授予新创建cheng用户在atguigudb数据库下所有表的查询权限

```sql
GRANT SELECT ON atguigudb.* TO 'cheng'@'%';
```

这个时候，atguigudb数据库就不再对cheng用户隐藏。

<img src=".\images\image-20240328115836796.png" align="left">

同时，也能够查看到atguigudb数据库下所有的数据表信息了：

![image-20240328115936422](.\images\image-20240328115936422.png)

同时，也能够去查看atguigudb数据库下所有表的数据。

这个时候，我们去查看一下cheng用户的所有权限：

```sql
show grants;
```

<img src=".\images\image-20240328120240825.png" align="left">



**案例2：**

创建一个用户joe，授予该用户对所有库所有表的全部权限，密码设为123.

```sql
GRANT ALL PRIVILEGES ON *.* TO 'joe'@'%' IDENTIFIED BY '123';
```

joe拥有了除grant以外的所有权限，即不能赋予用户权限。

以上这种语法不推荐使用，不推荐使用GRANT命令时加上IDENTIFIED BY子句，因为这样相当于创建用户并授予权限。





#### 授予权限出现的报错

在Mysql8.0中，root给其他给用户授予权限的时候报错：
ERROR 1227 (42000): Access denied; you need (at least one of) the SYSTEM_USER privilege(s) for this operation

这是因为Mysql8.0中新增了一个system_user账户类型，由于root用户没有SYSTEM_USER权限，导致出现错误。

解决方案：

为root添加权限：

```sql
grant system_user on *.*  to 'root';
```

此时就可以为其他用户授予权限了。







### 1.4、查看权限 show grants

* **`查看当前用户权限`**

```sql
SHOW GRANTS;
#或
SHOW GRANTS FOR CURRENT_USER;
#或
SHOW GRANTS FOR CURRENT_USER();
```



* **`查看某用户的权限`**

```sql
SHOW GRANTS FOR 'user'@'主机地址';
```



### 1.5、收回权限 revoke

收回权限就是取消已经赋予用户的某些权限。**收回用户不必要的权限可以在一定程度上保证系统的安全性。**MySQL中使用**`REVOKE语句`**取消用户的某些权限。使用REVOKE收回权限后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中的账户记录使用DROP USER语句）。

> **`注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。`**

**收回权限命令：**

```sql
REVOKE 权限1,权限2,...权限n ON 数据库名称.表名称 FROM 用户名@主机地址;
```

举例：

```sql
#收回全库全表的所有权限
REVOKE ALL PRIVILEGES ON *.* FROM cheng@'%';

#收回mysql库下的所有表的增删改查权限
REVOKE SELECT, INSERT, UPDAET, DELETE ON mysql.* FROM joe@localhost;
```

**注意**：需要用户重新登录之后才能生效。



> 开发说明：
>
> 有一些程序员喜欢使用root超级用户来访问数据库，完全把`权限控制`放在`应用层面`实现。这样当然也是可以的。但是建议大家，进了使用数据库自己的角色和用户机制来控制访问权限，不要轻易使用root账号。因为root账号密码放在代码里面不安全，一旦泄露，数据库就会完全失去保护。



## 2、权限表

权限表存放着我们创建了哪些用户，以及这些用户分别赋予了哪些权限，记录这些信息的就是权限表。权限表和访问控制实际上就是用户管理和权限管理的底层实现原理。

MySQL服务器通过`权限表`来**控制用户对数据库的访问**，权限表存放在`mysql数据库`中。MySQL数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是**`user表`**、**`db表`**。除此之外，还有**`table_priv表`**、**`column_priv表`**和**`proc_priv表`**等。**在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。**

通过这几个表，来体现对用户权限的访问控制。

### 2.1、user表

**这张表体现的是用户信息以及用户整体的权限信息。**

![image-20240328140525747](.\images\image-20240328140525747.png)![image-20240328140559602](.\images\image-20240328140559602.png)

1. **`范围列（或用户列）`**

* Host列：表示连接类型
  * `%` 表示所有远程通过TCP方式的连接
  * `IP地址` 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接 
  * `机器名` 通过制定网络中的机器名进行的TCP方式的连接 
  * `::1` IPv6的本地ip地址，等同于IPv4的 127.0.0.1 
  * `localhost` 本地方式通过命令行方式的连接，比如mysql -u xxx -p xxx 方式的连接。

* User列：表示用户名，同一个用户通过不同方式连接的权限是不一样的。

  Host列和User列共同组成联合主键

* authentication_string列：密码
  * 在MySQL5.7之前，密码保存在password字段，5.7之后保存到authentication_string字段中不再使用password字段。
  * 在MySQL8.0在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的`SHA1`改为了`SHA2`，不可逆。同时加上MySQL5.7的禁用用户和用户过去的功能，MySQL在用户管理方面的功能和安全性都较之前版本大大增强了。

2. **`权限列`**

* `xxx_priv`：表示是否拥有xxx权限。这些字段都是enum枚举类型。如果这些字段的值为Y，则表示该用户对所有的数据库都拥有该类型的权限。比如Select_priv的值为Y，则表示该用户可以查询所有数据库的值。

3. **`安全列`**

安全列只有6个字段，其中两是ssl相关的（ssl_type、ssl_cipher），用于`加密`；两个是x509相关的（x509_issuer、x509_subject），用于`标识用户`；另外两个Plugin字段用于`验证用户身份`的插件，该字段不能为空。

4. **`资源控制列`** 资源控制列的字段用来`限制用户使用的资源`，包括4个字段，分别为：

   1）max_questions，用户每小时允许执行的查询操作次数；

   2）max_updates，用户每小时运行执行的更新操作次数；

   3）max_connections，用户每小时允许执行的连接操作次数；

   4）max_user_connections，用户允许同时建立的连接次数。



例如：

先去查看一下user表中的信息：

![image-20240328141349264](.\images\image-20240328141349264.png)

去给cheng用户授予查询所有数据库表的权限：

```sql
grant select on *.* to cheng@'%';
```

此时，cheng用户就拥有了对所有数据库的查询操作，此时在user表中，该用户的Select_priv字段的值就会变为Y：

![image-20240328141322875](.\images\image-20240328141322875.png)

即，我们可以由此知道：

> **在user表中，如果用户的xxx_priv权限字段值为Y，则表示该用户对`所有数据库的所有表`都拥有该权限。**





### 2.2、db表

**这张表体现的是用户对某一个数据库的权限信息。**

![image-20240328142502726](.\images\image-20240328142502726.png)

表中字段Host、Db和User整体构成了db表的主键。表示的就是指定的用户（Host和User字段表示）对指定的数据库（Db字段表示）的权限（xxx_priv字段表示）。

1. **`用户列`** db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限。这三个字段的组合构成了db表的主键。
2. **`权限列`** xxx_priv。例如create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。在db表中的这些权限，如果为Y，表示的是对该数据库中所有的表都拥有的权限。



> **这一张表中，若权限列xxx_priv的值为Y，表示的是指定用户对`指定数据库中的所有表`，都拥有xxx的权限。**
>
> 比如，一条数据信息中表示的用户为cheng@'%'，数据库为atguigudb，权限列Select_priv的值为Y，则表示cheng用户对atguigudb下所有的表都拥有SELECT权限。使用授权语句实现就是：
>
> ```sql
> grant select on atguigu.* to cheng@'%';
> ```



### 2.3、tables_priv表和columns_priv表

**tables_priv表：**

![image-20240328143913039](.\images\image-20240328143913039.png)

tables_priv表中存放的是**`用户对指定数据库的指定表设置的操作权限`**。

tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和Column_priv，各个字段说明如下：

* 使用`Host`、`Db`、`User`和`Table_name`作为联合主键，用于指明哪个用户对于哪个数据库中数据表的权限。
* Grantor表示修改该记录的用户。
* Timestamp表示修改该记录的时间。
* `Table_priv`表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、References、Index和Alter。
* Column_priv字段表示对表中列的操作权限，包括Select、Insert、Update和References。



**columns_priv表：**

![image-20240328144003469](.\images\image-20240328144003469.png)

columns_priv表中存放的是**`用户对指定数据库中指定表的指定列设置的操作权限`**。

### 2.4、procs_priv表

procs_priv表可以对`存储过程和存储函数设置操作权限`，表结构如图：

![image-20240328150009144](.\images\image-20240328150009144.png)



## 3、访问控制

### 3.1、连接核实阶段

当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQl服务器接收到用户请求后，会**`使用user表中的host、user和authentication_string这3个字段匹配客户端提供信息`**。

服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。**`如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待用户请求。`**



### 3.2、请求核实阶段

一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、tables_priv和columns_priv表。

确认权限时，MySQL首先`检查user表`，如果指定的权限没有在user表中被授予，那么MySQL就会继续`检查db表`，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续`检查tables_priv表`以及`columns_priv表`，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将`返回错误信息`，用户请求的操作不能执行，操作失败。

因为user、db、tables_priv、columns_priv这四个表的范围是从大到小的，如果在user表中某一权限列的值为Y，那么肯定也就在另外三个表的权限信息是支持的。同理，在db表中若显示支持某一权限，则在table和cloumn表中也支持该权限。所以，**在执行请求，确认权限的顺序是：`user -> db -> tables_priv -> columns_priv`。**如图所示：

![image-20240328145009265](.\images\image-20240328145009265.png)

> 提示：Mysql通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作（与数据库和表无关），此时只涉及管理权限，因此MySQL值检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继续检查下一层级的表。






# 三、角色管理

## 1、角色的理解

角色是在MySQL8.0中引入的新功能。在MySQL中，`角色是权限的集合`，可以为角色添加或移除权限。用户可以被赋予角色，同时也被赋予角色包含的权限。对角色进行操作需要较高的权限，并且像用户账户一样，角色可以拥有授予和撤销的权限。

引入角色的目的是**`方便管理拥有相同权限的用户`**。

![image-20240328161223783](.\images\image-20240328161223783.png)



## 2、创建角色

创建角色使用**`CREATE ROLE`**语句，语法如下：

```sql
CREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'hostname']...];
```

角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。

例如：

创建经理角色

```sql
CREATE ROLE 'manager'@'%';
```



## 3、给角色赋予权限

创建角色之后，默认这个角色是没有任何权限的，与创建用户一样。

此时，我们需要给角色授权，给角色授权的**语法结构**是：

```sql
GRANT 权限 ON 数据库名.表名 TO 角色名[@'host_name'];
```

这其实和授权给用户的语法差不多。



案例：

我们先去查看一下manager角色创建后的权限：

![image-20240328163048660](.\images\image-20240328163048660.png)

此时相当于是没有任何权限的，此时给经理角色一个查看atguigudb数据库下employees表的权限：

```sql
GRANT SELECT ON atguigudb.employees TO manager;
```

此时，再去查看经理的权限：

![image-20240328163208338](.\images\image-20240328163208338.png)

## 4、查看角色的权限

赋予角色权限后，我们可以通过SHOW GRANTS语句，来查看权限是否创建成功了：

```sql
SHOW GRANTS FOR 角色;
```

如：

```sql
SHOW GRANTS FOR manager;
```

![image-20240328163319805](.\images\image-20240328163319805.png)

只要创建了一个角色或者用户，系统会自动给一个**`USAGE`**权限，意思是`连接登录数据库的权限`。后面一行代表了我们给角色manager赋予的权限，也就是能够查询employees表的权限。



## 5、回收角色的权限

角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用grant语句，与角色授权相同。撤销角色或角色权限使用revoke语句。

修改了角色的权限，会英雄拥有该角色的用户的权限。

撤销角色权限的**SQL语法**如下：

```sql
REVOKE 权限 ON 数据库名.表名 FROM 角色名[@'host_name'];
```

案例：

撤销manager角色查询atguigudb数据库中employees表的权限

```sql
REVOKE SELECT ON atguigudb.employees FROM manager;
```

此时，manager角色就不再拥有了该权限

![image-20240328164903195](.\images\image-20240328164903195.png)



## 6、删除角色

当我们需要对业务进行重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不再使用的角色。

**语法：**

```sql
DROP ROLE 角色1[, 角色2...];
```



## 7、给用户赋予角色

角色创建并授权后，要赋给用户并处于**`激活状态`**才能发挥作用。给用户添加角色可使用`GRANT`语句，语法格式：

```sql
GRANT role[, role2...] TO user[, user2...];
```

在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。



案例：

给manager角色赋予查询atguigudb下所有表的权限：

```sql
grant SELECT on atguigudb.* TO manager[@'%'];
```

给cheng用户赋予manager角色：

```sql
GRANT manager TO cheng;
```

那么，此时，一般来说，由于cheng用户被赋予了manager角色，其也拥有了manager角色中的权限，那cheng用户是可以去查询atguigudb下的表的。但是此时去执行查询操作会报错。并且，此时去查看cheng用户拥有的角色时：

```sql
SELECT current_role();
```

执行结果为：NONE，即cheng用户未被赋予任何角色。

<img src=".\images\image-20240328170558425.png" align="left">

为什么cheng用户下没有角色信息呢？

这是因为，**`MySQL中创建了角色之后，默认都是没有激活的`**，也就是不能用，必须要`手动激活`，激活以后用户才能拥有角色对应的权限。



## 8、激活角色

**`方式一：使用set default role命令激活角色`**

```sql
SET DEFAULT ROLE ALL TO 用户名[@主机名];
```

意思是去激活用户下所有已拥有的角色。

案例：

```sql
SET DEFAULT ROLE ALL TO cheng;
```

意思是激活cheng用户下所拥有的所有角色。

此时，再去查看cheng用户的所有角色：

![image-20240328172158467](.\images\image-20240328172158467.png)

此时，cheng用户下的manager角色就被激活了。

> 注意：用户需要退出重新登录，才能看到赋予的角色。



**`方式二：将activate_all_roles_on_login设置为ON`**

默认情况下，activate_all_roles_on_login变量值是OFF：

![image-20240328172308327](.\images\image-20240328172308327.png)

即**默认情况下，角色都是未激活的状态**。

**设置：**

```sql
SET GLOBAL activate_all_roles_on_login=ON;
```

这条SQL语句的意思是：对**`所有角色永久激活`**。即设置角色都是激活的状态。

## 9、撤销用户的角色

**语法：**

```sql
REVOKE 角色 FROM 用户;
```

案例：

撤销cheng用户的manager角色

```sql
REVOKE manager FROM cheng;
```

此时，cheng用户退出后重新登录，再去查看其赋予的角色时，就发现manager角色被撤销了：

<img src=".\images\image-20240328172633820.png" align="left">

## 10、设置强制角色

强制角色是给每个创建账户的默认角色，不需要手动设置。强制角色无法被`REVOKE`或`DROP`。

方式1：服务启动前设置

```shell
[mysqld]
mandatory_roles='role1,role2@hostname'
```

方式2：运行时设置

```sql
SET PERSIST mandatory_roles = 'role1,role2@hostname';#系统重启后仍然有效
SET GLOBAL mandatory_roles = 'role1,role2@hostname';#系统重启后失效
```

