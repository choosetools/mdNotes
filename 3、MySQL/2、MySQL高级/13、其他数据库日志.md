[TOC]

我们在讲解数据库事务时，讲过两种日志：重做日志、回滚日志。

对于线上数据库应用系统，突然遭遇数据库宕机怎么办？在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如：从日志中发现了某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。

除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。

# 一、MySQL支持的日志

## 1.1、日志类型

MySQL有不同类型的日志文件，用来存储不同类型的日志，分为`二进制日志`、`错误日志`、`通用查询日志`和`慢查询日志`，这也是常用的四种。MySQL 8又新增两种支持的日志：`中继日志`和`数据定义语句日志`。使用这些日志文件，可以查看MySQL内部发生的事情。

**这6类日志分别为：**

* **`慢查询日志`**：记录所有执行时间超过long_query_time的查询，方便我们对查询进行优化。
* **`通用查询日志`**：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
* **`错误日志`**：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，以及对服务器进行维护。
* **`二进制日志`**：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
* **`中继日志`**：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
* **`数据定义语句日志`**：记录数据定义语句执行的元数据操作。

除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。



## 1.2、日志的弊端

* `日志功能会降低MySQL数据库的性能。`例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。
* `日志会占用大量的磁盘空间。`对于用户量非常大、操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。



# 二、慢查询日志（slow query log）



请参考《数据库调优》文件中的慢查询日志，已详细讲述。





# 三、通用查询日志（general query log）

## 1、概述

通用查询日志用来**`记录用户的所有操作`**。包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给MySQL数据库服务器的所有SQL指令等。

**当我们的数据发生异常时，查询通用查询日志，还原操作时具体场景，可以帮助我们定位问题。**



## 2、问题场景

在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在，那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。

我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。

查看之后，发现1月1日下午2点，用户使用微信支付完以后，由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。用户又使用支付宝支付，此时记录更新到支付中心。晚上，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以覆盖记录了。

可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作细节，对找出异常发生的原因及其关键。





## 3、查看当前状态

```sql
SHOW VARIABLES LIKE '%general%';
```

查看通用查询日志的状态，以及通用查询日志存放的位置。

![image-20240429150236118](.\images\image-20240429150236118.png)

说明：

1. 系统变量general_log的值是OFF，即通用查询日志处于关闭状态。在MySQL中，`general log的默认是关闭的`。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。
2. 通用查询日志文件的名称是centOS7.log，存储路径是/var/lib/mysql/，这个路径也就是默认数据路径。







## 4、启动日志

**`方式1：永久性方式`**

修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：

```properties
[mysqld]
general_log=ON
#日志文件所在目录路径，filename为日志文件名
general_log_file=[path[filename]] 
```

如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名

**`方式2：临时性方式`**

```sql
SET GLOBAL general_log=ON; #开启通用插叙内置
```

```sql
SET GLOBAL general_log_file='path/filename'; #设置日志文件保存位置
```







## 5、日志查看案例

原本通用查询日志是关闭状态，因为未使用过通用查询日志，所以对应的日志文件是不存在的，当我们去将其开启后，通用查询日志文件才会被创建。

开启通用查询日志

```sql
SET global general_log = on;
```

此时，在/var/lib/mysql/目录下，就会创建一个通用查询日志文件。

我们可以使用

```sql
SHOW variables like '%general%';
```

查看通用查询日志文件的存储路径：

![image-20240429154200148](.\images\image-20240429154200148.png)

通用查询日志是以文本文件的形式存储在文件系统中的，可以使用`文本编辑器vi`（Linux系统）直接打开日志文件。

通过通用查询日志，可以了解用户对MySQL进行的操作。

例如，我们去执行下面这些操作：

```sql
use atguigudb3;

show tables;

select * from account;

select * from student;

delete from student where id = 20;
```

执行完毕之后，在通用查询日志文件中，查询出来的日志信息如下所示：

![image-20240429154004830](.\images\image-20240429154004830.png)

其中，右侧表示的是数据库的操作，左侧表示的是操作的时间，注意这里的时间需要+8小时，因为中国位于东八区，这上面的是格林尼治时间。

在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登录数据库，登录之后做了什么SQL操作，针对的是哪个数据表等信息。





## 6、停止日志

**`方式1：永久性方式`**

修改my.cnf或者my.ini文件，把[mysqld]组下的general_log值设置为OFF或者把general_log一项注释掉。修改保存后，再重启MySQL服务，即可生效。

例：

```properties
[mysqld]
general_log=OFF
```



**`方式2：临时性方式`**

使用SET语句停止MySQL通用查询日志功能：

```sql
SET GLOBAL general_log = OFF;
```

停止通用日志功能后，日志中就不会再记录操作信息了。



## 7、删除/刷新日志

如果数据的使用非常频率，那么通用查询日志会在占用服务器非常大的磁盘空间。数据库管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。

**`手动删除文件`**

对于通用日志文件，我们可以在数据目录下，对日志文件进行手动删除。

如果我们想要去将日志文件备份下来，可以先将旧的日志文件复制出来或者改名，然后去刷新日志文件，流程如下：

```shell
cd mysql-data-directory #输入自己的通用日志文件所在目录
mv 原日志文件名 新日志文件名 #改名操作
mysqladmin -uroot -p flush-logs #刷新日志，若日志文件已被删除，则重新生成
```







# 四、错误日志（error log）

错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括`错误`、`警告`和`提示`等。

通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务出现异常，错误日志是发现问题、解决故障的首选。

## 1、启动日志

在MySQL数据库中，错误日志功能是**`默认开启`**的。错误日志**`无法被禁止`**。

默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为`mysqld.log`：

![image-20240429161535284](.\images\image-20240429161535284.png)

如果需要指定文件名，需要在my.cnf做如下配置：

```properties
[mysqld]
log-error=[path/[filename]] 
#path为日志文件所在的目录路径，filename为日志文件名
```

修改配置项后，需要重启MySQL服务以生效

## 2、查看日志案例

MySQL错误日志是以文本的格式进行存储的，所以我们可以通过文本编辑器去查看错误日志信息。

![image-20240429161535284](.\images\image-20240429161535284.png)

```shell
vim /var/log/mysqld.log
```

![image-20240429163943049](.\images\image-20240429163943049.png)

可以看到，错误日志中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止的时间等。我们在做初始化时候生成数据库初始密码也是记录在error.log中。



## 3、删除/刷新日志

对于很久以前的的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的硬盘空间。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除。

**删除操作：**

```shell
rm -f /var/log/mysqld
```

在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。

**备份操作：**

1、重命名文件

```shell
mv /var/log/mysqld.log 新文件名
```

2、重建日志

```shell
mysqladmin -uroot -p flush-logs
```

可能上述的备份操作会报错，此时需要进行补充操作：

```shell
install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log
```

flush-logs指令操作：

从MysQL5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建操作。如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件，重新创建错误日志文件，大小为0字节。







# 五、二进制日志（bin log）（重要）

binlog可以说是MySQL中比较重要的日志了，在日常开发及运维过程中，经常会遇到。

binlog即binary log，二进制日志文件，也叫作变更日志（update log）。**它记录了数据库所有执行的`DDL`和`DML`等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）**

它以事件形式记录并保存在`二进制文件`中。通过这些信息，我们可以再现数据更新操作的全过程。

由于binlog存储的都是二进制的数据，所以我们无法通过vi等方式查看，因为它不是文本文件。

> 如果想要记录所有语句（例如查询），需要使用通用查询日志。

binlog主要应用场景：

* 一是用于`数据恢复`，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。
* 二是用于`数据复制`，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致性的目的。

可以说MySQL数据库的**`数据备份、主备、主主、主从`**都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。

![image-20240429191200372](.\images\image-20240429191200372.png)



## 1、查看默认情况

查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制日志是开启的

![image-20240429191440330](.\images\image-20240429191440330.png)

* `log_bin`为ON，就表示binlog是开启的状态；

* `sql_log_bin`为ON，表示支持把变更型的sql记录到日志文件中；

* `log_bin_basename`表示的binlog日志文件的存储路径，这并不是一个文件，binlog会生成很多文件，实际生成的文件是binlog.xxxxx；

* `log_bin_index`表示的是binlog日志文件的索引文件路径；
* `log_bin_trust_function_creators`：表示是否信任存储函数，如果为OFF，表示的是不信任，此时就不能去创建存储函数，修改为ON之后就能够创建。

我们去`/var/lib/mysql/`目录下，去查看一下binlog文件：

<img src=".\images\image-20240429192156125.png" alt="image-20240429192156125" style="zoom: 80%;" /> 

每当mysql服务重启时，都会帮助我们重新创建一个binlog文件。





## 2、日志参数设置

**`方式1：永久性方式`**

修改MySQL的`my.cnf`或my.ini文件可以设置二进制日志的相关参数：

```properties
[mysqld]
#设置二进制日志文件名
log-bin=文件名
binlog_expire_logs_seconds=600
max_binlog_size=100M
```

> 1. `log-bin=文件名`，设置的是二进制日志文件名与索引文件名，这里也可以加上路径，用于指定文件存储的地址。
>
>    例如:log-bin=atguigu-bin，重启mysql数据库后的文件为：
>
>    ![image-20240429194609810](.\images\image-20240429194609810.png)
>
> 2. `binlog_expire_logs_seconds`：此参数控制二进制文件保留的时长，单位为秒，默认2592000 30天。
>
> 3. `max_binlog_size`：控制单个二进制日志的大小，当前日志文件大小超过此变量时，执行切换动作。此参数的最大和默认值是`1GB`，该设置并`不能严格控制Binlog的大小`，尤其是Binlog比较靠近最大值而又遇到一个比较大的事务时，为了保证事务的完整性，需要将事务中所有的SQL都记录进当前日志，当达到设置的Binlog大小时，可能不做切换日志的动作，直到事务结束。

**设置带文件夹的bin-log日志存放目录**

如果想改变日志文件的目录和名称，可以对my.cnf中log_bin参数修改如下：

```properties
[mysqld]
log-bin="/var/lib/mysql/binlog/atguigu-bin"
```

注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。

```shell
chown -R -v mysql:mysql binlog
```

重启MySQL服务之后，新的二进制日志文件将出现在/var/lib/mysql/binlog/文件夹下面：

![image-20240429223839313](.\images\image-20240429223839313.png)

注意：

数据库文件最好不要与日志文件放在同一个磁盘上，这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。



**`方式2：临时性方式`**

如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql8中只有会话级别，没有global级别的设置。

例：

```sql
# global 级别
mysql> set global sql_log_bin=0;
ERROR 1228 (HY000): Variable 'sql_log_bin' is a SESSION variable and can`t be used with SET GLOBAL


# session级别
mysql> SET sql_log_bin=0;
Query OK, 0 rows affected (0.01 秒)
```





## 3、查看日志

当MySQL创建二进制日志文件时，先创建一个以'`filename`'为名称，以'`.index`'为后缀的文件，即**索引文件**。

再创建一个以'filename'为名称、以'.000001'为后缀的文件，即**日志文件**。

![image-20240430092414129](.\images\image-20240430092414129.png)



MySQL服务重新启动一次，以'.000001'为后缀的文件就会增加一个，并且后缀名按1递增，即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了max_binlog_size的上限（默认是1GB），就会创建一个新的日志文件。

**查看当前的二进制日志文件列表及大小**，指令如下：

```sql
SHOW BINARY LOGS;
```

![image-20240430092647524](.\images\image-20240430092647524.png) 

最新的binlog日志是刚刚启动MySQL服务时，创建出来的binlog，此时的大小为156，此时文件中是没有数据的。

![image-20240430092929278](.\images\image-20240430092929278.png) 

我们来执行一些DDL或者DML语句，让日志文件中存储一些日志信息：

```sql
use atguigudb3;
select * from account;
insert into account(id, name, balance) values(5, 'tom', 50);
update account set name = 'lucy' where id = 3;
```

执行完上面的语句，此时再去查看binlog.000026文件：

![image-20240430093158874](.\images\image-20240430093158874.png) 

此时文件的大小为804，即此时日志文件就记录了DML操作的信息了。



#### 方式一：mysqlbinlog

所有对数据库的修改都会记录在binlog中。但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助**`mysqlbinlog`**命令工具了，但是如果直接使用的话，呈现出来的结果是一个简单的日志文件，没有具体的SQL语句，这时因为binlog关键字后面的内容是经过编码后的二进制日志。

一个操作对应着一个事件，一个事件包含着如下这些信息：

* Query事件 负责开始一个事务（Begin）
* Table_map事件 负责映射需要的表
* Update_rows事件 负责写入数据
* Xid事件 负责结束事务

在**`mysqlbinlog`**命令后面加一个**`-v`**，表示行事件以`伪SQL的形式`表现出来，方便我们查看了：

```shell
mysqlbinlog -v '/var/lib/mysql/binlog.000026'
```

在查询的结果中，我们可以看到两个伪SQL信息，一个是INSERT插入SQL，一个是UPDATE更新的SQL：

<img src=".\images\image-20240430094115913.png" alt="image-20240430094115913" style="zoom:67%;" /> 

<img src=".\images\image-20240430094137839.png" alt="image-20240430094137839" style="zoom:67%;" /> 

关于mysqlbinlog工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句：

```shell
#可查看参数帮助
mysqlbinlog --no-defaults --help

#查看最后100行
mysqlbinlog --no-defaults --base64-output=decode-rows -vv 文件名 |tail -100

#根据position查找
mysqlbinlog --no-defaults --base64-output=decode-rows -vv 文件名 |grep -A 20 '4939002'
```





#### 方式二：show binlog events

上面这种方式读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：

```sql
show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];
```

* `IN 'log_name'`：指定要查询的binlog文件名（不指定就是第一个binlog文件）
* `FROM pos`：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）
* `LIMIT [offset]`：偏移量（不指定就是0）
* `row_count`：查询总条数（不指定就是所有行）

案例：

```sql
SHOW binlog events IN 'binlog.000026';
```

![image-20240430104046624](C:\Users\14036\AppData\Roaming\Typora\typora-user-images\image-20240430104046624.png)

上述查询出来的结果就包含事件内的全部信息。

上述的结果就是两个事件，一个是INSERT事件，一个是UPDATE事件

这里有一个Pos的参数，我们可以通过这个Pos参数，来查询从Pos参数起的日志信息，例如：

```sql
#查询pos点从235开始，查询3条语句
SHOW binlog events IN 'binlog.000026' FROM 235 LIMIT 3;

#查询Pos参数从156起，第2,3个二进制日志信息，LIMIT1即跳过前1个
SHOW binlog events IN 'binlog.000026' FROM 156 LIMIT 1,2;
```

pos参数是随着修改，不断增大的，所以当我们使用FROM Pos的方式去查询数据，实际上会将该操作的后续所有操作都查询出来。



上面这些都是基于binlog的默认格式的。

binlog格式查看：

![image-20240430110737556](.\images\image-20240430110737556.png)

除此之外，binlog还有两种格式，分别是**Statement**和**Mixed**，详细情况会在下一章讲解。







## 4、如何使用二进制日志恢复数据

如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用`mysqlbinlog`工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中恢复数据。

**恢复数据的语法如下：**

```sql
mysqlbinlog [option] filename|mysql -uuser -ppwd;
```

这个命令可以这样理解：使用mysqlbinlog命令获取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。

* `filename`：是日志文件名
* `option`：可选项，比较重要的两对option参数是--start-date、--stop-date和--start-position、--stop-position。
  * `--start-date和--stop-date`：可以指定恢复数据库的起始时间和结束时间。
  * `--start-position和--stop-position`：可以指定恢复数据的开始位置和结束位置。

分别表示使用两种方式进行恢复，一种是选择从指定的时间开始进行恢复，一种是选择从指定位置开始恢复。

由于我们恢复数据时，实际上又是去执行操作，这个时候又会向binlog文件中写入数据，所以**我们需要在恢复数据前，进行flush logs操作**：

```sql
flush logs;
```

这样一来，就会去重新生成一个log文件，恢复数据的操作实际上是写在新文件里了，这样一来，就不会对我们使用log文件进行恢复数据产生干扰。







---

#### 恢复演示

假设我往account表做了一些DML操作：

```sql
insert into account(id, name, balance) values(6, 'lurry', 150);

insert into account(id, name, balance) values(7, 'Aimy', 2000);

insert into account(id, name, balance) values(9, 'David', 1800);

delete from account where id = 9;

update account set name = 'zhangsan' where id = 7;
```

执行完毕后：

![image-20240430133739552](.\images\image-20240430133739552.png) 

上面都是正常的操作，然后突然，误操作了，删除了一些数据：

```sql
delete from account where id > 5;
```

此时，就将前面的插入的数据全部删除了：
![image-20240430132643281](.\images\image-20240430132643281.png)



这个时候，我们想去恢复数据，就可以使用二进制日志进行恢复。

我们去查看一下二进制日志：

![image-20240430112932344](.\images\image-20240430112932344.png)

由于进行了操作，二进制日志文件增加了，我们使用二进制日志文件恢复，**首先要先去生成一个新的二进制日志文件：**

```sql
flush logs;
```

![image-20240430113045269](.\images\image-20240430113045269.png)

接下来的恢复操作就会放入到新的二进制日志文件binlog.000027中。



我们恢复数据，**可以通过时间进行恢复，恢复指定时间段内的操作；也可以通过位置position进行恢复，恢复指定位置区间内的操作**。

> 如果通过时间进行恢复，则需要使用`mysqlbinlog`查看二进制日志信息，因为使用这种方式可以查看到操作的时间；
>
> 如果通过position进行恢复，则需要使用`show binlog events`查看二进制日志信息，使用这种方式可以查看到各个操作的position值。（推荐使用）

我们这里使用`position`进行恢复演示。

我们使用**`show binlog events`**去查看binlog.000026日志文件信息：

<img src=".\images\image-20240430131943549.png" alt="image-20240430131943549" style="zoom: 67%;" />

我们现在要去恢复之前的插入操作，恢复操作是恢复**`从BEGIN开始，一直到结束操作的BEGIN之前的操作`**。

之前三个步骤的插入操作如图是：

![image-20240430132558558](.\images\image-20240430132558558.png)

position也就是从883一直到1739。



**恢复操作：**

```shell
mysqlbinlog --start-position=883 --stop-position=1739 --database=atguigudb3 /var/lib/mysql/binlog.000026 | /usr/bin/mysql -uroot -p061535asd -v atguigudb3
```

其中：

--start-position=883：表示指定恢复的起始位置

--stop=position：表示指定恢复的终止位置

--database=atguigudb3：表示指定数据库

/var/lib/mysql/binlog.000026：表示根据哪个二进制日志文件进行恢复操作

/usr/bin/mysql：由于要进行登录，所以需要使用mysql的命令

-uroot -p061535asd -v atguigudb3表示登录的账号、密码以及数据库

此时，我们再去查看account表：

![image-20240430133336833](.\images\image-20240430133336833.png) 

可以看到，插入的数据已经被恢复了，即上述操作恢复了插入的行为。

再比如，我们去恢复一下删除id=9数据的行为，我们去看看删除操作对应的日志文件信息：
![image-20240430133524004](.\images\image-20240430133524004.png)

position的值从1818到2051，那么我们就可以去执行恢复操作：

```shell
mysqlbinlog --start-position=1818 --stop-position=2051 --database=atguigudb3 /var/lib/mysql/binlog.000026 | /usr/bin/mysql -uroot -p061535asd -v atguigudb3
```

执行之后，再去查看一下account表：

![image-20240430133642402](.\images\image-20240430133642402.png) 

就可以看到，其中id=9的数据就被删除了。

如果想要恢复更新操作也可以使用上面的方式继续进行。





上述，就是使用position的方式恢复数据，我们也可以使用时间的方式，对数据进行恢复，**指定某段时间内的操作进行恢复（但是不推荐使用这种方式进行恢复）**，SHOW BINLOG EVENTS查看不了日志的时间，我们需要使用**`mysqlbinlog`**命令进行查看，如下所示：

```sql
mysqlbinlog -v '/var/lib/mysql/binlog.000026'
```

<img src=".\images\image-20240430135508776.png" alt="image-20240430135508776" style="zoom:67%;" /> 

在操作的BEGIN之前，有一个TIMESTAMP就显示了时间的形式。

我们就可以使用时间恢复，命令格式如下：

```shell
mysqlbinlog --start-datetime='日期 时间' --stop-datetime='日期 时间' --database=数据库 二进制文件路径地址 | mysql -uroot -p密码 -v 数据库
```

可能出现一个事务执行时间过短，一秒内执行完成，此时我们找到下一个事务的开始时间，多计算一些时间即可。







## 5、删除二进制日志

MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制方法。**`PURGE MASTER LOGS`**只删除指定部分的二进制日志文件，**`RESET MASTER`**删除所有的二进制日志文件。具体如下：

1. **`PURGE MASTER LOGS：删除指定文件之前的所有日志文件`**

**语法如下：**

```mysql
PURGE {MASTER | BINARY} LOGS TO '指定日志文件名'
#或
PURGE {MASTER | BINARY} LOGS BEFORE '指定日志'
```

例如：使用PURGE MASTER LOGS语句删除创建时间比binlog.000023早的所有日志

我们先去查看一下有哪些binlog日志文件：

```sql
SHOW BINARY LOGS;
```

<img src=".\images\image-20240430173856077.png" alt="image-20240430173856077" style="zoom:67%;" /> 

删除比binlog.000023日志文件早的文件（不包括binlog.000023）：

```sql
purge master logs to 'binlog.000023';
```

执行之后，再去查看一下所有的日志文件：

![image-20240430173958269](.\images\image-20240430173958269.png) 

比binlog.000023早的所有日志文件都已经被删除了。



2. **`RESET MASTER：删除所有二进制日志文件`**

使用`RESET MASTER`语句，清空所有的binlog日志。MySQL会重新创建二进制文件，新的日志文件扩展名将重新从000001开始编号。慎用！

执行完该语句后，原来的所有二进制日志已经全部被删除。

如果使用这种方式去把二进制日志文件删除了，并且还进行了删库操作，那恢复数据都恢复不了。



## 6、其他场景

二进制日志可以通过数据库的`全量备份`和二进制日志中保存的`增量信息`，完成数据库的`无损失恢复`。

但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战的，因为这样操作很多，在日志中我们进行恢复就需要去查找操作对应的position位置，然后才能对其中的操作进行恢复，起止位置不容易管理。

在这种情况下，一个有效的解决办法是配置`主从数据库服务器`，甚至是一主多从的架构。把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。





## 7、二进制日志的写入机制

> **只要是刷盘，不论是redo log还是其他什么日志刷盘，都要经历中间的一个过程，那就是先将数据存入到`文件系统缓存page cache`中，再从page cache存入磁盘中。**

binlog的写入机制也比较简单，事务执行过程中，先把日志写到**`binlog cache`**，事务提交的时候，再把binlog cache写到binlog文件中（**中间会经历page cache文件系统缓存**）。

由于一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以就算当binlog数据要超过设置的二进制日志文件大小时，也要将日志信息写入到同一个日志文件中。

系统会给每个线程分配一个块内存作为`binlog cache`。

**我们可以通过`binlog_cache_size`参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘(Swap)。**

binlog日志刷盘流程如下：

<img src=".\images\image-20240430180623394.png" alt="image-20240430180623394" style="zoom:67%;" />

上图中的`write`，是指把日志写入到文件系统的page cache中，并没有进行持久化，所以速度比较快；

上图的`fsync`，才是将数据持久化到磁盘的操作。

> **write和fsync的时机，可以由参数`sync_binlog`控制，默认是`1`：**
>
> * **`sync_binlog为0`**，表示每次提交事务都只write，即只写入到`page cache`中，由系统自行判断什么时候执行fsync。（类似于redo log中将参数设置成2）
> * **`sync_binlog为1`**，表示每次提交事务都要将数据写入page cache，并将page cache中的数据写入到磁盘中，即write和fsync都进行。（类似于redo log中参数设置为1）
> * **还可以将`sync_binlog设置成N`**，表示每次事务提交都会write，经过N次事务提交后再执行fsync进行持久化。

sync_binlog设置为1，类似于redo log将参数innodb_flush_log_at_trx_commit参数设置为1，即表示每次提交事务，都将内存中的日志信息写入page cache，并将page cache中的数据写入磁盘中。

sync_binlog设置为0，就类似于redo log中将参数innodb_flush_log_at_trx_commit设置为2，即表示每次事务提交，只将内存中的日志信息写入page cache中，page cache何时刷盘由系统自己决定：

<img src=".\images\image-20240430182624385.png" alt="image-20240430182624385" style="zoom:67%;" />

类似于redo log，当sync_binlog为1时，binlog更加安全，但效率较差；当sync_binlog为0时，binlog安全性较差，但效率较高。（MySQL服务宕机并不会不会影响，操作系统宕机才会造成安全问题，因为page cache是存储在操作系统的内存中的）

最后还有一种折中的方式，可以将sync_binlog设置为N，表示每次提交事务都去write，积累了N个事务后再fsync，此时风险比较大，因为如果机器宕机的话，可能会丢失最近N个事务的binlog日志：

<img src=".\images\image-20240430182759680.png" alt="image-20240430182759680" style="zoom:67%;" />



## 8、binlog与redolog对比

* redo log是`物理日志`，记录的内容是"在某个数据页上做了什么修改"，属于`InnoDB存储引擎产生`的。

* 而binlog是`逻辑日志`，记录内容是语句的原始逻辑，类似于"给ID=2这一行的c字段加1"，属于`MySQL Server层`。
* 虽然它们都属于持久化的保证，但是侧重点不同：
  * redo log让InnoDB存储引擎有了崩溃恢复能力
  * binlog保证了MySQL集群架构的数据一致性



## 9、两阶段提交

在执行更新语句过程中，会记录redo log与binlog两个日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入（后台线程，每隔1s就会将redo log buffer中的日志写入磁盘），而binlog只有在事务提交时才写入（没有后台线程将binlog cache信息写入磁盘），所以**`redo log与bin log的写入时机不一样`**。

<img src=".\images\image-20240430183922242.png" alt="image-20240430183922242" style="zoom:67%;" />

**redo log与binlog两个日志之间的逻辑不一致，会出现什么问题？**

以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c = 1 where id = 2;

在更新操作完成后，会先将redo log写入内存中，然后再写入bin log，如果在写完redo log后，bin log日志写期间发生了异常，会出现什么情况呢？

由于binlog没写完就异常，这个时候binlog里面没有对应的修改记录。

**在主从复制中，主机是按照redo log进行恢复数据的，而从机使用的是binlog进行恢复。**

当我们进行数据恢复时，主机是正常恢复的，恢复出来的这一行c值是1；而从机使用binlog恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，最终主从机的数据不一致。

![image-20240430204330309](.\images\image-20240430204330309.png)

为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用**`两阶段提交方`**案。

原理很简单，**将redo log的写入拆成了两个步骤：`prepare`和`commit`**，这就是两阶段提交。

这两个步骤分别在binlog前与后执行：

<img src=".\images\image-20240430205926356.png" alt="image-20240430205926356" style="zoom:67%;" />

redo log在prepare阶段写入redo log日志信息，在commit阶段，会把redo log设置成commit阶段。

使用两阶段提交后，写入binlog时发生异常也不会有影响了。

当MySQL使用redo log恢复数据时，发现redo log若还处于prepare阶段时，没有转变为commit阶段，说明binlog日志没有成功写入到日志文件中，此时恢复数据要回滚未提交的事务，因为最后一个事务在提交时binlog出现了错误，导致binlog中最后一个事务中的信息是错误的，为了保证主从机的一致性，所以需要对事务进行回滚。

![image-20240430211129081](.\images\image-20240430211129081.png)

如果redo log处于commit阶段，就说明binlog已经写入成功，此时主机使用red o log恢复数据，从机使用binlog恢复数据，两台主机恢复的操作是一样的，也就不会出现主从机不一致的问题。



## 10、binlog格式的说明

**binlog有三种格式，分别为：`Statement`、`Row`以及`Mixed`。**

**`格式1：Statement模式`**

```properties
binlog_format=STATEMENT
```

在5.7.7之前，binlog的默认格式是Statement。

Statement模式**`只记录执行的SQL，不记录每一行数据的变化`**。这样一来，就有可能会出现主从不一致的情况。

比如，插入一条数据：

```sql
insert into student(id, name) values(2, @@hostname);
```

如果使用的是Statement模式，主机执行了上述的语句，从机进行复制时，直接将上面的SQL语句复制过来进行执行，此时，由于主机名和从机名不一致，在主服务器和从服务器的数据库中，就会得到两个不一样的数据。

即Statement模式只记录SQL语句，从机在复制时直接将SQL复制，然后执行，不会去管主机的执行情况。

再比如，如果一些SQL中包含了函数，比如说uuid()函数，每次执行的时候都会生成一个随机字符串，在master中记录了uuid，当同步到slave之后，再次执行，就获取到另外一个结果了。

**优点**：

* 不需要记录每一行的变化，减少了binlog日志量，文件较小
* binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况。
* binlog可以用于实时的还原，而不仅仅用于复制。

**缺点**：

* 可能会出现数据一致性问题。
* INSERT...SELECT会产生比Row模式更多的行级锁
* 复制需要进行全表扫描的UPDTAE，需要比Row请求更多的行级锁
* 对于有AUTO_INCREMENT字段的InnoDB表而言，INSERT语句会阻塞其他INSERT语句
* 对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而Row模式下，只会对那个发生变化的记录产生影响
* 执行语句如果出错的话，会消耗更多资源
* 数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错

**适用场景：**

* 基于SQL语句的复制：当使用基于SQL语句的复制技术，或者要求Binlog具有高可读性，可以选择Statement模式。



**`格式2：Row模式`**

```properties
binlog_format=ROW
```

在MySQL5.7.7之后，默认的binlog格式是Row。

Row格式不记录SQL语句的上下文信息，记录的是某一条记录被修改成什么样了。

即：**`Row格式不记录具体执行的SQL语句，而是记录数据行的变更情况`**。

Row格式的日志内容会非常清楚的记录下每一行数据修改的细节，这样就不会出现Statement中存在的那种数据无法被正常复制的情况。

例如：往表中插入一条数据，这条数据中使用到了uuid()函数，uuid()函数是去随机生成一串字符串，如果我们使用的是Row模式，在二进制日志文件中，记录的就是插入的具体内容，我们进行主从复制时也会将具体的内容复制，所以此时无需担心复制过去的内容不一致。

**优点：**

* 任何情况都可以被复制，这对复制来说是最安全可靠的。
* 多数情况下，从服务器上的表如果有主键的话，复制就会快了很多
* 复制以下几种语句时的行锁更少：INSERT...SELECT、包含Auto_increment字段的INSERT，没有附带条件或者并没有修改很多记录的update或delete语句。
* 执行INSERT、UPDATE、DELETE语句时锁更少
* 从服务器上采用多线程来执行复制称为可能

**缺点：**

* binlog大很多
* 复杂的回滚时binlog中会包含大量的数据
* 主服务器上执行UPDATE语句时，所有发生变化的记录都会写到binlog中，而statement模式只会写一次，这样就会频繁发生binlog的并发写问题
* 无法从binlog中看到都复制了哪些语句

**适用场景：**

* 要求更高精度的数据复制：当要求更高的数据复制精度，或者在一些需要避免非确定性问题的场景中，可以选择Row模式。



**`格式3：Mixed模式`**

```properties
binlog_format=MIXED
```

从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。

在Mixed模式下，一般的语句修改使用statement格式保存binlog。如一些函数，statement无法完成主从复制的操作，无法保证主从机数据的一致性时，则采用Row格式保存binlog。

MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在statement和row之间选择一种。



# 六、中继日志（relay log）

## 1、介绍

![image-20240430211523675](.\images\image-20240430211523675.png)

在主从架构中，对主服务器中数据表的更改行为都记录在binlog中，主服务器做了修改后，从服务器就会通过网络去读取主服务器中的binlog文件，然后把读取到的数据存储在Relay Log文件中，然后再去读取Relay Log，将Relay Log中存储的操作去修改从服务器上的数据表，这样就实现了主机上的表和从机上的表的一致性。

这里的Relay Log就是**中继日志**。

**`中继日志只在主从服务器架构的从服务器上存在。`**从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的**`数据同步`**。

搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。

文件名格式是：`从服务器名 -relay-bin.序号`

中继日志还有一个索引文件：`从服务器名 -relay-bin.index`，用来定位正在使用的中继日志



## 2、查看中继日志

中继日志与二进制日志格式相同，可以使用`mysqlbinlog`工具进行查看。

![image-20240430213317140](.\images\image-20240430213317140.png)

这一段的意思是，主服务器（"server id 1"）对表atguigu.test进行了两步操作：

```
定位到表atguigu.test编号是91的记录，日志位置是832；
删除编号是91的记录，日志位置是872
```



## 3、恢复的典型错误

如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能导致你的服务器名称与之前不同。

而中继日志是包含从服务器名的，在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是因为从服务器前后名称不一致导致的，此时我们可以通过修改从服务器名称来解决。





更多的中继日志内容，请查看《主从复制》
