# 一、主从复制概述

## 1、如何提升数据库并发能力

在实际工作中，我们常常将Redis作为缓存与MySQL配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在·再访问数据库，这样就提升了读取的效率，也减少了对后端数据库的访问压力。`Redis的缓存架构是高并发架构中非常重要的一环。`

![image-20240430215512172](.\images\image-20240430215512172.png)

此外，一般应用对数据库而言都是"读多写少"，也就是说数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做`主从架构`、进行`读写分离`，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。

如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何`优化SQL和索引`，这种方式简单有效；其次才是采用`缓存的策略`，比如使用Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用`主从架构`，进行读写分离。

按照上面的方式进行优化，使用和维护的成本是由低到高的。





## 2、主从复制的作用

主从同步设计不仅可以提高数据库的吞吐量，还有以下3个方面的作用。

<img src=".\images\image-20240430223246985.png" alt="image-20240430223246985" style="zoom:67%;" />

**`第一个作用：读写分离`**。我们可以通过主从复制的方式来同步数据，然后通过读写分离提高数据库并发处理能力。

其中一个是Master主库，负责写入数据，我们称之为：写库。

其他都是Slave从库，负责读取数据，我们称之为：读库。

当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。

面对"读多写少"的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，`让不同的读请求按照策略均匀地分布到不同的从服务器上，让读取更加顺畅`。读取顺畅的另一个原因，就是`减少了锁表的影响`，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。

**`第二个作用就是数据备份。`**我们通过主从复制将主库上的数据复制到了从库上，相当于一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。

**`第三个作用是具有高可用性。`**数据备份实际上是一种冗余机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。

关于高可用性的程序，我们可以用一个指标衡量，即正常可用时间/全年时间。

实际上，更高的高可用性，意味着需要付出更高的成本，在现实中国我们需要结合业务需求和成本来进行选择。







# 二、主从复制的原理

> **`Slave会从Master读取binlog来进行数据同步。`**

## 1、原理剖析

**`三个线程`**

实际上主从同步的原理就是基于binlog进行数据同步的。在主从复制过程中，会基于3个线程来操作，一个主库线程，两个从库线程。

![image-20240501085244136](.\images\image-20240501085244136.png)

`二进制日志转储线程（Binlog dump thread）`是一个主库线程。当从库线程连接的时候，该线程用于将主库的二进制日志发送给从库，当主库读取事件（Event）的时候，会在Binlog加锁，防止在读取binlog时，又去修改binlog日志，造成并发问题。读取完成之后，再将锁释放掉。

`从库I/O线程`会连接到主库，向主库发送请求更新Binlog。这时从库的I/O线程就可以读取到主库的二进制日志转储线程发送的Binlog更新部分，并拷贝到本地的中继日志（Relay log）。

`从库SQL线程`会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持一致。

![image-20240501085717947](.\images\image-20240501085717947.png)

> 注意：
>
> 不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。
>
> 除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。

**`复制三步骤`**

步骤1：`Master`将写操作记录到二进制日志（`binlog`）。这些记录叫做**二进制日志事件**（binary log events）。

步骤2：`Slave`将`Master`的binary log events拷贝到它的中继日志（`relay log`）；

步骤3：`Slave`重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步且串行化的，而且重启后从`接入点`开始复制。

**复制的最大问题是`延时问题`。**



## 2、复制的基本原则

* 每个Slave只有一个Master
* 每个Slave只能有一个唯一的服务器ID
* 每个Master可以有多个Slave





# 三、一主一从架构搭建

一台主机用于处理所有`写请求`，一台从机负责所有`读请求`，架构图如下：

![image-20240501091435949](.\images\image-20240501091435949.png)

要求，主机和从机的MySQL版本尽量一致（要么都是5.7，要么都是8.0）

> 下面这些操作，完成了主从架构的搭建，以及保证了主从复制，但是，如果想要让写请求访问的是主服务器，读请求访问的是从服务器，还需要使用到Mycat这个中间件。

## 1、准备工作

1. 准备好`两台centOS`虚拟机

2. 每台虚拟机上需要安装好MySQL，注意，版本要么都是8.0以上，要么都是5.7及以下，不能一个是5.7，一个是8.0。

注意：克隆的方式需要修改新克隆出来的主机的：1）`MAC地址` 2）`hostname` 3）`IP地址` 4）`UUID`

上述这些步骤，请查看`Linux系统配置以及MySQL的安装`笔记

此外，克隆的方式生成虚拟机中，MySQL Server的UUID是相同的，必须修改MySQL Server的UUID，否则在有些场景会出错。

**修改MySQL Server的UUID的方式：**

```shell
vim /var/lib/mysql/auto.cnf
```

随便修改其中的一个值就行

之后重启mysql服务：

```shell
systemctl restart mysqld
```

然后我们使用Xshell连接上主机与从机的虚拟机即可。

这个时候，准备工作就做好了，目前有了两个主机，分别是"`主从架构 主机`"以及"`主从架构 从机`"。

## 2、主机配置文件

主从所有配置项都配置在[`mysqld`]节点下，且都是小写字母。

**具体参数配置如下：**

* 必须

  ```properties
  #主服务器唯一ID
  server-id=1
  
  #启用二进制日志，知名路径。最好选择指定的目录下，该目录最好不是数据目录下（这里还是数据目录下），下面表示的含义是位于数据目录下，文件名以atguigu-bin开头，例如atguigu-bin.000001
  log-bin=atguigu-bin
  ```

* 可选

  ```properties
  #[可选]0（默认）表示读写，1表示只读（从机）
  read-only=0
  
  #设置日志文件保留的时长，单位是秒
  binlog_expire_logs_seconds=6000
  
  #设置单个二进制日志大小，此参数的最大和默认值是1GB
  max_binlog_size=200M
  
  #[可选]设置不要复制的数据库
  binlog-ignore-db=test
  
  #[可选]设置需要赋值的数据库，默认全部记录。比如binlog-do-db=atguigu_master_slave
  binlog-do-db=需要复制的主数据库名字
  
  #[可选]设置binlog格式
  binlog_format=STATEMENT
  ```

此时，我们就可以在/etc/my.cnf中去修改配置参数

重启后台mysql服务，使配置生效。

> 注意：
>
> 先搭建完主从复制，再创建数据库。
>
> MySQL主从复制起始时，从机不继承主机数据。



## 3、从机配置文件

* 必选

  ```properties
  #设置从服务器唯一ID
  server-id=2
  ```

  

* 可选

  ```properties
  #[可选]启动中继日志，并指定中继日志文件前缀
  relay-log=mysql-relay
  ```

配置完成后，重启后台mysql服务，使配置生效

注意：

主从机都要关闭防火墙

```shell
systemctl stop firewalld.service 
```





## 4、主机：建立账户并授权

如果使用的是MySQL5.7，使用下面语句就可以建立账户并授权slave：

```sql
GRANT REPLICATION SLAVE ON *.* TO 'salve1'@'从机器数据库IP' IDENTIFIED BY '密码';
```

如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：

```sql
#创建用户slave1
CREATE USER 'slave1'@'%' IDENTIFIED BY '密码';

#赋予slave1用户权限，这个权限是主从复制的权限，表示给slave任何库下的任何表主从复制的权限
GRANT REPLICATION SLAVE ON *.* TO 'slave1'@'%';

#此语句必须执行
ALTER USER 'slave1'@'%' IDENTIFIED WITH mysql_native_password BY '061535asd';

flush privileges;
```



执行完成之后，查询Master的状态，并记录下File和Position的值

```sql
show master status;
```

![image-20240501133645562](.\images\image-20240501133645562.png)

记录下其中File和Position的信息，File：atguigu-bin.000001，Position：1136。其中表示的含义是二进制日志文件，以及当前位置的信息，我们之后进行主从复制，就是从这个二进制日志文件，以及当前的位置进行复制。

注意：执行完此步骤后，不要再操作主服务器MySQL，防止主服务状态值变化。



## 5、从机：配置需要复制的主机

**`步骤1：从机上复制主机的命令`**

```sql
CHANGE MASTER TO
MASTER_HOST='主机的IP地址',
MASTER_USER='主机用户名',
MASTER_PASSWORD='主机用户名密码',
MASTER_LOG_FILE='主机二进制日志文件',
MASTER_LOG_POS=位置值;
```

这个主机用户名，是刚才主机创建出来的用于主从复制的用户slave1，二进制日志文件也就是上面查询出来的二进制日志文件名atguigu-bin.000001，位置即上面的POS值：1136。

所以，复制主机的命令是：

```sql
CHANGE MASTER TO
MASTER_HOST='192.168.110.10',
MASTER_USER='slave1',
MASTER_PASSWORD='061535asd',
MASTER_LOG_FILE='atguigu-bin.000001',
MASTER_LOG_POS=1136;
```

在从机的mysql指令中，执行上述语句。

如果之前配置过主从架构，并且从机还未停止，此时就会去报错：

![image-20240501134741594](.\images\image-20240501134741594.png)

此时我们需要去stop SLAVE。



**`步骤2：启动slave同步`**

在从机中，使用mysql指令执行start slave，启动slave同步：

```sql
START SLAVE;
```

此时如果报错：

![image-20240501135006005](.\images\image-20240501135006005.png)

说明原本已经开启过slave同步，从机中已经存在中继日志了。

可以执行如下操作，删除之前的中继日志信息。然后重新去执行之前的CHANGE MASTER TO...语句即可。

```sql
reset slave; #删除slave数据库的relay log日志文件，并重新启用新的relay log文件
```





我们开启SLAVE同步后，可以去查看一下同步状态：

```sql
SHOW SLAVE STATUS\G
```

![image-20240501135255834](.\images\image-20240501135255834.png)

如果Slave_IO_Running与Slave_SQL_Running都是Yes时，就表示主从同步成功。





## 6、测试

经过上面这些操作，主从架构就已经搭建成功了，接下来我们对主从复制进行复制。

我们先去主服务器中去创建一个数据库：

```sql
create database atguigu_master_slave;

use atguigu_mster_slave;
```

然后，我们去从服务器中查看所有的数据库，就会发现刚刚在主服务器中创建的数据库：

![image-20240501154050661](.\images\image-20240501154050661.png) 

在主服务器中，创建表student，然后往表中插入两条数据：

```sql
create table student(id int, name varchar(15));

insert into student(id, name) values(1, 'tom');

insert into student(id, name) values(2, @@hostname);
```

此时，主服务器中就可以查看到这两条数据：

![image-20240501154445623](.\images\image-20240501154445623.png) 

然后我们去从服务器中查看该表：

![image-20240501154511875](.\images\image-20240501154511875.png) 

第二条数据使用的是全局属性hostname作为name列的值，该值在两台主机中不一致。在主机中，hostname属性的值为zhuji，而在从机中，hostname属性的值为congji，所以两台主机在执行insert逻辑操作的时候，使用的属性值也是不一样的，创建出来的表信息也是不一样的。



## 7、停止主从同步

在从机中执行命令：

```sql
STOP SLAVE;
```

此时，我们再去查看一下从机的属性：

![image-20240501155340094](.\images\image-20240501155340094.png)

发现Slave_IO_Running为NO、Slave_SQL_Running也为NO。



如果停止从服务器复制功能，再使用需要重新配置主从，否则就会报错。

重新配置主从（在从机上执行）：

```sql
stop slave;

reset master; #删除master中的所有binlog文件，并将日志文件情况，重新开始所有的新的日志文件（慎用）
```





## 8、扩展：多主多从

![image-20240501190759604](.\images\image-20240501190759604.png)

对于如何搭建多主多从架构，以及如何去水平分表，修改写请求与读请求访问的服务器，请查看《MyCat》中间件的内容。









# binlog格式的说明

**binlog有三种格式，分别为：`Statement`、`Row`以及`Mixed`。**

**`格式1：Statement模式`**

```properties
binlog_format=STATEMENT
```

在5.7.7之前，binlog的默认格式是Statement。

Statement模式**`只记录执行的SQL，不记录每一行数据的变化`**。这样一来，就有可能会出现主从不一致的情况。

比如，插入一条数据：

```sql
insert into student(id, name) values(2, @@hostname);
```

如果使用的是Statement模式，主机执行了上述的语句，从机进行复制时，直接将上面的SQL语句复制过来进行执行，此时，由于主机名和从机名不一致，在主服务器和从服务器的数据库中，就会得到两个不一样的数据。

即Statement模式只记录SQL语句，从机在复制时直接将SQL复制，然后执行，不会去管主机的执行情况。

再比如，如果一些SQL中包含了函数，比如说uuid()函数，每次执行的时候都会生成一个随机字符串，在master中记录了uuid，当同步到slave之后，再次执行，就获取到另外一个结果了。

**优点**：

* 不需要记录每一行的变化，减少了binlog日志量，文件较小
* binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况。
* binlog可以用于实时的还原，而不仅仅用于复制。

**缺点**：

* 可能会出现数据一致性问题。
* INSERT...SELECT会产生比Row模式更多的行级锁
* 复制需要进行全表扫描的UPDTAE，需要比Row请求更多的行级锁
* 对于有AUTO_INCREMENT字段的InnoDB表而言，INSERT语句会阻塞其他INSERT语句
* 对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而Row模式下，只会对那个发生变化的记录产生影响
* 执行语句如果出错的话，会消耗更多资源
* 数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错

**适用场景：**

* 基于SQL语句的复制：当使用基于SQL语句的复制技术，或者要求Binlog具有高可读性，可以选择Statement模式。



**`格式2：Row模式`**

```properties
binlog_format=ROW
```

在MySQL5.7.7之后，默认的binlog格式是Row。

Row格式不记录SQL语句的上下文信息，记录的是某一条记录被修改成什么样了。

即：**`Row格式不记录具体执行的SQL语句，而是记录数据行的变更情况`**。

Row格式的日志内容会非常清楚的记录下每一行数据修改的细节，这样就不会出现Statement中存在的那种数据无法被正常复制的情况。

例如：往表中插入一条数据，这条数据中使用到了uuid()函数，uuid()函数是去随机生成一串字符串，如果我们使用的是Row模式，在二进制日志文件中，记录的就是插入的具体内容，我们进行主从复制时也会将具体的内容复制，所以此时无需担心复制过去的内容不一致。

**优点：**

* 任何情况都可以被复制，这对复制来说是最安全可靠的。
* 多数情况下，从服务器上的表如果有主键的话，复制就会快了很多
* 复制以下几种语句时的行锁更少：INSERT...SELECT、包含Auto_increment字段的INSERT，没有附带条件或者并没有修改很多记录的update或delete语句。
* 执行INSERT、UPDATE、DELETE语句时锁更少
* 从服务器上采用多线程来执行复制称为可能

**缺点：**

* binlog大很多
* 复杂的回滚时binlog中会包含大量的数据
* 主服务器上执行UPDATE语句时，所有发生变化的记录都会写到binlog中，而statement模式只会写一次，这样就会频繁发生binlog的并发写问题
* 无法从binlog中看到都复制了哪些语句

**适用场景：**

* 要求更高精度的数据复制：当要求更高的数据复制精度，或者在一些需要避免非确定性问题的场景中，可以选择Row模式。



**`格式3：Mixed模式`**

```properties
binlog_format=MIXED
```

从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。

在Mixed模式下，一般的语句修改使用statement格式保存binlog。如一些函数，statement无法完成主从复制的操作，无法保证主从机数据的一致性时，则采用Row格式保存binlog。

MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在statement和row之间选择一种。





# 四、同步数据一致性问题

**`主从同步的要求：`**

* 读库和写库数据一致
* 写数据必须写到写库
* 读数据必须到读库（不一定）

## 1、理解主从延迟问题

我没看懂，后面再学习吧









## 2、主从延迟问题的原因解释







## 3、如何减少主从延迟







## 4、如何解决一致性问题







# 五、总结

![image-20240502130133465](.\images\image-20240502130133465.png)