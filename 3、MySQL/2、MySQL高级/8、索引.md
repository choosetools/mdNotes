[TOC]



# 一、为什么要使用索引？

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则`通过索引查找`相关数据，如果不符合则需要`全表扫描`，即需要一条一条地查找记录，直到找到与条件符合的记录。

![image-20240403093346588](.\images\image-20240403093346588.png)

如上图所示，数据库没有索引的情况下，数据`分布在磁盘不同的位置上`，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果`数据顺序摆放`，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col2=89这条记录，就需要逐行去查找、去比较。从Col2=34开始，进行比较，发生不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘IO才能找到。**`时间复杂度为O(n)`**。

假如给数据使用**`二叉树`**这样的数据结构进行存储，如下图所示：

![image-20240403093737071](.\images\image-20240403093737071.png)

对字段Col 2添加了索引，就相当于在硬盘上为Col 2维护了一个搜一年的数据结构，即这个`二叉搜索树`。二叉搜索树的每个结点存储的是**`(k, v)结构`**，key是Col 2，value是该key所在行的文件指针（地址）。比如：该二叉树的根节点就是（34,0x07）。现在对Col 2添加了索引，这时再去查找Col2=89这条记录的时候会先去查找该二叉搜索树，读34到内存，89>34，去右侧查找；读89到内存，89 == 89，找到了数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要`查找两次`就可以定位到记录的地址，查询速度就提高了。

这就是我们为什么要建索引，目的就是为了`减少磁盘I/O的次数`，加快查询速率。

索引**`减少了磁盘I/O的次数`**，磁盘I/O所花费的时间远远大于与内存I/O所花费的时间。





# 二、索引及其优缺点

## 1、索引概述

MySQL官方对索引的定义为：**`索引（Index）是帮助MySQL高效获取数据的数据结构`**。

**索引的本质**：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现`高级查找算法`。

`索引是在存储引擎中实现的`，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的`最大索引数`和`最大索引长度`。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

## 2、优点

1. 类似于大学图书馆建书目索引，提高数据检索的效率，`降低数据库的IO成本`，这也是创建索引最主要的原因。
2. 通过创建唯一索引，可以保证数据库中每一行`数据的唯一性`。
3. 在实现数据的参考完整性方面，可以`加速表和表之间的连接`。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
4. 在使用分组和排序子句进行数据查询时，可以显著`减少查询中分组和排序的时间`，降低CPU的消耗。

## 3、缺点

增加索引也有很多不利的方面，主要表现在如下几个方面：

1. 创建索引和维护索引需要`消耗时间`，并且随着数据量的增加，所消耗的时间也会增加。
2. 索引需要占`磁盘空间`，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，`存储在磁盘上`，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
3. 虽然索引大大提高了查询速度，同时却会`降低更新表的速度`。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

> 提示：
>
> 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。

 



# 三、InnoDB中的索引

## 1、一个简单的索引设计方案

首先，创建一个表：

```sql
CREATE TABLE index_demo(
	c1 INT,
	c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1)
)ROW_FORMAT = Compact;
```

这个新建的表index_demo表中有两个INT类型的列，1个CHAR(1)类型的列，而且我们规定c1为主键，这个表使用`Compact`行格式来实际存储记录。

这里我们简化了index_demo表的行格式示意图：

![image-20240403110018420](.\images\image-20240403110018420.png)

我们只在示意图里展示记录的几个部分：

* `record_type`：记录头信息的一项属性，表示记录的类型，`0`表示普通记录、`2`表示最小记录、`3`表示最大记录，`1`表示目录项记录。
* `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁，实际上就是一个指向下一条记录的指针。
* `各个列的值`：这里值记录在index_demo表中的三个列，分别是c1、c2和c3。
* `其他信息`：除了上述三种信息以外的所有信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![image-20240403110451909](.\images\image-20240403110451909.png)

由于InnoDB存储引擎把数据都是以页的形式存储

把一些记录放到页里的示意图就是：

![image-20240403110624259](.\images\image-20240403110624259.png)

**设计方案：**

我们在根据某个搜索条件查找一些记录为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条阿金匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速定位到需要查找的记录在哪些数据页中该怎么办？我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下面这些事情：

1. **`下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值`**

假设：每个数据页最多可以存放3条记录（实际上一个数据页非常大，可以存放很多记录）。有了这个假设，我们向index_demo表插入3条记录：

```sql
INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
```

那么这些记录已经按照主键值的大小串联成一个单向链表了，如下图所示：

![image-20240403111223815](.\images\image-20240403111223815.png)

从图中可以看出来，index_demo表中的3条记录都被插入到编号为10的数据页中了，此时我们再来插入一条记录：

```sql
INSERT INTO index_demo VALUES(4, 4, 'a');
```

因为页10最多只能存放3条记录，所以我们不得不分配一个新页：

![image-20240403111342779](.\images\image-20240403111342779.png)

注意，新分配的数据页编号可能并不是连续的，它们只是通过维护着上一个页和下一个页的编号而建立了`链表关系`。另外，页10中用户记录的最大的主键值是5，而页28中有一条记录的主键值是4，因为5>4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次`记录移动`，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

![image-20240403111717593](.\images\image-20240403111717593.png)

这个过程表明了在对页的记录进行增删改查的过程中，我们必须通过一些诸如`记录移动`的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为**`页分裂`**。

2. **`给所有的页简历一个目录项`**

由于数据页的`编号可能是不连续`的，所以在向index_demo表中插入许多条记录后，可能是这样的效果：

![image-20240403111937257](.\images\image-20240403111937257.png)

因为这些16KB的页在物理存储上是`不连续`的，所以如果想从这么多页中根据主键值`快速定位某些记录所在的页`，我们需要给它们做一个`目录`，每个页对应一个目录项，每个目录项包括下面两个部分：

* 页的用户记录中最小的主键值，我们用`key`表示
* 页号，我们用`page_no`表示

所以我们为上边几个页做好的目录就像这样子：

![image-20240403112145617](.\images\image-20240403112145617.png)

以页28为例，它对应目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5.我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录，具体查找过程分两步：

1. 先从目录项中根据二分法快速确定主键值为20的记录在目录项3中（因为12 < 20 < 209），它对应的页是页9.
2. 再根据前边说的在页中查找记录的方法去页9中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有个别名，叫做**`索引`**。



## 2、InnoDB中索引设计方案

### 迭代1次：目录项记录的页

上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用`二分法`快速定位具体的目录项，而假设所有目录项都可以在物理存储器上`连续存储`，但是这样做有几个问题：

* **Innodb是使用`页`作为管理存储空间的基本单位**，最多能保证**`16kb`**的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
* 我们时常会对`记录进行增删`，假设我们把`页28`中的所有记录全部都删除了，那也就意味着`目录项2`没有存在的必要，这就需要把`目录项2`也删除，同时把`目录项2`后面的所有目录项都向前移动，这样的操作效率很差。

所以，我们要灵活地管理所有目录项，使用逻辑上的连续存储，而不是物理上的连续存储。

我们发现，目录项其实长得和用户记录差不多，只不过目录项中的两列是`主键`和`页号`而已。为了和用户记录进行区分，我们把这些用来表示目录项的记录称为**`目录项记录`**。那InnoDB怎么区分一条记录是普通的`用户记录`还是`目录项记录`呢？使用记录头信息里的`record_type`属性，它的各个取值代表的意思如下：

* `0`：普通的用户记录
* `1`：目录项记录
* `2`：最小记录
* `3`：最大记录

我们把前边使用到的目录项放到数据页中的样子就是这样：

![image-20240403142446185](.\images\image-20240403142446185.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调`目录项记录`和普通的`用户记录`的**`不同点`**：

* `目录项记录`的`record_type`是1，而`普通用户记录`的`record_type`的值是0。
* 目录项记录只有主键值和页的编号两个列，而普通用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。
* 记录头信息里还有一个min_rec_mask属性，只有存储目录项记录的页中主键值最小的目录项记录值为1，其他记录值为0.

**`相同点`**：两者用到是一样的数据页，都会为主键值生成**`Page Directory`（页目录）**，从而在按照主键值进行查找时可以使用**二分法**来加快查询速度。

现在以查找主键为20的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12 < 20 < 209，所以定位到对应的记录所在的页就是页9.
2. 再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录。



### 迭代2次：多个目录项记录的页

虽然说目录项记录中只能存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有`16kb`大小，能够存放的目录项记录也是有限的，如果表中的数据很多，以至于一个数据页不足以存放所有的目录项记录，如何处理？

这里我们假设一个存储目录项记录的页最多只能存放4条目录项记录，所以如果此时我们再向上图中插入一条主键值为320的用户记录的话，那就需要分配一个新的存储目录项记录的页：

![image-20240403144106501](.\images\image-20240403144106501.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

* 为存储该用户记录而新生成了页31.
* 因为原先存储目录项记录的页30容量已满，所以不得不需要一个新的页32来存放页31对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为20的记录为例：

1. `确定目录项记录页`

   我们现在的存储目录项记录的页有两个，即页30和页32，又因为页30表示的目录项的主键值的范围是[1, 320)，页32表示的目录项的主键值不小于320，所以主键值为20的记录对应的目录项记录在页30中。

2. `通过目录项记录页确定用户记录真实所在的页`

   在一个存储目录项记录的页中，通过二分法查找，定位用户记录所在的页。

3. `在真实存储用户记录的页中定位到具体的记录`



### 迭代3次：目录项记录页的目录页

问题来了，在这个查询步骤的第一步中我们需要定位存储目录项记录的页，但是这些`页是不连续的`，如果我们表中的数据非常多则会`产生很多存储目录项记录的页`，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页**再生成一个更高级的目录**，就像是一个多级目录一样，`大目录里嵌套小目录`，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![image-20240403145050733](.\images\image-20240403145050733.png)

如图，我们生成了一个存储更高级目录的页33，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在[1, 320)之间，则到页30中查找更详细的目录项记录，如果主键值不小于320的话，就到页32中查找更详细的目录项记录。

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，我们可以用下面这个图来描述：

![image-20240403145257048](.\images\image-20240403145257048.png)

这个数据结构，就是**`B+树`**。

### B+树

不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为**`节点`**。

从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也称为**`叶子节点`**，其余用来存放目录项的节点称为**`非叶子节点`**或者**`内节点`**，其中B+树最上边的那个节点称为**`根节点`**。

一个B+树的节点其实可以分为好多层，规定最下边的那层，也就是我们存放用户记录的那层为第**`0`**层，之后依次往上加。在真实环境中，一个页中存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：

* 如果B+树只有一层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录。
* 如果B+树有2层，最多能存放1000x100=100000条记录。
* 如果B+树有3层，最多能存放1000x1000x100=100000000条记录
* 如果B+树有4层，最多能存放1000x1000x1000x100=100000000000条记录。

所以，在一般情况下，我们用到的**`B+树都不会超过4层`**，那我们通过主键值去查找某条记录最多只需要4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的**`Page Directory`（页目录）**，所以在页面内也可以通过**`二分法`**实现快速定位记录。

树的每一个层级，都是代表了用户需要去磁盘I/O的次数。

**精确查找过程：**

用户去磁盘首先读取根节点的页，读取到内存中，然后进行二分法查找，查找数据应该在下一层的哪一页上；然后再去磁盘中读取下一层级的页，读取到内存中，进行二分法查找......直到读取到叶子结点的页，获取到要查找的数据信息。由此可知：**`树的层级，代表了与磁盘I/O的次数。树的层次越低，磁盘I/O的次数就越少。`**

我们开发中，B+树的层次一般不会超过4层。

## 3、InnoDB中常见索引概念

### 聚簇索引

**聚簇索引：`所有的用户记录都存在了叶子结点，数据即索引，索引即数据`。**

我们来使用前面的图，来解释一下什么是聚簇索引：

![image-20240403145050733](.\images\image-20240403145050733.png)

**特点：**

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

   1. `页内`的记录是按照主键的大小顺序排成一个`单向链表`。
   2. 各个`存放用户记录的页`也是根据页中用户记录的主键大小顺序排成一个`双向链表`。
   3. `存放目录项记录的页`分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个`双向链表`。

2. B+树的`叶子节点`存储的是`完整的用户记录`。

   所谓完整用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为**`聚簇索引`**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。



在上图中，所有的用户数据信息都保存在了索引的叶子节点上，构成了整个的树状索引结构，这就是聚簇索引。

InnoDB中，MySQL8.0之后，数据、索引以及表的结构全都存放在`.ibd`文件中，**InnoDB就是聚簇索引**，数据即索引，索引即数据，数据和索引存放在一个文件里面。

但是MyISAM表底层是将数据和索引分开的，数据存放在`.MYD`文件中，索引存放在`.MYI`文件里，**MyISAM就是非聚簇索引**。





**优点：**

* **`数据访问更快`**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。
* 聚簇索引对于主键的`排序查找`和`范围查找`速度非常快。
* 按照聚簇索引排序顺序，查询一定范围数据的时候，由于数据都是紧密相连，数据库从不用多个数据块中提取数据，所以`节省了大量的IO操作。`

**缺点：**

* `插入速度验证依赖于插入顺序`，按照主键的顺序插入是最快的，插入到最后就不会出现页分裂的情况。页分裂严重影响性能。因此，对于InnoDB表，我们一般会定义一个**`自增的ID为主键`**。
* `更新主键的代价很高`，因为更新主键，需要按照顺序，将修改后的数据记录移动到相应的位置，其他的数据记录位置也需要更改。因此，对于InnoDB表，我们一般定义**`主键为不可更新`**。
* `二级索引访问需要两次索引查找`，第一次找到主键值，第二次根据主键值找到行数据。

**限制：**

* 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MyISAM并不支持聚簇索引。

* 一个MySQL`表只能有一个聚簇索引`，一般情况下就是使用数据表的**`主键`**来作为索引。
* 如果没有定义主键，InnoDB会选择`非空的唯一索引`代替。如果没有这样的索引，InnoDB表会隐式地定义一个主键，就是为了能够实现聚簇索引。
* 为了充分利用聚簇索引的特性，InnoDB表的主键列尽量`选用有序的顺序id`，而不建议用无序的id，比如UUID、MD5、字符串作为主键无法保证数据的顺序增长。



**注意：**

聚簇索引的查找操作，只适用于InnoDB表，并且只适用于**`使用主键作为匹配条件`**的查找，如果筛选条件不是主键，则不能使用聚簇索引。因为InnoDB表中的B+树都是按照主键进行排序的，进行筛选时是按照主键进行筛选的。



### 二级索引（辅助索引、非聚簇索引）

上边介绍的`聚簇索引`只能在搜索条件是**`主键值`**时才能发挥作用，因为B+树中大数据都是依照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到尾沿着链表依次遍历记录一遍。

答案：我们可以`多建几棵B+树`，不同的B+树中的数据采用不同的排序规则。比方说我们用非主键列c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示：

![image-20240403174751079](.\images\image-20240403174751079.png)

这个B+树与上边介绍的聚簇索引有几处**不同**：

* 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：
  * 页内的记录是按照c2列的大小顺序排成一个`单向链表`。
  * 各个存放`用户记录的页`也是根据页中记录的c2列大小顺序排成一个`双向链表`。
  * 存放`目录项记录`的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个`双向链表`。
* B+树的叶子节点存储的并不是完整的用户记录，而只是**`c2列+主键`**这两个列的值。
* 目录项记录中不再是主键+页号的搭配，而变成了`c2列+页号`的搭配。



所以，如果我们现在想通过c2列的值查找某些记录的话，就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为4的记录为例，**查找过程案例如下**：

1. 确定目录项记录

   根据根页面，也就是页44，可以快速定位到目录项记录所在的页为`页42`（因为2 < 4 < 9）

2. 通过目录项记录页确定用户记录真实所在的页

   在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 < 4 <= 4，所以确定实际存储用户记录的页在`页34`和`页35`中。

3. 在真实存储用户记录的页中定位到具体的记录。

   到`页34`和`页35`中定位到具体的记录。

4. 但是这个B+树的叶子节点中的记录只存储了`c2`和`c1`（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。

实际上，非聚簇索引查找就是比聚簇索引多了一个查找步骤，先去在非聚簇索引中查找对应数据的主键数据，然后根据主键再去聚簇索引中找到对应的数据信息。

**`概念：回表`**

我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到`聚簇索引中再查一遍`，这个过程称为**`回表`**。也就是根据c2列的值查询一条完整的用户记录需要用到**2棵B+树**。

**`问题`**：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到非聚簇索引的叶子节点不行么？

**`回答：`**

如果把完整的用户记录放到叶子节点是不需要回表了，但是过于`占用内存`了。相当于每建立一棵B+树都需要把所有的用户记录都拷贝一遍，这就有点浪费存储空间了。

因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为**`二级索引`**（英文名secondary index），或者**`辅助索引`**。由于我们使用的是c2列作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。

InnoDB存储引擎中，底层只有一个聚簇索引，可以有多个二级索引（非聚簇索引）。

![image-20240403180935021](.\images\image-20240403180935021.png)

**小结：**聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：

1. `聚簇索引的叶子节点`存储的就是我们的`数据记录`，`非聚簇索引的叶子节点`存储的是`数据位置`。非聚簇索引不会影响数据表的物理存储顺序。
2. **`一个表只能有一个聚簇索引`**，因为只能有一种排序存储的方式，但**`可以有多个非聚簇索引`**，也就是多个索引目录提供数据检索。
3. 使用聚簇索引，数据查询记下来高，但是如果对数据进行插入、删除、更新操作，效率会比非聚簇索引低。



### 联合索引

**联合索引也属于非聚簇索引。**

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比如说我们想让B+树按照`c2和c3列`的大小进行排序，这个包含两层含义：

* 先把各个记录和页按照c2列进行排序。
* 在记录的c2列相同的情况下，采用c3列进行排序

为c2和c3列建立的索引的示意图如下：

![image-20240403185219993](.\images\image-20240403185219993.png)

如图所示，我们需要注意下面几点：

* 每条`目录项记录`都由`c2、c3、页号`这三个部分组成，每条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
* B+树`叶子节点`处的用户记录由`c2、c3和主键c1列`组成。

注意一点，以c2和c3列的大小为排序规则建立的B+树称为**`联合索引`**，本质上也是一个**二级索引**。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

* 建立联合索引只会建立如上图一样的1棵B+树；
* 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。



## 4、InnoDB的B+树索引注意事项

### `根页面（根节点）位置不动`

我们前面介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点画出来，然后再画存储目录项记录的内节点，但是实际上B+树的形成过程是这样的：

* 每当为每个表创建一个B+树索引的时候，都会先为这个索引创建一个**根节点**页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。
* 随后向表中插入用户记录时，先把用户记录存储到**根节点**中。
* 当根节点中可用的空间用完时，继续插入记录，此时会将根节点中的所有记录**复制**到一个新分配的页，比如页a中，然后对这个新页进行**`页分裂`**的操作，得到一个新页，比如页b。这时新插入的记录根据键值的大小就会被分配到页a或页b中，而根节点便升级为存储目录项记录的页。

这个过程特别注意的是：一个B+树索引的根节点自诞生起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号变回被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

### `内节点中目录项记录的唯一性`

我们知道B+树索引的内节点中目录项记录的内容是`索引列+页号`的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿`index_demo`表为例，假设这个表中的数据是这样的：

![image-20240403200235671](.\images\image-20240403200235671.png)

如果二级索引中目录项记录的内容给只是**索引列 + 页号**的搭配的话，那么为c2列建立索引后的B+树应该长这样：

![image-20240403200306326](.\images\image-20240403200306326.png)

此时，我们想新插入一行记录，其中c1、c2、c3的值分别是9、1、'c'，此时就会出现一个问题：由于页3中存储的目录项记录是由c2列 + 页号的值组成的，页3中的两条目录项记录对应的c2列的值都是1，而我们新插入的这条记录的c2列的值也是1，那么这条记录是该放到页4还是页5中呢？这个时候就不清楚了。

所以，为了能够让新插入记录能够找到自己应该在哪个页中，我们需要**`保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的`**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分组成的：

* 索引列的值
* 主键值
* 页号

也就是我们把**主键值**也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：

![image-20240403201055302](.\images\image-20240403201055302.png)

这样我们再插入记录(9, 1, 'c')时，由于页3中存储的目录项记录是由`c2列 + 主键 + 页号`的值构成的，可以先把新纪录的c2列的值和页3中各目录记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列 + 主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到页5中。

### `一个页面至少存储2条记录`

很好理解，如果一个页面存放一条记录太浪费了，不如不使用页面，所以一个页面至少存放2条记录。





# 四、MyISAM的索引方案

**对于MySQL官方来说，B树就是B+树**

**`B树索引适用存储引擎如表所示：`**

| 索引/存储引擎 | MyISAM | InnoDB | Memory |
| ------------- | ------ | ------ | ------ |
| BTree索引     | 支持   | 支持   | 支持   |

即使多个存储引擎支持同一种类型的索引，但是它们的实现原理也是不同的。InnoDB和MyISAM默认的索引是Btree索引；Memory默认的索引是Hash索引。

MyISAM引擎使用BTree作为索引结构，叶子节点的data域存放的是**`数据记录的地址`**。

### MyISAM索引的原理

下面是MyISAM索引的原理图。

我们知道InnoDB中索引即数据，也就是聚簇索引的B+树的叶子节点已经把完整的用户记录包含了，而MyISAM的索引方案虽然也使用树形结构，但是却**`将索引和数据分开存储`**。

* 将表中的记录`按照记录的插入顺序`单独存储在一个文件中，称之为**数据文件**（`.MYD文件`）。这个文件并不划分为若干数据页，有多少记录就往这个文件中塞多少记录，由于在插入数据的时候并没有刻意按照主键大小排序（MyISAM中可以没有主键），所以我们并不能在这些数据上使用二分法进行查找。
* 使用MyISAM存储的表会把索引信息另外存储到一个称为**索引文件**的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是**`主键值 + 数据记录地址`**的组合。

![image-20240403205553130](.\images\image-20240403205553130.png)

这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引（primary key）示意。可以看出**`MyISAM的索引文件仅仅保存数据记录的地址`**。在MyISAM中，主键索引和二级索引在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：

![image-20240403205935727](.\images\image-20240403205935727.png)

同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果制定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

**说明：**

> MyISAM中没有聚簇索引，全都是二级索引，因为MyISAM表可以不去创建主键，所以不会去创建聚簇索引，就算创建了主键，对应的B+树索引的叶子节点存放的也是地址值。



### MyISAM与InnoDB索引对比

**`MyISAM的索引方式都是“非聚簇”的，与InnoDB一定包含一个聚簇索引不同。`**

**小结两者的区别：**

1、在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次**`回表`**操作，意味着MyISAM中建立的索引相当于**全部都是二级索引**。

2、InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

3、InnoDB的非聚簇索引data域存储相应记录**主键的值**，而MyISAM索引记录的是**地址**。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。

4、MyISAM的`回表操作是十分快速`的，因为是拿地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，相较于MyISAM是慢一点的。

5、**InnoDB要求表必须有主键，MyISAM中可以没有**。如果没有显式指定，MySQL会自动选择一个非空且唯一标识数据记录的列作为主键，如果不存在，则MySQL会自动为InnoDB表生成一个隐式字段作为主键，这个字段长度为6个字节，类型为长整型。

![image-20240403210718222](.\images\image-20240403210718222.png)





# 五、索引的代价

* **`空间上`**

每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的B+树由许多数据页组成，那就是很大一片存储空间。

* **`时间上`**

每次对表中的数据进行`增、删、改`操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值`从小到大的顺序排序`而组成了`双向链表`。不论是叶子节点中的记录，还是内节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

**总结**：**`一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。`**







# 假如没有任何索引，数据库是如何根据查询语句搜索数据的？

InnoDB存储引擎中，数据是以**`页`**的形式进行存放的。

数据页之间是组成`双向链表`的，数据页内部的数据行是组成单向链表的，而且数据行是根据主键从小到大排序的。每个数据页里都会有一个页目录，里面根据数据行的主键存放了目录，数据行分散到不同的槽位中。所以实际上每个数据页的目录里，就是这个页里每个主键跟所在槽位的映射关系，如下图所示：

![在这里插入图片描述](.\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4MzEzNQ==,size_16,color_FFFFFF,t_70)

假设要根据主键查找一条数据，过程就是：首先会先到数据页的页目录根据主键进行二分查找；然后通过二分查找快速定位到数据在哪个槽里，然后到那个槽中去，遍历槽位里的每一行数据，就可以快速找到主键对应的数据了。每个槽位里都有一组数据行，就在里面遍历查找就可以了。

但是假设是根据非主键的其他字段查找数据呢？（假设没有为该字段创建索引）

此时就无法使用主键的页目录来二分查找，只能进入到数据页里，根据单向链表依次遍历查找数据了，这就性能很差了。

假设要是没有建立任何索引，无论是根据逐渐查询，还是根据其他字段来查询，实际上都没有什么好的方式。

一个表里所有数据页都是组成双向链表的，遍历直接从第一个数据页开始遍历所有的数据页。从第一个数据页开始，得先把第一个数据页从磁盘上读取到内存buffer pool的缓存页中，由于根据其他字段进行查找，数据页中的页目录不起作用，只能在页里面的记录进行单向链表的一个一个地进行遍历查找，如下图：

![在这里插入图片描述](.\images\ahdoahsdoas.png)

假如第一个数据页没有找到那条数据呢？

没办法，只能一个一个地沿着页的双向链表，继续读取下一个数据页到缓存中，循环往复。

此时，实际上就是在做一个操作：全表扫描。

**由于未给查询的字段创建索引，并且要查询的字段不是主键（无法使用到聚簇索引中的页目录），此时，就只能按照页的顺序，将磁盘上的数据页加载到缓存页中，对数据页中的数据一个一个地进行遍历，查找相应的数据。**这就是**`全表扫描`**！

全表扫描的效率是非常差的，所以，当我们要经常对一个字段进行查询时，建议给这个字段创建相应的索引。

那么，接下来，我就将介绍如何给字段添加索引，以及哪些情况下推荐去创建索引。



# 一、索引的声明与使用

## 1、索引的分类

* 从`功能逻辑`上说，索引主要有4种，分别是普通索引、唯一索引、主键索引、全文索引。
* 按照`物理实现`方式，索引可以分为2种：聚簇索引和非聚簇索引。
* 按照`作用字段个数`进行划分，分成单列索引和联合索引。

1. **`普通索引`**

在创建普通索引时，不附加任何限制条件，只是用来提高查询效率。这类索引可以创建在`任何数据类型`中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引之后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以通过该索引进行查询。

2. **`唯一性索引`**

使用`UNIQUE参数`可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。

例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。

3. **`主键索引`**

主键索引即`聚簇索引`，是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOT NULL + UNIQUE，一张表里最多只有一个主键索引。

4. **`单列索引`**

在表中的`单个字段`上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可，一个表可以有多个单列索引。

5. **`多列（组合、联合）索引`**

多列索引是在表的`多个字段`组合上创建索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是**只有查询条件中使用了这些字段中的第一个字段时才会被使用**。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时遵循`最左前缀集合`。

6. **`全文索引`**

全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用`分词技术`等多种算法智能分析出文本文字中关键字的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。

使用参数`FULLTEXT`可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在`CHAR`、`VARCHAR`或`TEXT`类型及其系列类型的字段上，**`查询数据量较大的字符串类型字段时，使用全文索引可以提高查询速度`**。例如，表student字段information是TEXT类型，该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高字段information的速度。

全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。

随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solr、ES等专门的搜索引擎所替代。



7. **`补充：空间索引`**

使用参数`SPATIAL`可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间索引，而且索引的字段不能为空。



**`小结：不同的存储引擎支持的索引类型也不一样`**



## 2、创建索引

MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句**`CREATE TABLE`**中指定索引列，使用**`ALTER TABLE`**语句在存在的表上创建索引，或者使用**`CREATE INDEX`**语句在已存在的表上添加索引。

### 创建表时创建索引

* **`隐式的方式创建`**

使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义`主键约束`、`外键约束`或者`唯一性约束`，而不论创建了哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。

例如：

```sql
CREATE TABLE dept(
dept_id INT PRIMARY KEY AUTO_INCREMENT,
	dept_name VARCHAR(20)
);

CREATE TABLE emp(
	emp_id INT PRIMARY KEY AUTO_INCREMENT,
	emp_name VARCHAR(20) UNIQUE,
	dept_id INT,
	CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)
);
```

创建完成后，去查看这两个表的索引信息：

<img src=".\images\image-20240407115855508.png" align="left">

<img src=".\images\image-20240407115911401.png" align="left">

此时，在dept表创建了一个主键索引，即聚簇索引

在emp表中创建了三个索引，分别是主键索引、唯一索引（使用唯一约束名作为索引名）以及外键索引（使用外键约束名作为索引名）

由上述可知：

**在创建表时，声明`主键约束`、`唯一性约束`、`外键约束`的字段上，会自动地隐式添加相关索引。**



* **`显式的方式创建`**

**语法：**

```sql
CREATE TABLE table_name (
[col_name data_type]
[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length]) [ASC|DESC]
);
```

* `UNIQUE`、`FULLTEXT`和`SPATIAL`为可选参数，分别表示唯一索引、全文索引和空间索引。
* `INDEX`和`KEY`为同义词，两者的作用相同，用来指定创建索引。
* `index_name`指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名。
* `col_name`为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择。

* `length`为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；比如说length值为20，表示只取字符串前20个字段作为索引来创建。
* `ASC`或`DESC`指定升序或者降序的索引值存储。



#### 1、普通索引

例：

```sql
CREATE TABLE book(
     book_id INT ,
     book_name VARCHAR(100),
     authors VARCHAR(100),
     info VARCHAR(100) ,
     comment VARCHAR(100),
     year_publication YEAR,
     #创建普通索引，使用year_publication列作为索引值，没有指定索引名，默认使用列名作为索引名
     INDEX(year_publication)
);
```

此时，就会去创建book表的同时，创建了一个普通的索引，由于未指定索引名，所以默认使用列名作为索引名。

![image-20240407123323627](.\images\image-20240407123323627.png)





#### 2、唯一索引

当一个字段拥有唯一性约束时，会自动地帮我们创建唯一索引，当然这种方式是隐式的，现在我们来学习一下显式地创建唯一索引。

案例：

```sql
CREATE TABLE book1(
     book_id INT ,
     book_name VARCHAR(100),
     authors VARCHAR(100),
     info VARCHAR(100) ,
     comment VARCHAR(100),
     year_publication YEAR,
     #声明唯一性索引
     UNIQUE INDEX uk_idx_cmt(COMMENT)
);
```

![image-20240407125029259](.\images\image-20240407125029259.png)

此时，创建出来的索引就是唯一性索引，Non_unique的值为0.

> **给字段创建唯一索引，实际上相当于给字段添加了唯一性约束，该字段也会被限制不能有重复性数据。**





#### 3、主键索引

主键索引，就是在创建表时定义主键的方式进行创建。在InnoDB表中，主键索引就是聚簇索引，InnoDB表中一定有一个聚簇索引，我们只需要在创建表的时候指定主键即可创建。

例：

```sql
CREATE TABLE student (
id INT(10),
student_no VARCHAR(200),
student_name VARCHAR(200),
PRIMARY KEY(id)
);
```

这个时候，就为id主键创建了主键索引（聚簇索引）。

同时，如果想要去删除主键索引，可以通过删除主键的方式进行删除即可。

```sql
ALTER TABLE student
DROP PRIMARY KEY;
```





#### 4、单列索引和组合索引

我们之前创建的三个索引都属于单列索引，即使用表中的单个字段来创建索引。具体地单列索引创建方式请参考前面三种。

案例：创建单列索引

```sql
CREATE TABLE test2(
 id INT NOT NULL,
 name CHAR(50) NULL,
 INDEX single_idx_name(name(20))
 );
```

![image-20240407132609553](.\images\image-20240407132609553.png)

创建了单列索引，此时的Seq_in_index值为1



案例：创建组合（多列）索引

```sql
CREATE TABLE test3(
	id INT(11) NOT NULL,
	name CHAR(30) NOT NULL,
	age INT(11) NOT NULL,
	info VARCHAR(255),
	INDEX multi_idx(id,name,age)
);
```

这个时候，就创建了一个多列索引，我们去查看一下这个索引信息：

```sql
SHOW INDEX FROM test3;
```

![image-20240407131947755](.\images\image-20240407131947755.png)

创建了多列索引，有三个索引信息，三个索引信息的Seq_in_index的值分别为1、2、3。分别表示索引的第一个字段信息、第二个字段信息以及第三个一段信息。



**多列索引使用时的注意：**

> 1. **只有查询条件中使用了这些字段中的`第一个字段`时才会被使用**。例如，在表中的字段id、name和gender上建立一个多列索引idx_id_name_gender，只有在查询条件中使用了字段id时该索引才会被使用。
>
>    我们就说，多列索引是满足**`最左前缀原则`**的
>
>    例如：看看下面两个查询
>
>    ```sql
>    EXPLAIN SELECT * FROM test3 WHERE id = 1001 AND name = 'Tom';
>    ```
>
>    ![image-20240407132229447](.\images\image-20240407132229447.png)
>
>    由于此时，在查询条件中使用到了多列索引的第一个字段id，所以此时是使用到了多列索引进行查询的。
>
> 
>
>    ```sql
> EXPLAIN SELECT * FROM test3 WHERE name = 'Tom';
>    ```
>
>    ![image-20240407132325643](.\images\image-20240407132325643.png)
>
>    此时的查询条件中不包含多列索引的第一个字段id，所以此时，没有使用到多列索引进行查询。
>
>    所以，我们建议：**将最常用的检索条件字段放在多列索引的最前面。**
>
> 
>
> 2. 若查询使用到了组合索引中的所有字段，比如where id = 1 and name = 'tom' and gender = '男'，由于组合索引中的目录记录中包含这些字段，会先对第一个字段进行筛选，若有多个目录记录都满足第一个字段，即id=1，然后再对第二个字段进行筛选......直到找到那个最满足条件的那个目录记录，跳转到对应的页中。
>
>    在索引中，也是先对第一个字段进行排序，即id；如果id相同的话，再对第二个字段进行排序，即name......我们查找的数据，也是先对id进行筛选，若有多个记录的id相同，则再对name进行筛选......







#### 5、全文索引

`FULLTEXT`全文索引可以用于全文搜索。并且只为`CHAR`、`VARCHAR`和`TEXT`列创建索引。索引总是对整个列进行，不支持局部（前缀）索引。

举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：

```sql
CREATE TABLE test4(
	id INT NOT NULL,
	name CHAR(30) NOT NULL,
	age INT NOT NULL,
	info VARCHAR(255),
	FULLTEXT INDEX futxt_idx_info(info)
)ENGINE = MyISAM;
```

> 在MySQL5.7及之后版本中，InnoDB支持全文索引

语句执行完毕之后，使用SHOW INDEX查看表结构：

![image-20240407151905239](.\images\image-20240407151905239.png)

由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。

举例2：

```sql
CREATE TABLE papers(
	id INT NOT NULL AUTO_INCREMENT,
	title varchar(200) DEFAULT NULL,
	content text,
	PRIMARY KEY(id),
    #创建以title和content列为全文索引
	FULLTEXT KEY title (title, content)
)ENGINE=MyISAM DEFAULT CHARSET=utf8;
```

不同于like方式的查询，全文索引用`match+against`方式查询：

```sql
SELECT * FROM papers
WHERE MATCH(title, content) AGAINST('查询字符串');
```



**全文索引能够明显地提高查询效率**。

> 注意点：
>
> 1. 使用全文索引前，搞清除版本支持情况；
> 2. 全文索引比 like+% 快N倍，但是可能存在精度问题；
> 3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。





#### 6、空间索引

空间索引创建中，要求空间类型的字段必须为`非空`。

举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：

```sql
CREATE TABLE test5(
	geo GEOMETRY NOT NULL,
	SPATIAL INDEX spa_idx_geo(geo)
)ENGINE=MyISAM;
```

这语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：

```sql
SHOW INDEX FROM test5 \G
```

可以看到，test5表的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。







### 在已存在的表上创建索引

在已经存在的表中创建索引可以使用`ALTER TABLE`或者`CREATE INDEX`语句。

* **`方式一：使用ALTER TABLE语句创建索引`**

**语法：**

```sql
ALTER TABLE table_name 
ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC];
```

案例：

创建表book5：

```sql
CREATE TABLE book5(
	book_id INT,
	book_name VARCHAR(100),
    authors VARCHAR(100),
    info VARCHAR(100),
    comment VARCHAR(100),
    year_publication YEAR
);
```

现在去查看一下book5的索引：

```sql
SHOW INDEX FROM book5;
```

![image-20240407153052542](.\images\image-20240407153052542.png)

然后给book5表添加索引：

```sql
#给列comment添加一个普通索引
ALTER TABLE book5 
ADD INDEX idx_cmt(comment);

#给列book_name添加一个唯一索引
ALTER TABLE book5 
ADD UNIQUE uk_idx_bname(book_name);

#给列book_id、book_name和info添加一个多列索引
ALTER TABLE book5
ADD INDEX mul_bid_bname_info(book_id,book_name,info);
```

然后再去查看book5索引信息：

![image-20240407153402196](.\images\image-20240407153402196.png)



* **`方式二：使用CREATE INDEX创建索引`**

**语法：**

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC];
```

案例：

创建表book6：

```sql
CREATE TABLE book6(
	book_id INT,
	book_name VARCHAR(100),
    authors VARCHAR(100),
    info VARCHAR(100),
    comment VARCHAR(100),
    year_publication YEAR
);
```

给book6创建索引：

```sql
CREATE INDEX idx_cmt 
ON book6(comment);

CREATE UNIQUE INDEX uk_idx_bname 
ON book6(book_name);

CREATE INDEX mul_bid_bname_info
ON book6(book_id,book_name,info);
```

查看book6的索引信息：

![image-20240407153725846](.\images\image-20240407153725846.png)







---

## 3、删除索引

当我们要对表中的数据进行大量地增删改操作时，由于索引的存在，会影响增删改的效率，所以，**建议我们在进行大量增删改操作之前，先删除索引，然后在操作表数据完成之后，再添加索引。**

* **`方式一：使用ALTER TABLE删除索引`**

**语法：**

```mysql
ALTER TABLE table_name
DROP INDEX index_name;
```

例如：删除book表中名称为idx_bk_id的索引：

```sql
ALTER TABLE book
DROP INDEX idx_bk_id;
```





* **`方式二：使用DROP INDEX删除索引`**

**语法：**

```mysql
DROP INDEX index_name
ON table_name;
```

例如：删除book表中名称idx_aut_info的组合索引：

```sql
DROP INDEX idx_aut_info
ON book;
```





> **注意：**
>
> * 添加了`AUTO_INCREMENT`约束字段的主键索引和唯一索引不能被删除。因为AUTO_INCREMNET约束的字段必须是主键或者唯一的。
>
> * 对于联合索引来说，删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。
>
>   例如：
>
>   ![image-20240407155507606](.\images\image-20240407155507606.png)
>
>   在book6表中有一个联合索引：mul_bid_bname，使用book_id、book_name以及info列创建的。
>
>   此时，我们假如去删除book_id列，之后再查看book6表中的索引信息：
>
>   ```sql
>   ALTER TABLE book6
>   DROP column book_id;
>   ```
>
>   ![image-20240407155703846](.\images\image-20240407155703846.png)
>
>   就会发现，联合索引现在目前只包含了book_name和info字段，book_id字段被去除了。
>
>   当我们继续删除字段时，联合索引将会变为单列索引，当我们将这三个字段都删除时，该索引也会被删除。









---

## 4、查看索引

* **`方式一：通过查看创建表的语法来查看表的索引`**

例如：

```sql
SHOW CREATE TABLE book\G
```

![image-20240407123606806](.\images\image-20240407123606806.png)

这里就有一个普通索引，使用了KEY作为开头，表明指定创建索引，前面第一个'year_publication'是索引名，()中的'year_publication'表示使用该列去创建一个索引。





* **`方式二：直接去查看表中的索引`**

例如：

```sql
SHOW INDEX FROM book\G
```

![image-20240407124010914](.\images\image-20240407124010914.png)







---

# 二、MySQL8.0索引新特性

## 1、降序索引

降序索引以降序存储键值。虽然在语法上，从MySQL 4开始就已经支持降序索引的语法了，但实际上，只有到MySQL 8.0开始才真正有效（仅限于InnoDB引擎）。

**当我们要查询数据，由于在页中，用户记录默认是按照升序的顺序从左到右进行排序，当我们要按照降序查询时，使用页时需要进行`反向扫描`，这大大降低了数据库的效率。**

案例：

分别在MySQL 5.7和MySQL 8.0版本中创建数据表ts1：

```sql
create table ts1(
	a INT,
	b INT,
	#索引字段a按照升序排列，字段b按照降序排列
	INDEX idx_a_b(a ASC, b DESC)
);
```

这个idx_a_b的索引含义是：联合索引，在记录中，先按照字段a的大小升序排序，如果a字段的大小相同，再按照b字段大小降序排序。

创建成功后，我们来分别看看MySQL 5.7和MySQL 8.0中，该表的创建信息，MySQL5.7版本中数据表ts1的结构：

![image-20240407162010113](.\images\image-20240407162010113.png)

从结果上看出，索引其实依旧是默认的升序排序。

在MySQL 8.0版本中查看数据表ts1的结构，结果如下：

![image-20240407162249522](.\images\image-20240407162249522.png)

从结果上可以看出，一级排序：字段a依然是使用升序排序的，二级排序：字段b使用了降序排序。

下面继续测试降序索引在执行计划中的表现。

分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：

```sql
DELIMITER //
CREATE PROCEDURE ts_insert()
BEGIN
	DECLARE i INT DEFAULT 1;
	WHERE i < 800
	DO
		INSERT INTO ts1 select rand()*80000,rand()*80000;
		SET i = i + 1;
	END WHILE;
	commit;
END //
DELIMITER ;

#调用
CALL ts_insert();
```

执行完毕后，MySQL 5.7和MySQL 8.0的两个数据表中都包含了799条记录。

分别在MySQL5.7和MySQL8.0中，查看下面语句的执行计划：

```sql
EXPLAIN SELECT * FROM ts1 
ORDER BY a ASC, b DESC
LIMIT 5;
```

在MySQL5.7版本查询数据表ts1的执行计划，结果如下：

![image-20240407164129519](.\images\image-20240407164129519.png)

从结果可以看出，执行计划中扫描数rows为799，并且使用了Using filesort。

Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的，多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库的执行速度。

在MySQL8.0版本中查看数据表ts1的执行计划，结果如下：

![image-20240407164414126](.\images\image-20240407164414126.png)

我们可以看到，执行计划中，扫描数仅为5，并且没有使用Using filesort。MySQL8.0的效率很高。



**为什么这里MySQL8.0的查询效率要比MySQL5.7中的查询效率更好呢？**

原因在于，底层索引中，记录的排序顺序与MySQL8.0版本中，查询的顺序一致，这个时候就可以直接从左往右进行查询得到数据。

对于MySQL5.7来说，由于其不支持索引数据降序排序，其查询的顺序与数据排序的顺序不一致，导致MySQL5.7需要进行反向扫描，所以效率较低。



> **注意：**降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低，**效率最高时即索引中的顺序与查询中的顺序保持一致或完全相反**。
>
> 例如：
>
> 在MySQL5.7和MySQL8.0中分别查看以下的执行计划：
>
> ```sql
> EXPLAIN SELECT * FROM ts1
> ORDER BY a DESC, b DESC
> LIMIT 5;
> ```
>
> 此时，MySQL5.7中的执行结果为：
>
> ![image-20240407165021838](.\images\image-20240407165021838.png)
>
> MySQL8.0中的执行结果为：
>
> ![image-20240407164922000](.\images\image-20240407164922000.png)
>
> 此时，MySQL5.7的执行计划要明显好于MySQL8.0。



**启示：**

> 查询时若经常使用到的多级排序查询，比如：
>
> ```sql
> SELECT *
> FROM xxx
> ORDER BY a DESC, b ASC;
> ```
>
> 这个时候，我们就可以专门为该排序方式创建一个多列索引，使用该顺序为多级索引记录进行排序，这个时候，当我们使用到该排序方式查询时，速度就会快很多。





---

## 2、隐藏索引

在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。

从MySQL 8.0开始支持**`隐藏索引（inisible indexes）`**，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引，确认将索引设置为隐藏索引后系统不受任何影响，就可以彻底删除索引。**这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除**。

通过隐藏索引的方式，了解索引删除前后对查询性能的影响，来知道这个索引有没有作用，从而对索引进行修改或者删除，这也是隐藏索引的作用之一。

> 注意：
>
> 主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。

索引默认是可见的，在使用CREATE TABLE，CREATE INDEX或者ALTER TABLE等语句时可以通过**`VISIBLE`**或者**`INVISIABLE`**关键字来设置索引的可见性。



1. **`创建表时直接创建`**

**语法：**

```sql
CREATE TABLE table_name(
	col1 type1,
	col2 type2,
	...
	INDEX [indexname](col_name(length)) INVISIBLE
);
```

实际上，就是在创建表时创建索引的方式上，在最后添加了一个`INVISIBLE`关键字，表示创建出来的索引是隐藏索引。



案例：

```sql
CREATE table book7(
	book_id int,
	book_name VARCHAR(100),
	authors VARCHAR(100),
	info VARCHAR(100),
	comment VARCHAR(100),
	year_publication year,
	#创建不可见的索引
	INDEX idx_cmt(comment) invisible
);
```

去查看一下book7中的索引信息：

![image-20240407174304319](.\images\image-20240407174304319.png)

Visible的值为NO，表示该索引是隐藏的。

此时，我们测试一下是否查询时是否可以使用该索引：

```sql
EXPLAIN SELECT * from book7 where comment = 'mysql...';
```

查询结果：

![image-20240407174532589](.\images\image-20240407174532589.png)

此时未使用任何索引。





2. **`在已存在的表上创建`**

**方式一：使用CREATE INDEX语句**

```mysql
CREATE INDEX index_name
ON table_name(col_name(length)) INVISIBLE;
```

**方式二：使用ALTER TABLE语句**

```sql
ALTER TABLE table_name
ADD INDEX index_name(col_name(length)) INVISIBLE;
```

实际上，上面两种创建隐藏索引的方式，都是在原本创建索引方式的基础上，在最后加上**`INVISIBLE`**，表示创建的索引是隐藏的。



案例：

```sql
ALTER TABLE book7
ADD UNIQUE INDEX uk_idx_bname(book_name) invisible;
```

此时，去查看book7中的索引信息：

![image-20240407175035054](.\images\image-20240407175035054.png)



3. **`切换索引可见状态`**

已存在的索引可以通过如下语句切换可见状态：

```sql
#切换成隐藏索引
ALTER TABLE table_name ALTER INDEX index_name INVISIBLE;

#切换成非隐藏索引
ALTER TABLE table_name ALTER INDEX index_name VISIBLE;
```

将索引修改成非隐藏状态之后，优化器在进行查询的时候就可以进行选择。

> **注意**：当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。





4. **`使隐藏索引对查询优化器可见`**（了解）

默认情况下，隐藏索引对优化器是不可见的，查询优化器无法使用到索引对数据进行查询。

在MySQL8.x版本中，为索引提供一种新的测试方式，可以通过查询优化器的一个开关（`use_invisible_indexes`）来打开设置，使隐藏随你对查询优化器可见。

**如果use_invisible_indexes设置为`OFF`（默认），优化器会忽略隐藏索引。如果设置为`ON`，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。**

查看优化器的开关设置：

```sql
select @@optimizer_switch \G
```

查询结果：

![image-20240407180746557](.\images\image-20240407180746557.png)

在查询结果中，可以找到这个属性：`use_invisible_indexes=off`

此时属性配置值为off，说明隐藏索引默认对查询优化器不可见。

使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：

```sql
SET SESSION optimizer_switch="use_invisible_indexes=on";
```

SQL语句执行成功，再次查看查询优化器的开关设置。

![image-20240407190032837](.\images\image-20240407190032837.png)

此时，在输出结果中可以看到属性配置：`use_invisible_indexes=on`。

此时，查询优化器对于隐藏索引可见，在优化时会去考虑隐藏的索引。

一般情况下，我们不会去修改这个值，因为我们需要隐藏索引来给我们测试索引的作用和效果。





---

# 三、索引的设计原则

为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。**索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍**。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。

## 1、数据准备

**第一步：创建数据库、创建表**

```sql
CREATE DATABASE atguigudb1;

USE atguigudb1;

#1、创建学生表和课程表
CREATE TABLE student_info(
	id INT NOT NULL AUTO_INCREMENT,
    student_id INT NOT NULL,
    name VARCHAR(20) DEFAULT NULL,
    course_id INT NOT NULL,
    class_id INT DEFAULT NULL,
	create_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY(id)
)ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE course(
	id INT NOT NULL AUTO_INCREMENT,
    course_id INT NOT NULL,
	course_name VARCHAR(40) DEFAULT NULL,
    PRIMARY KEY(id)
)ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**第二步：创建模拟数据必须的存储函数**

```sql
#函数1：创建随机产生字符串函数
DELIMITER //
CREATE FUNCTION rand_string(n INT)
RETURNS VARCHAR(255) #该函数返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str = CONCAT(return_str, SUBSTRING(chars_str, FLOOR(1+RAND()*52),1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;
```

```sql
#函数2：创建随机数函数
DELIMITER //
CREATE FUNCTION rand_num(from_num INT, to_num INT) 
RETURNS INT
BEGIN 
	DECLARE i INT DEFAULT 0;
	SET i = FLOOR(from_num + RAND() * (to_num - form_num + 1));
	RETURN i;
END //
DELIMITER ;
```

如果创建函数时，假如报错：

This function has none of DETERMINISTIC......

由于开启慢查询日志bin-log，我们就必须为我们的function指定一个参数。

主从复制，主机回将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主机操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。

* 查看mysql是否允许创建函数：

  ```sql
  SHOW VARIBALES LIKE 'log_bin_trust_function_creators';
  ```

* 命令开启：允许创建函数设置：

  ```sql
  set global log_bin_trust_function_creators=1; #若不加global只是当前窗口有效
  ```

  上述的修改只对当前mysql服务有效，mysqld重启后，上述的修改又会失效。永久方法：

  在/etc/my.cnf文件中，加上：

  ```properties
  log_bin_trust_function_creators=1
  ```

  然后重启mysql服务：

  ```shell
  systemctl restart mysqld
  ```

  这个时候，发现此时依然可以创建存储函数



**第三步：创建插入模拟数据的存储过程，用于给表中插入数据**

```sql
# 存储过程1：创建插入课程表存储过程
DELIMITER //
 CREATE PROCEDURE  insert_course( max_num INT )
 BEGIN  
DECLARE i INT DEFAULT 0;   
SET autocommit = 0;    
#设置手动提交事务
REPEAT  #循环
SET i = i + 1;  #赋值
INSERT INTO course (course_id, course_name ) VALUES 
(rand_num(10000,10100),rand_string(6));  
UNTIL i = max_num  
END REPEAT;  
COMMIT;  #提交事务
END //
DELIMITER ;
```

```sql
# 存储过程2：创建插入学生信息表存储过程
DELIMITER //
 CREATE PROCEDURE  insert_stu( max_num INT )
 BEGIN  
DECLARE i INT DEFAULT 0;   
SET autocommit = 0;    
#设置手动提交事务
REPEAT  #循环
SET i = i + 1;  #赋值
INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES 
(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));  
UNTIL i = max_num  
END REPEAT;  
COMMIT;  #提交事务
END //
DELIMITER ;
```

第四步：调用存储过程

```sql
CALL insert_course(100);

CALL insert_stu(100000);
```

这个时候，course表中就包含了100条数据，student_info表中包含了100000条数据。



## 2、哪些情况适合创建索引

#### 字段的数值有唯一性的限制

这里字段数值有唯一性限制，并不是说该字段本身有唯一性约束，有唯一性约束的字段自动就有了唯一性索引，不需要我们去给它创建索引了。这里的唯一性限制，说的是字段的数值应该是唯一的，但是未给其设置唯一性约束。

索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，`如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引`。这样可以更快速地通过该索引来确定某条记录。

例如：

学生表中的学号具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。

> **`业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引（Alibaba规范）。`**
>
> 所以，我们在创建表的时候，就要去考虑表字段的唯一性，可以通过设置唯一性约束的方式创建唯一性索引。
>
> 
>
> 说明：不要以为唯一索引影响了INSERT速度，这个速度损耗可以忽略，但提高查找速度是明显的。





#### 频繁作为WHERE查询条件的字段

某个字段在SELECT语句的WHERE条件中经常被使用到，那么就需要给这个字段创建了索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。



**案例：**

student_info数据表（含100万条数据），假如我们想要查询student_id=123110的用户信息。

如果我们没有对student_id字段创建索引，进行如下查询：

```sql
SELECT course_id, class_id, name, create_time, student_id
FROM student_info
WHERE student_id = 123110;
```

运行结果：

![image-20240407221717383](.\images\image-20240407221717383.png)

所花费的时间是0.440秒。

那么，接下来我们去给student_id字段创建索引：

```sql
CREATE INDEX idx_sid
ON student_info(student_id);
```

创建完成之后，我们再去执行查询操作，此时的执行结果为：

![image-20240407222016046](.\images\image-20240407222016046.png)

此时花费的时间变为了0.172秒，此时花费的时间就少了很多，效率提升了很多。

原因在于，如果不使用索引搜索数据的话，底层实际上是去在"全盘扫描"，即沿着双向链表从第一个页一直扫描到最后一个页，对于数据量大的数据表来说，效率肯定是比较低的。





#### 经常GROUP BY和ORDER BY的列

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY进行分组查询，或者使用ORDER BY对数据进行排序的话，就`需要对分组或者排序的字段进行索引`。如果待排序的列有多个，那么可以在这些列上建立`组合索引`。

对于ORDER BY来说：索引本身就是按照创建列大小的顺序进行排列的，如果我们要对查询的结果进行ORDER BY排序的话，直接使用已经排序好的索引信息会更快。

对于GROUP BY来说：在索引中，按照列的大小顺序进行排序，所以相同的列肯定存放在一起的，此时我们要进行GROUP BY分组操作，就直接取相邻的数据即可，效率很高。



**案例1：**

按照student_id对学生选修的课程进行分组，显示不同的student_id和课程数量，显示100个即可。

如果我们不给student_id创建索引，执行下面的SQL语句：

```mysql
SELECT student_id, count(*) as num
FROM student_info
GROUP BY student_id
LIMIT 100;
```

执行结果为：

![image-20240407224209163](.\images\image-20240407224209163.png)

花费的时间是0.553秒

当我们给student_id创建索引后，执行结果为：

![image-20240407224328346](.\images\image-20240407224328346.png)

所花费的时间变为了0.191秒。

同样地，如果是ORDER BY排序，也需要对字段创建索引。

说明：对于包含GROUP BY或ORDER BY子句的查询，最好为这两个子句的列创建索引，这样效率会比较高。





**案例2：**

但是，若查询语句中既包含GROUP BY子句，也包含ORDER BY子句，那么怎样的索引效率最好呢？

比如：

```sql
SELECT student_id, COUNT(1) as num
FROM student_info
GROUP BY student_id
ORDER BY create_time DESC
limit 100;
```

我们来分别创建四种索引，分别是：

单独为student_id创建索引；

单独为create_time创建索引；

为student_id和create_time创建联合索引，student_id放在前面；

为student_id和create_time创建联合索引，create_time放在前面。

来分别测试一下，这四种索引对该查询的效率影响。

**首先，单独为student_id创建索引：**

```sql
ALTER TABLE student_info
ADD INDEX idx_sid(student_id);
```

此时执行查询的结果为：

![image-20240407232749164](.\images\image-20240407232749164.png)

所花费的时间是2.731s。

去查看一下



**然后，我们去为create_time创建索引：**

```sql
ALTER TABLE student_info
ADD INDEX idx_cre_time(create_time DESC);
```

此时，该表就存在两个索引，一个是student_id的索引，一个是create_time的索引。

然后，我们去查看一下，执行上述查询语句，使用的索引以及可能使用的索引：

```sql
EXPLAIN SELECT student_id, COUNT(1) as num
FROM student_info
GROUP BY student_id
ORDER BY create_time DESC
limit 100;
```

此时，只会且只可能执行一个索引：

![image-20240407233433937](.\images\image-20240407233433937.png)

原因就在于GROUP BY子句比ORDER BY子句先执行，在执行到GROUP BY子句优化器就会为其选择索引进行执行。

即，就算为其创建了ORDER BY列的索引，其依然会去执行GROUP BY列的索引。

**最后，为其创建两个联合索引**

```sql
ALTER TABLE student_info
ADD INDEX idx_sid_cre_time(student_id, create_time DESC);

ALTER TABLE student_info
ADD INDEX idx_cre_time_sid(create_time DESC, student_id);
```

此时，该表中存在了四个索引，我们去查看一下执行上述语句会使用什么索引以及可能使用什么索引：

```sql
EXPLAIN SELECT student_id, COUNT(1) as num
FROM student_info
GROUP BY student_id
ORDER BY create_time DESC
limit 100;
```

![image-20240407234017370](.\images\image-20240407234017370.png)

实际使用的索引是`idx_sid_cre_time`，可能使用两个联合索引和student_id单列索引。

为什么会这样？

还是因为GROUP BY子句的执行顺序比ORDER BY子句先，当执行到GROUP BY子句时，就会去考虑使用索引。此时有两个索引摆在面前，一个是GROUP BY单列索引，一个是包含ORDER BY子句的联合索引，优化器会选择后者。

让我们来看看实际执行上述查询语句所花费的时间：

![image-20240407234249178](.\images\image-20240407234249178.png)

发现速度快了一个量级。

所以，**对于执行语句中既有GROUP BY子句，也有ORDER BY子句时，推荐使用二者列的联合索引，其中，GROUP BY列放在联合查询的前面。**



按照SQL执行的顺序，因为GROUP BY语句比ORDER BY语句先执行，在执行到GROUP BY语句时就去考虑使用GROUP BY的列所创建的索引。假如说，执行语句既包含GROUP BY子句，也包含ORDER BY子句，那么优化器就会优先选择使用GROUP BY分组的列所创建的索引。当然，如果索引是联合索引，索引的列既包含GROUP BY列，也包含ORDER BY列，并且第一个列是GROUP BY列，那么优化器相较于只有一个列的索引，会优先选择联合索引，这种联合索引的效率是最快的。



> **总结：**
>
> * 查询语句中如果单独使用`GROUP BY`子句，那么针对于`GROUP BY`的列去创建索引。
>
> * 如果单独使用`ORDER BY`子句，那么针对于`ORDER BY`子句的列去创建索引。
>
> * 如果既使用GROUP BY子句，也使用ORDER BY子句，那么建议创建一个`联合索引`，联合索引要先将GROUP BY的列写在前面，ORDER BY的列写在后面（GROUP BY子句先执行，优先选择索引）。







#### UPDATE、DELETE的WHERE条件列

当我们对某条数据进行UPDATE或者DELETE操作的时候，是否也需要对WHERE的条件列创建索引呢？

我们先看一下对数据进行UPDATE的情况：我们想要把name为24oiashfaasdifhh对应的student_id修改为10002，当我们没有对name进行索引时，执行SQL语句：

```sql
UPDATE student_info SET student_id = 10002
WHERE name = '24oiashfaasdifhh';
```

运行时间为0.578s。

效率不是很高，但如果我们对name字段创建了索引，然后执行类似的SQL语句，运行时间仅为0.001s，效率有了很大的提升。

同理，对于DELETE语句也是一样的。

对数据按照某个条件进行查询后再进行UPDATE或DELETE的操作，如果对WHERE字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据WHERE条件列检索出来这条记录，然后再对它进行更新或删除。

**`如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。`**

**`所以，对于需要经常修改删除的字段，不建议为其创建索引，需要需要在索引中经常对其进行维护。`**





#### DISTINCT字段需要创建索引

有时候我们需要对某个字段进行去重，使用DISTINCT。

那如果不使用索引时，我们在底层就需要将这些重复的数据合在一起，这也需要花费时间。

如果使用了索引，这些重复的数据在底层实际上就是存储在一起的，我们进行去重时就不需要将相同的数据组合放在一起，省去了很多的时间。

比如：

我们想要查询课程表中不同的student_id有哪些，如果我们没有对student_id创建索引，执行SQL语句：

```sql
SELECT DISTINCT(student_id) FROM student_info;
```

运行所花费的时间为0.683s。

如果我们对student_id建立了索引，再执行相同的SQL语句。

运行所花费的时间为0.010s。

可以看到SQL查询效率有了提升，同时显示出来的student_id还是按照递增的顺序进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以去重的时候也会快很多。



#### 多表JOIN连接操作时，创建索引注意事项

首先，`连接表的数量尽量不要超过3张`，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

其次，**`对WHERE条件创建索引`**，因为WHERE才是对数据条件的过滤。如果在数量非常大的情况下，没有WHERE条件过滤是非常可怕的。

最后，`对用于连接的字段创建索引`，并且该字段在多张表中的`类型必须一致`。比如course_id在student_info表和course表中都为INT类型，而不能一个为int一个为varchar。**因为ON子句实际上相当于WHERE子句，用途也是筛选作用。**筛选出符合ON连接条件的记录。（对连接的字段进行索引时请测试，有时候给连接字段创建索引后，反而效率降低）

举个例子：

如果我们只对student_id创建索引，执行SQL语句：

```sql
SELECT course_id, name, student_info.student_id, course_name
FROM student_info JOIN course
ON student_info.course_id = course.course_id
WHERE name= 'oadihoiehaw';
```

原本的运行时间为0.189s

如果我们对name创建索引，再执行，运行时间为0.002s。



#### 使用列的类型小的创建索引

我们这里所说的`类型大小`指的是该类型表示的数据范围的大小。

我们在定义表结构的时候要显式的指定列的类型，以正数类型为例，有`TINYINT`、`MEDIUMINT`、`INT`、`BIGINT`等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用MEDIUMINT就不要使用INT。这是因为：

* 数据类型越小，在查询时进行的比较操作越快
* 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以`放下更多的记录`，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的`主键来说更加使用`，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果使用更小的数据类型，也就意味着节省的存储空间和更高效的I/O。



#### 使用字符串前缀创建索引

假设我们的字符串很长，那存储一个字符串需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：

* B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，`在索引中占用的存储空间越大`。
* 如果B+树索引中索引列存储的字符串很长，`在比较字符串时会占用更多的实际`。

我们可以通过截取字符串前面一部分内容建立索引，这就叫做**`前缀索引`**。这样在查找记录时虽然不能精准的定位到记录的位置，但是能够定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。

由于非聚簇索引中，目录项记录的唯一性（若索引列的值一样，还会继续比较主键的值），所以，使用字符串前缀创建索引，不会因字符串前缀值一致而导致搜索错误的情况，因为还会继续比较主键的值。

所以，**使用字符串前缀创建索引，既能够`节约空间`，又`减少了字符串的比较时间`。**

但是截取多少字符串长度是合适的呢？

截取要是太长，字符串的比较时间过长，不利于效率；截取要是过短，字符串的重复率太高，索引的作用较小。

比如，创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引

```sql
CREATE table shop(address varchar(120) not null);

ALTER TABLE show add index(address(12));
```

问题是，截取多少呢？截取的多了，达不到节省索引存储空间的目的；截取的少了，重复内容太多，字段的散列度（选择性会降低）。**怎么计算不同的长度的选择性呢？**

**公式：**

```sql
count(distinct left(列名, 索引长度)) / count(*)
```

例如：

```sql
#截取前10个字符的选择度
select count(distinct left(address, 10)) / count(*)
from shop;

#截取前20个字符的选择度
select count(distinct left(address, 20)) / count(*)
from shop;
```

**`引申另一个问题：索引列前缀对排序的影响`**

如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边这个查询可能有点问题：

```sql
SELECT * FROM shop
ORDER BY address
LIMIT 12;
```

因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式`无法支持使用索引排序`，只能使用文件排序。



**`扩展：Alibaba《Java开发手册》`**

【`强制`】**在varchar字段上建立索引时，必须指定索引长度**，没有必要在全字段建立索引，根据实际文本区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度)) / count(*)的区分度来确定。

> 一般认为，**区分度**超过**`33%`**就算是比较高效的索引了。

#### 区分度高（散列性高）的列适合作为索引

`列的基数`指的是某一列中不重复数据的个数，比方说某个列包含值2,5,8,2,5,8,2,5,8，虽然有9条记录，但该列的基数却是3。也就是说，**`在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。`**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的建立索引效率可能不好。

可以使用公式`select count(distinct a)/count(*) from t1`计算区分度，越接近1越好，一般超过33%就算是比较搞笑的索引了。

拓展：联合索引把区分度高（散列性高）的列放在前面。



#### 使用最频繁的列放到联合索引的左侧

这就是**`最左前缀原则`**。

比如：

```sql
SELECT *
FROM student_info
WHERE student_id = 100012 AND course_id = 100;
```

若student_id更加频繁地用于筛选条件，这个时候，我们就可以去创建一个联合索引，将student_id放在联合索引的左边，course_id放在联合索引的右边。当我们使用student_id去查询的筛选条件时，就会考虑使用这个联合索引。**就可以增加联合索引的使用率，建立较少的索引。**



#### 在多个字段都要创建索引的情况下，联合索引优于单值索引

若多个字段都要去创建索引，这个时候，我们在实际查询使用时，一个查询只会使用到一个索引，创建过多的索引反而使用不到，索引较多时也会影响数据增删改的效率。

若将这些字段联合创建索引，这个时候，联合索引占用更少的空间，使用率也比较高，同时，对于表数据增删改操作的影响就会变低。



> **总结：**
>
> **`若多个字段需要创建索引，联合索引更加适合，将最常用的索引列放在索引的最左边。`**





## 3、限制索引的数目

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量**`不超过6个`**。原因：

1. 每个索引都需要占用`磁盘空间`，索引越多，需要的磁盘空间就越大。
2. 索引会影响`INSERT、DELETE、UPDATE等语句的性能`，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
3. 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的`索引来进行评估`，以生成一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。





## 4、哪些情况不适合创建索引

#### 在where中使用不到的字段，不要设置索引

WHERE条件（包括GROUP BY、ORDER BY）里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。                                                                                                                     

#### 数据量小的表最好不要使用索引

如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，`是否创建索引对查询效率的影响并不大`。甚至说，查询花费的时间可能比比那里索引的时间还要短，索引可能不会产生优化效果。

**在数据行中数据比较少的情况下，比如`不到1000`行，是不需要创建索引的。**

#### 有大量重复数据的列上不要建立索引

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“性别”字段上只有"男"和"女"两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会**`严重降低数据更新速度`**。

给性别去创建索引，实际上是使用记录中的第二个字段主键去比较的，然后查询到数据后还要去聚簇索引中回表，此时效率反而还降低了。

不如直接使用主键去一个一个地去遍历页的方式去查询，这样反而还快一点，因为我使用主键去索引中查询也是一个一个地去比较。



#### 避免对经常更新的表创建过多的索引

第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。

第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却也会降低更新表的速度。

#### 不建议用无序的值作为索引

例如身份证、UUID、MD5、HASH、无序长字符串等。

#### 删除不再使用或很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

#### 不要定义冗余或重复的索引

**`1、冗余索引`**

举例：

```sql
CREATE TABLE person_info(
 id INT UNSIGNED NOT NULL AUTO_INCREMENT,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
 KEY idx_name (name(10))
);   
```

比如在上表中，通过idx_name_birthday_phone_number索引就可以对name列进行快速搜索，再创建一个专门针对name列的索引就是一个冗余索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。



**`2、重复索引`**

另一种情况，我们可能会对某个列重复建立索引，例如：

```sql
CREATE TABLE repeat_index_demo(
	col1 INT PRIMARY KEY,
	col2 INT,
	UNIQUE uk_idx_c1(col1),
	INDEX idx_c1(col1)
);
```

我们可以看到，col1既是主键，有给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。







# 联合索引是否能够使用以及能够使用几个字段的判断

**我们来说一个结论，联合索引是否能够使用以及能够使用几个字段的判断条件是：`是否有序`。**

是否有序指的是索引中，取出来的字段之间是否是有序排列的，如果有序，那么就可以使用联合索引，如果无序，就不能够使用联合索引。

假设test表中有一个联合索引(a, b, c)。

我们先来说一个**例一：**

```sql
select * from test where a = 1 and b = 2 and c = 3;
```

这个查询当然可以使用索引，并且可以使用索引中全部的三个字段。

为什么？

答案是**有序**。

三个列的联合索引是按照创建索引时列的顺序分级排列的（最左原则），索引中的一级排序是按照a的大小进行排序，然后再按照b的顺序进行二级排序，最后按照c的顺序进行三级排序。

在索引中取出数据的顺序是：

先将字段a是1的索引数据取出，由于索引的一级排序是按照a的大小排的，所以a是有序的，a为1的数据都是存放在一起的；

取出a的数据后，我们再在其中筛选b的大小，字段b在a=1的索引中也是有序的，所以我们可以将b=2的数据取出；

筛选出b=2的数据后，在b=2的索引下，c的字段也是有序的，所以此时我们也能够将c=3的数据很好地取出。

该查询能够使用到3个字段进行索引，就是因为这三个字段的数据在整体比较的数据中是有序的。



然后，我们再来看看**第二个例子：**

```sql
select * from test where a = 1 and b > 2 and c = 3;
```

我们先说结论：

这个查询中，使用了联合查询，但是只用到了联合查询中的两个字段a和b，c无法使用到联合查询。

为什么？

还是因为有序性。

在联合索引(a, b, c)中，对于这个查询的步骤是这样的：

首先我们去筛选字段a=1的索引，这肯定是有序的，我们直接使用；

然后将筛选完毕的数据开始筛选b>2的数据，由于在a=1字段下，b的字段也是有序的，所以，我们也能够将b>2的数据筛选出来（b>2的数据都存放在一起）；

最后，我们想要在字段b>2的索引下，筛选出c=3的数据。此时，b>2的索引中，c的大小并不是有序的，比如：

b  3  3  5  7  9  

c  0  3  9  5  1

此时，取出的c值是0 3 9 5 1，c的值是无序的。

由于索引是否可以使用的判断条件是：是否有序

有序就可以使用，无序就不能使用

所以此时的c字段是不能使用索引的。

所以上述查询只能使用到联合索引的两个字段。



**再来看一个例子：**

```sql
select * from test where a = 1 and b >= 2 and c = 3;
```

这个例子和第二个例子中，唯一的区别在于b的筛选条件从 > 2变成了>= 2。

但是，我们来说一个结论，这个查询，联合索引中的三个字段都使用到了。

为什么？明明筛选条件只是从>2变成了>=2，只多了一个=2的范围，为什么就可以使用联合索引的三个字段了？

由于联合索引（二级索引）是先按照a字段的值排序的，满足a=1后筛选出来的b字段，也是有序的，所以符合b>=2条件的二级索引记录肯定是相邻的，于是在进行索引扫描的时候，可以定位到符合b>=2条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合b>=2条件位置，所以b字段可以在联合索引的B+Tree中进行索引查询。

即，此时b字段是有序的，可以使用索引查询（这在之前已经说过了）

然后，在满足b>=2筛选条件下的索引记录的范围里，c字段是无序的。这是肯定的，但是为什么这里的查询使用到了c字段呢？

原因在于：**在对于符合b=2的二级索引记录范围里，c字段是有序的**。（因为对于联合索引，先是按照a字段的值排序，然后在a字段值相同的情况下，再按照b字段进行排序；在b字段相同的情况下，再按照c字段进行排序）

于是，在确定需要扫描的二级索引的范围内，当二级索引记录的a字段是1，b字段是2时，可以通过c=3条件来减少需要扫描的二级索引记录范围。

即虽然c字段是无序的，但是在b=2的情况下，c字段是有序的，我们可以使用索引在a=1、b=2的情况下对c=3进行扫描，能够减少b为2情况下，索引记录的扫描次数。

也就是说，这个时候可以从符合a=1、b=2和c=3的第一条记录开始扫描，在a=1、b=2的情况下c是有序的，那么在这个情况下，可以使用到c字段索引，所以在这个查询中，需要使用三个列的索引进行索引查询。

**总结：**

**联合索引能不能够使用到这个字段，一切的根据就在于这个字段在整体或者某一部分的情况下，是不是有序的，如果有序，就可以使用；如果全部都无序，那就不可使用。**



引申一下：

其实不仅仅是针对于联合索引，对于单列索引也是一样的，是否能够使用某索引，就看在索引中该列数据是有序的（或部分是有序的）。
