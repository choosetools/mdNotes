## 1、MySQL体系结构

首先来看一张MySQL体系图，了解一下存储引擎所在的位置。

![image-20240402144145236](.\images\image-20240402144145236.png)



## 2、存储引擎介绍

关系型数据库，就是用来存储各种数据信息的。根据不同业务场景，比如说：有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表需要查询非常快。那`存储引擎就是指表的类型`。在我们实际的开发业务中，可能需要使用到各种各样的表，不同的表也意味着存储不同类型的数据，数据的处理上也就会存在差异。针对MySQL来说，它提供了很多类型的存储引擎来供我们选择，我们可以根据业务需求来选择不同的存储引擎，最大程度的发挥MySQL的强大之处。

## 3、MySQL存储引擎特性

1. 采用的**`插拔式`**的插件方式；
2. 存储引擎是指定在表之上的，即`一个库中的每一个表都可以指定选择存储引擎`；
3. 无论表采用什么样的结构，都会在数据区，产生一个`.frm`文件（MySQL8.0之后产生的是`.sid`文件），这是表结构定义描述文件，用于描述表的结构。

## 4、查看存储引擎

查看mysql提供什么存储引擎：

```sql
show engines;
```

![image-20240402144659874](.\images\image-20240402144659874.png)

上述结果是在MySQL8.0中的查询结果。

结果显示，MySQL 8支持9种存储引擎，分别是：**`MEMORY`**、**`MRG_MYISAM`**、**`CSV`**、**`FEDERATED`**、**`PERFORMANCE_SCHEMA`**、**`MyISAM`**、**`InnoDB`**、**`BLACKHOLE`**和**`ARCHIVE`**。

* `Engine`参数表示存储引擎名称
* `Support`参数表示MySQL数据库是否支持该存储引擎，YES表示支持，NO表示不支持，DEFAULT表示系统默认的存储引擎。
* `Transactions`参数表示该存储引擎是否支持事务
* `XA`参数表示存储引擎是否支持分布式事务
* `Savepoints`参数表示存储引擎是否支持事务回滚。



## 5、设置系统默认的存储引擎

**查看系统默认的存储引擎**

```sql
show variables like '%storage_engine%';
#或
SELECT @@default_storage_engine;
```

<img src=".\images\image-20240402150545941.png" align="left">

可以看到，系统默认的存储引擎为**`InnoDB`**。

**修改默认存储引擎**

如果在创建表的语句中没有显式指定表的存储引擎的话，那么就默认会使用`InnoDB`作为表的存储引擎。如果我们想修改表的默认存储引擎的话，可以使用下面的命令：

```sql
SET DEFAULT_STORGE_ENGINE=MyISAM;
```

或者修改my.cnf文件：

```shell
vim /etc/my.cnf
default-storge-engine=MyISAM

#重启服务
systemctl restart mysqld
```

修改默认存储引擎后，如果没有显式地去声明存储引擎，那么创建出来的数据库或者表都会使用修改后的默认存储引擎。



## 6、设置表的存储引擎

存储引擎是负责对表中规定数据进行提取和写入工作的，我们可以为`不同的表设置不同的存储引擎`，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。

**创建表时制定存储引擎**

我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎Innodb。如果想显示地指定表的存储引擎，可以这样写：

```sql
CREATE TABLE 表名(
	建表语句;
)ENGINE = 存储引擎名称
```

**修改表的存储引擎**

如果表已经创建好了，可以使用下面的命令去修改表的存储引擎：

```sql
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```





## 7、各种存储引擎

### CSV

> CSV存储引擎，即数据是以**`CSV文件`**存储的。
>
> **特点：**
>
> 1. 不能定义索引，列定义必须为NOT NULL，不能设置自增列。（缺点：`不适用于大表或者数据查询、排序等处理操作`）
> 2. CSV数据的存储需要使用,逗号隔开，可直接编辑CSV文件进行数据的编排（缺点：`数据安全性低`）
> 3. 可以对硬盘中保存的表文件数据进行直接编辑xxx.CSV文件，但是**不能将该文件删除然后上传同名的.CSV文件**，编辑之后，通过命令：`flush table xxx`表名的方式使其生效。
>
> **应用场景：**
>
> 1. 数据的快速导入导出；
> 2. 表格直接转换成CSV。

使用案例：

创建一个使用CSV引擎的表：

```sql
CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL) ENGINE = CSV;
```

往其中添加数据：

```sql
INSERT INTO test VALUES(1,'record one'),(2,'record two');
```

<img src=".\images\image-20240402154541799.png" align="left">

这个时候，我们去查看一下该表对应的文件信息：

![image-20240402154625359](.\images\image-20240402154625359.png)

我们可以看到有三个文件，分别是**`.CSV文件`**、**`.CSM文件`**和**`.sdi文件`**。

其中：

* `.CSV`文件保存的是数据表的数据信息

* `.CSM`文件存储表的状态和表中存在的行数

* `.sdi`文件存储的是表的结构。

我们去打开.CSV文件：

```shell
vim test.CSV
```

<img src=".\images\image-20240402154911005.png" align="left">

可以看到，CSV是将不同的列之间，使用**`逗号,`**进行分隔存放到文件中。

这种格式可以被表格等程序读取，甚至写入，方便我们使用表格来对.CSV文件进行转换：

![image-20240402155241190](.\images\image-20240402155241190.png)



### Archive

> Archive存储引擎，是以**`压缩协议`**进行数据的存储
>
> **特点：**
>
> 1. 只支持`insert`和`select`两种操作；（缺点：不适用于对数据的处理操作）
> 2. 只允许自增ID列建立索引
> 3. 拥有良好的压缩机制，使用`zlib压缩库`，在记录请求的时候实时进行压缩，经常被用来作为仓库使用。
> 4. 创建Archive表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为`.ARZ`。
> 5. 支持`行级锁`
> 6. 不支持事务
> 7. **`优点`**：**数据占用磁盘少**
>
> **应用场景：**
>
> `日志系统和数据采集类`应用；**`适合存储大量的独立的作为历史记录的数据`**。拥有很高的插入速度，但是查询的支持较差。

使用案例：

使用Archive引擎创建表：

```sql
CREATE TABLE `users_archive` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `address` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=Archive
```

创建表后查看表的数据文件：

![image-20240402173717548](.\images\image-20240402173717548.png)

* **`.ARZ`文件存放表的数据信息**

* **`.sdi`文件存放表的结构信息。**

然后，我们使用函数批量插入1万条数据：

```sql
//批量添加函数:
CREATE DEFINER=`root`@`%` PROCEDURE `users_archive_batchAdd`()
begin
    declare i int;
    set i=1;
    while i<10000 do
				INSERT INTO users_archive(id,name,age,address) VALUES(i,concat('James',i),i,concat('BeiJing',i));
        set i=i+1;
     end while;
end

call users_archive_batchAdd();
```

此时，去查看对比数据内容占用情况：

![image-20240402174047826](.\images\image-20240402174047826.png)

即：Archive存储引擎占用的磁盘空间小，由于只支持insert和select两种操作，所以建议对于需要占用大量空间，并且不去修改和删除的数据，可以使用Archive存储引擎。



### Memory

Memory采用的逻辑介质是**`内存`**，`响应速度很快`，但是当mysqld守护进程崩溃的时候数据会丢失。另外，要求存储的数据是`数据长度不变`的格式，比如Blob和Text类型的数据不可用。

**特点：**

1. Memory同时支持**`哈希（HASH）索引`**和**`B+树索引`**。

2. Memory表至少比MyISAM表快一个数量级。

3. MEMORY`表的大小是受到限制`的。表的大小主要取决于两个参数，分别是 `max_rows`和 `max_heap_table_size`。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大。 

4. 数据文件与索引文件分开存储。 

5. 缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。 


**使用Memory存储引擎的场景：** 

1.  `目标数据比较小`，而且`非常频繁的进行访问`，在内存中存放数据，如果太大的数据会造成 内存溢出。可以通过参数max_heap_table_size控制Memory表的大小，限制Memory表的最大的大小。 
1.  如果`数据是临时`的，而且`必须立即可用得到`，那么就可以放在内存中。 
1.  存储在Memory表中的数据如果突然间`丢失的话也没有太大的关系`。



### InnoDB（重要）

在MySQL5.5及以后的版本，MySQL选择使用Innodb为默认存储引擎。在创建数据库表时，不制定存储引擎，默认使用的就是InnoDB。如果需要使用其他存储引擎，需要手动指定。

**特点**：

* InnoDB支持**`事务操作`**，每一条SQL语句都会被认作是一个事物，自动提交。
* InnoDB支持**`外键`**。
* InnoDB支持表级锁、行级锁。**`默认为行级锁`**。行级锁，即操作表中的哪一行就锁哪一行数据，不会影响其他用户操作表中的其他数据，多并发环境中效率更高。
* 相较于MyISAM存储引擎来说，`InnoDB写的处理效率较差一些`，并且会占用更多的磁盘空间以保存数据和索引。
* 除了insert和select外，还需要update和delete操作，那么，应优先考虑Innodb存储引擎。
* InnoDB表`必须有主键`（如果没有明确去指定创建主键索引，它会帮我们隐藏的生成一个6byte的int型索引作为主键索引）。
* InnoDB文件存储方式为：
  * `.frm`文件存储表结构
  * `.ibd`文件存储数据内容
* MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，`对内存要求较高`，而且内存大小对性能有决定性的影响。



> **除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。**



### MyISAM（重要）

MyISAM是MySQL5.5之前版本的默认存储引擎。

**特点：**

* MyISAM**`不支持事务、行级锁、外键`**。

* MyISAM有一个变量专门来保存整个表的行数，查询count很快。
* MyISAM支持**`表级锁`**，不支持行级锁。所以，当对使用MyISAM引擎的表执行更新操作的时候，会将整个表都锁起来，这样会导致并发操作效率很慢。
* MyISAM是**`非聚集索引`**。
* MyISAM可以被压缩后进行查询操作，节省空间容量。
* MyISAM中主键不是必须的。
* MyISAM支持全文索引。



每个MyISAM在磁盘上存储成3个文件，其文件名和表名相同，扩展名如下：

* `.frm`（存储表定义）；

* `.MYD`（存储数据）；

* `.MYI`（存储索引）

![image-20240402170642612](.\images\image-20240402170642612.png)

> **应用场景**：`对事务完整性没有要求或者以SELECT、INSERT为主的应用可以使用这个引擎来创建表。`







## InnoDB VS MyISAM

**区别：**

1. **`InnoDB支持事务；MyISAM不支持。`**对于InnoDB每一条SQL语句都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语句放在begin和commit之间，共同组成一个事务。

2. **`InnoDB支持外键；MyISAM不支持。`**对于一个包含外键的InnoDB表转换成使用MyISAM引擎会失败，现在建议不要使用外键。

3. **`InnoDB是聚集索引；MyISAM是非聚集索引。`**InnoDB使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的；MyISAM也是使用B+Tree作为索引结构，但是索引和数据文件是分离的，索引保存的是数据文件的指针。

   ![image-20240402172713308](.\images\image-20240402172713308.png)

   ![image-20240402172726911](.\images\image-20240402172726911.png)

4. **`InnoDB必须有主键；MyISAM可以没有主键`**。InnoDB如果我们没有明确去指定创建主键索引，它会帮我们隐藏地生成一个6byte的int类型的索引作为主键索引。

5. **`InnoDB辅助索引和主键索引之间存在层级关系；MyISAM辅助索引和主键索引则是平级关系。`**即：InnoDB 如果添加其他辅助索引，辅助索引查询就需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也相应都会很大。（比如表中有id(主键),name,age 字段，我们创建一个主键索引，再来创建一个name索引，层级关系如下图所示）

   ![在这里插入图片描述](.\images\112222)

   ![img](.\images\42341234)

6. **`InnoDB不保存表的具体行数；MyISAM用一个变量保存了整个表的行数。`**所以使用MyISAM执行count()查询表中行数速度很快。

7. **`InnoDB不支持全文索引；MyISAM支持全文索引。`**在MySQL5.7之后，InnoDB也支持全文索引了。

8. **`InnoDB支持表级锁、行级锁，默认为行级锁；MyISAM仅支持表级锁。`**InnoDB的行锁是实现在索引上的，而不是锁在物理行上。如果访问未命中索引，也是无法使用行锁，会退化为表锁。

9. **`InnoDB存储文件是.frm、.ibd；MyISAM是.frm、.MYD和.MYI。`**InnoDB 中：

   ​	`.frm文件`：保存的是表结构定义描述文件；

   ​	`.ibd文件`：保存的是employee表中的数据内容；

   MyISAM中：

   ​	`.frm文件`：保存的是表结构定义描述文件，

   ​	`.MYD文件`：保存的是数据内容，

   ​	`.MYI文件`：保存的是索引内容

   在MySQL8.0之后，Innodb不再提供.frm文件，而是全都放入到.ibd文件；MyISAM也将.frm文件替换成了.sdi文件。



**如何进行选择？**

1. 需要用到事务选择InnoDB，不需要事务可以考虑MyISAM。
2. 表中大多数只是查询操作，可以考虑MyISAM；如果既有读也有写，需要使用InnoDB。
3. 如果不知道使用什么，建议使用InnoDB。