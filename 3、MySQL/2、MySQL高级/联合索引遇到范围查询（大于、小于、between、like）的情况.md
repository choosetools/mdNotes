我们来说一个**结论**：

> **`联合索引的最左匹配原则，在遇到范围查询（如>、<）的时候，就会停止匹配，就是范围查询的字段可以用到联合查询，但是在范围查询字段后面的字段无法使用到联合查询。但是，对于>=、<=、BETWEEN、LIKE前缀匹配这四种范围查询，并不会停止匹配。`**



联合索引有一些特殊情况，**并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询**，也就是可能存在部分字段用到联合索引的B+Tree，部分字段没有用到联合索引的B+Tree的情况。

这种特殊情况就发生在范围查询。也就是文章开头那句话：联合索引的最左匹配原则会一直向右匹配知道遇到`范围查询`时就会停止匹配。也就是**范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法用到联合索引。**

范围查询有很多中，那么到底是哪些范围查询会导致联合索引的最左匹配原则停止匹配呢？

接下来，举例几个范围查询的例子，下面的实验案例是基于MySQL8.0做的。

### **例子一：**

> **Q1：select * from t_table WHERE a > 1 and b = 2;**
>
> **联合索引(a, b)哪一个字段使用了联合索引？**

由于联合索引（二级索引）是先按照a字段的值排序的，所以符合a>1条件的二级索引肯定是相邻的，于是在进行索引扫描的时候，可以定位到符合a>1条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合a>1条件的位置。所以a字段可以在联合索引的B+Tree中进行索引查询。

**但是在符合a>1条件的二级索引记录的范围里，b字段是无序的。**

比如，下图的联合索引的B+Tree里：

![img](.\images\321789123798.png)

我们虽然通过a>1的条件筛选出了一部分数据，但是在这部分数据中的第二个字段，是无序的。

比如a，b字段的数据如下所示：

a  2  2  3  4  6

b  4  6  1  6  0

此时，b字段的数据就是4 6 1 6 0，即此时b字段的数据是无序的。

因此，我们不能根据查询条件b=2来进一步减少需要扫描的记录数，还是需要去扫描所有的b字段（b字段无法利用联合索引进行索引查询的意思）

因此，**Q1这条查询语句只有a字段用到了联合索引进行索引查询，而b字段并没有用到联合索引**。

我们也可以在执行计划中的key_len知道这一点，在使用联合索引进行查询的似乎，**通过key_len我们可以知道优化器具体使用了多少个字段的查询条件来形成扫描区间的边界条件。**

举个例子，a和b都是int类型且不为NULL的字段，那么Q1这条查询语句执行计划如下：

![img](.\images\7438921798.png)

可以看到key_len为4个字节（如果字段允许为NULL，就在字段类型占用的字节数上加1，也就是5字节），说明只有a字段用到了联合索引进行索引查询，而且可以看到，即便b字段没有用到联合索引，key为idx_a_b，说明Q1查询语句使用了idx_a_b联合索引。

通过Q1查询语句我们可以知道，**a字段使用了>进行范围查询，联合索引的最左匹配原则在遇到a字段的范围查询（>）就停止匹配了，因此b字段并没有使用到联合索引。**



### 例子二

> **Q2：select * from t_table where a >= 1 and b = 2**
>
> **联合索引(a, b)哪一个字段用到了联合索引的B+Tree？**

Q2和Q1的查询语句很像，唯一的区别是a字段的查询条件"大于等于"。

由于联合索引（二级索引）是先按照a字段的值排序的，所以符合>=1条件的二级索引记录肯定是相邻的，于是在进行索引扫描的时候，可以定位到符合>=1条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合a>=1条件位置。所以a字段可以在联合索引的B+Tree中进行索引查询。

虽然在符合a>=1条件的二级索引记录的范围里，b字段的值是无序的，**但是对于符合a=1的二级索引记录的范围里，b字段的值是有序的**。（因为对于联合索引，是先按照a字段的值排序，然后在a字段的值相同的情况下，再按照b字段的值进行排序）。

于是，在确定需要扫描的二级索引的范围时，当二级索引记录的a字段值为1时，可以通过b=2条件减少需要扫描的二级索引记录范围（b字段可以利用联合索引进行查询的意思）。也就是说，从符合a=1 and b=2条件的第一条记录开始扫描，而不需要从第一个字段值为1的记录开始扫描。即：在a=1的条件下，b字段的顺序是有序的，所以此时可以使用到联合索引。

所以，Q2这条查询语句a和b字段都用到了联合索引进行索引查询。

我们也可以在执行计划中的key_len知道这一点。执行计划如下：

![img](.\images\53d95c937c63730f24739d7f03513131.png)

可以看到key_len为8字节，说明优化器使用了2个字段的查询条件来形成扫描区间的边界条件，也就是a和b字段都用到了联合查询进行索引查询。

通过Q2查询语句我们可以知道，虽然a字段使用了>=进行范围查询，但是联合索引的最左匹配原则并没有在遇到a字段的范围查询（>=）后就停止匹配了，b字段还是可以用到了联合索引的。

原因就在于：**在进行a>=1筛选之后，虽然b字段的排序是无序的，但是在a=1的情况下，b字段的排序是有序的，所以b字段可以使用到索引进行扫描。**



### 例子三：

> **Q3：select * from t_table WHERE a between 2 and 8 and b = 2;**
>
> **联合索引（a, b）哪一个字段用到了联合索引B+Tree？**

Q3查询条件中a between 2 and 8的意思是查询a字段的值在2和8之间的记录。

不同的数据库对between...and处理方式是有差异的。**在MySQL中，BETWEEN包含了value1和value2的边界值，类似于>=和<=。**

由于MySQL的BETWEEN包含value1和value2边界值，所以类似于Q2查询语句，因此**Q3这条查询语句a和b字段都用到了联合索引进行索引查询。**

我们也可以在执行计划中的key_len知道这一点。执行计划如下：

![img](.\images\123132423144123.png)

可以看到key_len为8字节，说明优化器使用了2个字段的查询条件来形成扫描区间的边界条件，也就是a和b字段都用到了联合索引进行索引查询。

通过Q3查询语句我们可以知道，**虽然a字段使用了BETWEEN进行范围查询，但是联合索引的最左匹配原则并没有在遇到a字段的范围查询（BETWEEN）后就停止匹配了，b字段还是可以用到了联合索引的。**





### 例子四

> **Q4：SELECT * FROM t_user WHERE name LIKE 'j%' and age = 22,**
>
> **联合索引（name, age）哪一个字段用到了联合索引的B+Tree？**

对于上述的查询语句，其实相当于：

select * from t_user where name >= 'j' and name < 'k' and age = 22。

虽然有两个范围查询，但是在name = 'j'的情况下，age是有序的，所以这里可以用到两个字段。

由于联合索引（二级索引）是先按照name字段的值排序的，所以前缀为'j'的name字段的二级索引记录都是相邻的，于是在进行索引扫描的时候，可以定位到符合前缀为'j'的name字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的name前缀不为'j'为止。

所以a字段可以在联合索引的B+Tree中进行索引扫描，形成的扫描区间是['j', 'k')。注意，j是闭区间。如下图：

![img](.\images\ac43370995b219660ab9495f633ff8b2.png)

虽然在符合前缀为'j'的name字段的二级索引记录的范围里，age字段的值无序的，**但是对于符合name=j的二级索引记录的范围里，age字段的值是有序的**（因为对于联合索引，是先按照name字段的值排序，然后在name字段的值相同的情况下，再按照age字段的值进行排序）。

于是，在确定需要扫描的二级索引的范围时，当二级索引记录的name字段值为'j'时，可以通过age=22条件减少需要扫描的二级索引记录范围（age字段可以利用联合索引进行索引查询的意思）。也就是说，从符合name='j' and age=22条件的第一条记录开始扫描，而不需要从第一个name为j的记录开始扫描。如下图的右边：

![img](.\images\2fc877a929af660b6404e693bf94c02c.png)

所以，**Q4这条查询语句a和b字段都用到了联合索引进行索引查询。**

我们也可以在执行计划中的key_len直到这一点。本例子中：

name字段的类型是varchar(30)且不为NULL，数据库表使用了utfmb4字符集，一个字符集为utf8mb4的字符是4个字节，因此name字段的实际数据最多占用的存储空间长度是120字节（30 x 4），然后因为name是变长类型的字段，需要再加2，也就是name的key_len为122。

age字段的类型是int且不为NULL，key_len为4。

Q4查询语句的执行计划如下：

![img](.\images\ca57a5921c00cf2cf75c5191d49fc730.png)

可以看到key_len为126字节，name的key_len为122，age的key_len为4，说明优化器使用了2个字段的查询条件来形成扫描区间的边界条件，也就是name和age字段都用到了联合索引进行索引查询。

通过Q4查询语句我们可以知道，虽然name字段使用了like前缀匹配进行范围查询，但是联合索引的最左匹配原则并没有遇到name字段的范围查询（like 'j%'）后就停止匹配了，age字段还是可以用到了联合索引的。



### 例子五

> **Q5：SELECT * FROM t_user WHERE name LIKE '%j' AND age = 22;**
>
> 联合索引(name, age)

这里会不会使用索引呢？使用索引的几个字段呢？我们来看看执行计划信息：

![image-20240412133950636](.\images\image-20240412133950636.png)

我们可以看到，这里不会使用到任何的索引。

为什么出现这种情况？

原因就在于name like '%j'这个筛选条件

我们知道，索引是按照大小顺序进行排序的，但是这个排序的顺序，无法让我们得到以j结尾的name的位置信息，此时，我们假如要使用索引去筛选出name like '%j'的数据，实际上就是去全表扫描，需要一个一个地去扫描索引中的数据，那么此时索引的作用就失效了。

所以，此时，就不会去使用索引来进行比对。

即，此时，就算索引是有序的，但是不起任何作用，依旧是去全表扫描，所以，此时不会使用任何索引。