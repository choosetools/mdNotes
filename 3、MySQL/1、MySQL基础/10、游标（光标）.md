# 1、什么是游标（或光标）

游标就类似于Java中的**iterator**指针。

虽然我们也可以通过筛选条件WHERE和HAVING，或者是限定返回记录的关键字LIMIT返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是`随意定位到某一条记录`，并对记录的数据进行处理。

这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。**`游标让SQL这种面向集合的语言有了面向对象开发的能力。`**

在SQL中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标`充当了指针的作用`，我们可以通过操作游标来对数据行进行操作。

> **MySQL中游标可以在`存储过程`和`存储函数`中使用。**

比如：我们查询了employees数据表中工资高于15000的员工有哪些：

```sql
SELECT employee_id, last_name, salary FROM employees
WHERE salary > 15000;
```

![image-20240317165933412](.\images\image-20240317165933412.png)

这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是"108"的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。



# 2、使用游标步骤

> **游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。**

如果我们想要使用游标，一般需要经历四个步骤。不同的DBMS中，使用游标的语法可能略有不同。

#### 第一步，声明游标

在MySQL中，使用`DECLARE`关键字来声明游标，并使用**`CURSOR`**来表示游标，其语法的基本形式如下：

```sql
DECLARE cursor_name CURSOR FOR select_statement;
```

这个语法适用于MySQL、SQL Server、DB2和MariaDB。如果是用Oracle或者PgSQL，需要写成：

```sql
DECLARE cursor_name CURSOR IS select_statement;
```

要使用SELECT语句来获取数据结果集，而此时还没有开始遍历数据，这里select_statement代表的是SELECT语句，返回一个用于创建游标的结果集。

比如：

```sql
DECLARE cur_emp CURSOR FOR
SELECT employee_id,salary FROM employees;
```





#### 第二步，打开游标

打开游标的语法如下：

```sql
OPEN cursor_name;
```

当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候SELECT语句的查询结果集就会送到游标工作区，为后面游标的`逐条读取`结果集中的数据做准备。



#### 第三步，使用游标（从游标中取得数据）

语法如下：

```sql
FETCH cursor_name INTO var_name [, var_name]...
```

这句话的作用是：

将cursor_name所表示的游标当前指向位置上的字段数据赋值给var_name变量。

并将游标指向下一行数据。

> 游标的查询结果集中的字段数，必须跟INTO后面的变量数一致，否则，在存储过程执行的时候，MySQL会提示错误。
>
> var_name必须在声明游标之前就定义好。
>
> 即：**`用于接收的变量，需要在声明游标之前就创建。`**

```sql
FETCH cur_name INTO emp_id, emp_sal;
```

注意：**`游标的查询结果集中的字段数，必须跟INTO后面的变量数一致`**，否则，在存储过程执行的时候，MySQL会提示错误。

比如：

声明游标如下所示：

```sql
DECLARE cursor_name CURSOR FOR
SELECT employee_id, last_name
FROM employees;
```

那么，当我们去使用游标的时候，INTO后面跟着的变量数要和声明游标时查询的字段数一致。

比如在上例中，声明时查询的字段有两个，那么在使用的时候，就需要去创建两个变量接收数据。



#### 第四步，关闭游标

```sql
CLOSE cursor_name；
```

有OPEN就会有CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭该游标，因为游标会`占用系统资源`，如果不及时关闭，**`游标就会一直保持到存储过程结束`**，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。

关闭游标后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。





# 3、使用举例

**案例1：**

创建存储过程get_count_by_limit_total_salary()，声明IN参数limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的新资值，直到薪资综合达到limit_total_salary参数的值，返回累加的人数给total_count。

```sql
DELIMITER $

CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE, OUT total_count INT)
BEGIN
	#声明变量总工资
	DECLARE sum_salary DOUBLE DEFAULT 0;
	#声明变量：当前指针指向的工资
	DECLARE cursor_salary DOUBLE DEFAULT 0;
	#声明变量：累加的人数
	DECLARE sum_count INT DEFAULT 0;
	
	#创建游标，由于需要累加最高工资，所以查询的是工资，并使用倒序排序
	DECLARE emp_cursor CURSOR FOR
		SELECT salary
		FROM employees
		ORDER BY salary DESC;
	
	#打开游标
	OPEN emp_cursor;
	
	#循环
	WHILE sum_salary < limit_total_salary DO
		#使用游标，将游标中查询到的工资使用变量存放
		FETCH emp_cursor INTO cursor_salary;
		
		#累加工资
		SET sum_salary = sum_salary + cursor_salary;
		
		#记录累加人数
		SET sum_count = sum_count + 1;
	END WHILE;

	SET total_count = sum_count;
	#关闭游标
	CLOSE emp_cursor;

END $

DELIMITER ;
```





**案例2：**

创建存储过程update_salary()，参数1为IN的INT型变量dept_id， 表示部门id；参数2为IN的INT型变量change_sal_count，表示要调整薪资的员工个数。查询指定id部门的员工信息，按照salary升序排列，根据hire_date的情况，调整前change_sal_count个员工的薪资，详情如下。

![image-20240317231622043](.\images\image-20240317231622043.png)

```sql
delimiter $
CREATE PROCEDURE update_salary(IN dept_id INT,IN change_sal_count INT)
BEGIN
	#创建变量，记录当前游标指向的员工入职日期和员工id
	DECLARE emp_hire_date DATE;
	DECLARE emp_id INT;
	
	#记录工资变化的倍数
	DECLARE salary_rate DOUBLE DEFAULT 0.0;
	
	#记录循环次数
	DECLARE num INT DEFAULT 0;

	#创建游标，需要查询出hire_date和employee_id
	DECLARE emp_cursor CURSOR FOR 
		SELECT employee_id, hire_date
		FROM employees 
		WHERE department_id = dept_id 
		ORDER BY salary ASC;
	
	#打开游标
	OPEN emp_cursor;
	
	WHILE num < change_sal_count DO
		#使用游标，将游标的信息赋值给变量
		FETCH emp_cursor INTO emp_id, emp_hire_date;
		
		#进行判断
		IF emp_hire_date < 1995 THEN 
			SET salary_rate = 1.2;
		ELSEIF emp_hire_date >= 1995 AND emp_hire_date <= 1998 THEN 
			SET salary_rate = 1.15;
		ELSEIF emp_hire_date > 1998 AND emp_hire_date <= 2001 THEN 
			SET salary_rate = 1.10;
		ELSE 
			SET salary_rate = 1.05;
		END iF;
		
		#更新数据
		UPDATE employees SET salary = salary * salary_rate WHERE employee_id = emp_id;
		
		SET num = num + 1;
	END WHILE;
	
	#关闭游标
	CLOSE emp_cursor;
END $

delimiter ;
```









# 4、小结

游标是MySQL的一个重要供，为`逐条读取`结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。

但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据进行`加锁`，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会`消耗系统资源`，造成内存不足，这时因为游标是在内存中进行的处理。

建议：养成用完之后关闭的系统，这样才能提高系统的整体效率。

