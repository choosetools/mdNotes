# 一、MySQL中的数据类型

| 类型             | 类型举例                                                     |
| ---------------- | ------------------------------------------------------------ |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、INT（或INTEGER）、BIGINT       |
| 浮点类型         | FLOAT、DOUBLE                                                |
| 定点数类型       | DECIMAL（也是一种浮点类型，精度好）                          |
| 位类型           | BIT                                                          |
| 日期时间类型     | YEAR、TIME、DATE、DATETIME、TIMESTAMP                        |
| 文本字符串类型   | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT          |
| 枚举类型         | ENUM                                                         |
| 集合类型         | SET                                                          |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB      |
| JSON类型         | JSON对象、JSON数组                                           |
| 空间数据类型     | 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON;<br>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION |

* 文本字符串类型相当于可以存储字符流数据

* 二进制字符串类型相当于可以存储字节流数据

常见数据类型的属性，如下：

| 属性               | 含义                   |
| ------------------ | ---------------------- |
| NULL               | 数据列可包含NULL值     |
| NOT NULL           | 数据列不允许包含NULL值 |
| DEFAULT            | 默认值                 |
| PRIMARY KEY        | 逐渐                   |
| AUTO_INCREMENT     | 自增，适用于整数类型   |
| UNSIGNED           | 无符号                 |
| CHARACTER SET name | 指定一个字符集         |





# 二、整数类型

## 1、类型介绍

整数类型一共有5种，包括`TINYINT`、`SMALLINT`、`MUDIUMINT`、`INT`和`BIGINT`。

它们的区别如下表所示：

| 整数类型       | 字节 | 有符号取值范围   | 无符号取值范围 |
| -------------- | ---- | ---------------- | -------------- |
| `TINYINT`      | 1    | -2^7 ~ 2^7 - 1   | 0 ~ 2^8 - 1    |
| `SMALLINT`     | 2    | -2^15 ~ 2^15 - 1 | 0 ~ 2^16 - 1   |
| `MEDIUMINT`    | 3    | -2^23 ~ 2^23 - 1 | 0 ~ 2^24 - 1   |
| `INT、INTEGER` | 4    | -2^31 ~ 2^31 - 1 | 0 ~ 2^32 - 1   |
| `BIGINT`       | 8    | -2^63 ~ 2^63 - 1 | 0 ~ 2^64 - 1   |

如果在整数型字段声明时，加了一个`UNSIGNED`，表示无符号的，此时整数类型就没有负数了，相应地在正数的范围变大。

整数类型大小有范围，插入的数据不能超出这个范围，否则就会报错，例如：

```sql
INSERT INTO test_int1(f1)
VALUES(128);
```

f1字段设置的类型是TINYINT，TINYINT的范围是-128~127，当往其中插入超出范围的数据比如128时，执行结果：

![image-20240310101019638](.\images\image-20240310101019638.png)

即此时报错了。



## 2、可选属性

整数类型的可选属性有三个：

#### 宽度M（一般不使用）

**`M`**:表示显示宽度，M的取值范围是（0,255）。

例如：int(5)，表示的意思是当数据的宽度小于5的时候，在数字前面需要使用字符来填满宽度。

**该项功能需要配合“`ZEROFILL`”使用，表示使用"0"填满宽度，否则指定显示宽度无效。**

**`在MySQL8.0之后，整数数据类型不推荐使用显示宽度属性`**，**只有在MySQL5.7版本之前才使用整数宽度。**

如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？

不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存。int(3)、int(4)、int(8)在磁盘上都是占用4bytes的存储空间。

即，这个属性表示的含义意思就是要填满的宽度。

例如：

使用以下方式去创建数据表：

```sql
CREATE TABLE test_int1(
	f1 TINYINT,
	f2 SMALLINT,
	f3 MEDIUMINT,
	f4 INT,
	f5 BIGINT
);
```

如果是MySQL8.0版本，创建出来的表如下所示：

<img src=".\images\image-20240310175208979.png" align="left">

如果是MySQL5.7版本，创建出来的表如下所示：

<img src=".\images\image-20240310175846335.png" align="left">

在MySQL5.7中，整数数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。

该属性需要搭配“**`ZEROFILL`**”一起使用才有效果，让我们去创建一个新表来看看该属性的效果：

```sql
CREATE TABLE test_int2(
f1 INT,
f2 INT(5),
f3 INT(5) ZEROFILL #f3当不足5位时，使用0填充
);
```

之后往其中添加数据：

```sql
INSERT INTO test_int2(f1, f2)
VALUES(123, 123), (123456, 123456);
```

添加成功后查询该表，得到结果：

![image-20240310182245223](.\images\image-20240310182245223.png)

发现其实，f1和f2没有区别，实际上就是没有区别，因为宽度M属性必须要配合ZEROFILL一起使用才有效果，否则和没有加该属性效果没有区别。

然后我们往f3中添加数据：

```sql
INSERT INTO test_int2(f3)
VALUES(123), (123456);
```

查询结果为：

![image-20240310182447459](.\images\image-20240310182447459.png)

发现实际上是起作用了，当数据长度不满设置的宽度时，使用“0”填满；而当数据长度超出了设置的宽度时，就不会有效果，因为宽度已经满足了。



#### 无符号UNSIGNED

`UNSIGNED`：**无符号类型**（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0.所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。

> **将整数类型字段设置成UNSIGNED，不可为负数，相应地其在正数上的范围会变成原本的两倍。**
>
> 例如：TINYINT如果为UNSIGNED，则从原本的-128~127 -> 0~255

案例：

```sql
CREATE TABLE test_int3(
	f1 INT UNSIGNED
);

DESC test_int3;
```

查询结果：

![image-20240310184458223](.\images\image-20240310184458223.png)



#### 用0填充ZEROFILL（一般不使用）

`ZEROFILL`：用0填充，（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），需要和`宽度M`属性一起使用才有意义。如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。

**当使用ZEROFILL时，默认自动使用UNSIGNED。**

**`int(M)，必须要和UNSIGNED ZEROFILL一起使用才有意义。`**



## 3、适用场景

* `TINYINT`：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。
* `SMALLINT`：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。
* `MEDIUMINT`：用于较大整数的计算，比如车站每日的客流量。
* `INT`、`INTEGER`：取值范围足够大，一般情况下不用考虑超限问题，用的最多。
* `BIGINT`：只有当处理特别巨大的整数时才会用到，比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓。

## 4、如何选择？

在评估用哪种整数类型的时候，你需要考虑`存储空间`和`可靠性`的平衡问题：一方面，用占用字节属少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起`系统错误`，影响可靠性。

举个例子，商品编号采用的数据类型是INT。原因就在于，客户门店中流通的商品种类较多，而且每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。

如果使用SMALLINT类型，虽然占用字节数比INT类型的整数少，但是却不能保证数据不会超出范围65535.相反，使用INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。

你要注意的是，在实际工作中，**`系统故障产生的成本远远超过增加几个字段存储空间所产生的成本`**。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。





# 三、浮点类型

## 1、类型介绍

浮点数和定点数类型的特点是可以`处理小数`，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。MySQL支持的浮点数类型，分别是`FLOAT`、`DOUBLE`、`REAL`。

* **`FLOAT`**表示单精度浮点数，占用4个字节。

* **`DOUBLE`**表示双精度浮点数，占用8个字节数。

  ![image-20240311081809426](.\images\image-20240311081809426.png)

* **`REAL`**默认就是DOUBLE。如果你把SQL模式设定为启用"REAL_AS_FLOAT"，那么，MySQL就认为REAL是FLOAT。如果要启用"REAL_AS_FLOAT"，可以通过以下SQL语句实现：

  ```sql
  SET sql_mode = "REAL_AS_FLOAT";
  ```

**问题1**：FLOAT和DOUBLE这两种数据类型的区别是啥呢？

FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围大。

**问题2**：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于0的部分呢？

MySQL存储浮点数的格式为：`符号（S）`、`尾数（M）`和`阶码（E）`。因此，无论有没有符号，MySQL的浮点数都会存储表示符号的部分。因此，所谓的无符号数取值范围，其实就是有符号数取值范围大于等于0的部分。



## 2、数据精度说明

对于浮点类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。

* MySQL中允许`非标准语法`（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：**`FLOAT(M, D)`**或**`DOUBLE(M, D)`**。这里的M称为`精度`，D称为`标度`。（M, D）中的M=整数位+小数位，D=小数位。所以，D<=M<=255，0<=D<=30。

  例如，定义为FLOAT(5,2)的一个列可以显示为-999.99~999.99。如果超出这个范围会报错。

* FLOAT和DOUBLE类型在不指定（M，D）时，默认会按照实际的精度来显示。

* 说明：浮点类型，也可以加**`UNSIGNED`**，但是不会改变数据范围，例如：FLOAT(3,2)UNSIGNED仍然只能表示0~9.99的范围。

* **`从MySQL8.0开始，FLOAT(M, D)和DOUBLE(M, D)用法在官方文档中已经明确不推荐使用`**，将来可能被移除。另外，**`关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了`**，将来也可能被移除。

* 不管是否设置了精度（M，D），这里**MySQL的处理方案**如下：

  > * 如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值
  > * 如果存储时，小数点部分若超出范围，就分以下情况：
  >   * 若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如：在FLOAT(5,2)列内插入999.009，此时保存下来的结果就是999.01。
  >   * 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。

* 举例：

  创建一个表test_double1

  ```sql
  CREATE TABLE test_double1(
  	f1 FLOAT,
  	f2 FLOAT(5,2),
  	f3 DOUBLE,
  	f4 DOUBLE(5,2)
  );
  ```

  往其中添加数据：

  ```sql
  INSERT INTO test_double1
  VALUES(123.456, 123.456, 123.4567, 123.45);
  ```

  查询一下test_double1表：

  <img src=".\images\image-20240311084706252.png" align="left">

  我们可以发现，插入的f2字段数据123.456中小数点部分，是超出了FLOAT(5,2)范围的，MySQL会进行四舍五入处理，进位到二位小数，变为123.46，此时未超出范围，所以正常插入。

  我们再往其中添加数据：

  ```sql
  INSERT INTO test_double1
  VALUE(123.456, 1234.45, 123.4567, 123.4567);
  ```

  此时的执行结果为：

  ![image-20240311085147091](.\images\image-20240311085147091.png)

  发现此时执行报错了，原因也在于f2字段上。f2字段声明的数据类型为FLOAT(5,2)，即小数部分最多是两位，整数部分则最多是3位，当整数部分超出了范围，则直接报错，不会进行四舍五入处理。



## 3、精度误差说明

浮点数类型有个缺陷，就是不精准。和Java中的浮点数一样。下面我们来解释一下为什么MySQL的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47，0.44,0.19，我们期待的运行结果是0.47+0.44+0.19=1.1，但实际使用sum进行查询后：

```sql
CREATE TABLE test_double2(
	f1 DOUBLE
);


INSERT INTO test_double2
VALUES(0.47),(0.44),(0.19);

SELECT SUM(f1)
FROM test_double2;
```

查询结果：

<img src=".\images\image-20240311091325038.png" align="left">

发现结果并不是我们想要的1.1，而变成了1.0999999999999999。

为什么出现这样的误差呢？

问题出在MySQL对浮点类型数据的存储方式上。

MySQL用4个字节存储FLOAT类型数据，用8个字节来存储DOUBLE类型数据。无论哪个，都是采用二进制的方式来存储的，但是如果尾数不是0或5，是无法使用二进制精准地表示浮点数的，进而，就只好在取值允许的范围内进行四舍五入。

在Java中也是一样的，只是Java会耍一个聪明，将数据转换成最近的那个整数，比如1.9999999999就会转换成2。

在编程中，如果使用到浮点数，要特别注意误差问题，**`因为浮点数是不准确的，所以我们要别面使用"="来判断两个数是否相等`**。同时，在一些对精确度要求比较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL有没有精确的数据类型呢？当然有，这就是定点数类型：`DECIMAL`。类似于Java中的BigDecimal类。

> **误差原因总结**：**`浮点数底层使用二进制来存储，如果尾数不是0或5，无法使用二进制精确地表示`**。



# 四、定点数类型：DECIMAL(M,D)

## 1、类型介绍

MySQL中定点数只有**`DECIMAL`**这一种类型。

与FLOAT、DOUBLE不同的是，DECIMAL一定要使用**DECIMAL(M, D)**的形式。

| 数据类型           | 字节数      | 含义               |
| ------------------ | ----------- | ------------------ |
| **`DECIMAL(M,D)`** | **M+2字节** | 有效范围由M和D决定 |

使用DECIMAL(M,D)的方式表示高精度小数。其中，M被称为精度，D被称为标度。0<=M<=65，0<=D<=30，D<M。例如，定义DECIMAL(5,2)的类型，表示该列取值范围是-999.99~999.99。



* **`DECIMAL(M, D)的最大取值范围与DOUBLE类型一样`**，但是有效的数据范围是有M和D决定的。并且其存储空间并不是固定的，由精度M决定，总共占用的存储空间为M+2字节。所以，当DECIMAL(M, D)要想存储和DOUBLE一样大的数据时，可能需要耗费更多的空间，因为DOUBLE只占用8个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数的数值范围更大一点。



* 定点数在MySQL内部是以**`字符串`**的形式存储的，也就决定了它一定是精准的，和Java一样。



* 当DECIMAL类型不指定精度和标度时，默认为`DECIMAL(10,0)`，即可以表示10个长度的整数，没有小数。



* 当数据的精度超出了定点数类型的精度范围时，MySQL同样会进行四舍五入处理。（与浮点数的处理一样）



* **`浮点数 vs 定点数`**
  * 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景，
  * 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景。
  * **一般都使用定点数**



* **举例1**，MySQL对DECIMAL插入数据的处理：

  创建一个表test_decimal

  ```sql
  CREATE TABLE test_decimal1(
  f1 DECIMAL,
  f2 DECIMAL(5,2)
  );
  ```

  查看这个表信息

  ```sql
  DESC test_decimal1;
  ```

  ![image-20240311094059627](.\images\image-20240311094059627.png)

  可以看见，当不给decimal设置精度和标度时，默认设置为(10,0)。

  往其中添加数据：

  ```sql
  INSERT INTO test_decimal1(f1, f2)
  VALUES(123.456, 123.456);
  ```

  查询结果：

  <img src=".\images\image-20240311094248129.png" align="left">

  插入数据当超出精度范围时，MySQL会进行四舍五入的处理。f1的精度是(10, 0)，即不包含小数，插入123.456四舍五入后得到123。f2的精度是(5,2)，即长度为5，小数长度为2，进行四舍五入得到123.46。

  再插入数据：

  ```sql
  INSERT INT test_decimal1(f2)
  VALUES(1234.5);
  ```

  执行会报错。原因就在于DECIMAL(5,2)，整数部分的长度是5-2=3,插入的数据超出了这个范围，就直接报错。

  即：

  > DECIMAL字段插入数据，类似于浮点数对数据的处理：
  >
  > 当整数部分超出了设定的范围，直接报错；
  >
  > 当小数部分超出了设定的范围，则先进行四舍五入处理，四舍五入后如果整数部分未超出，则插入成功；若整数部分超出范围，则报错。



* **举例2**，对DECIMAL精度的测试：

  将原本是DOUBLE类型的字段修改为DECIMAL(5,2)：

  ```sql
  ALTER TABLE test_double2
  MODIFY f1 DECIMAL(5,2);
  ```

  该字段中存储着如下数据：

  

  此时，去将这些数据加起来：

  ```sql
  SELECT SUM(f1)
  FROM test_double2;
  ```

  执行结果为：

  <img src=".\images\image-20240311095725322.png" align="left">

  此时，就可以得到精准的数据1.10，而不是原本的1.09999999999999999999。即DECIMAL用于精准的数据表示和计算，与Java中的BigDecimal作用一样。



## 2、开发中经验

由于DECIMAL数据的精准性，在项目中，除了极少数（比如商品编号）用到的整数类型外，其他的数值都用的是DECIMAL。





# 五、位类型：BIT(M)

BIT类型中存储的**二进制值**。

| 二进制字符串类型 | 长度 | 长度范围 | 占用空间          |
| ---------------- | ---- | -------- | ----------------- |
| `BIT(M)`         | M    | 1<=M<=64 | 约为(M+7)/8个字节 |

BIT类型，(M)表示的是**二进制的位数**，如果没有指定M，`默认是1位，最大值是64位`。



**案例：**

创建表test_bit1：

```sql
CREATE TABLE test_bit1(
	f1 BIT,
	f2 BIT(5),
	f3 BIT(64)
);

desc test_bit1;
```

查看test_bit1表结构：

![image-20240311101036252](.\images\image-20240311101036252.png)

此时我们往其中添加数据：

```sql
INSERT INTO test_bit1(f1)
VALUES (0), (1);
```

查询结果：

<img src=".\images\image-20240311101230780.png" align="left">

再往其中添加数据：

```sql
INSERT INTO test_bit1(f2)
VALUES (32);
```

此时执行就会报错，因为f2字段的位类型长度为5，即可以存储5个长度的二进制，可以存储的数据长度为1+2+4+8+16=31，32超过了该字段最高能存储的数据。

> 所以，**在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内**。



当我们使用SELECT命令查询位字段时，可以使用**`BIN()`**查询数据对应的十六进制数，或**`HEX()`**函数查询其对应的二进制数，也可以使用**`+0`**的方式显示十进制。例如：

往f2中添加数据：

```sql
INSERT INTO test_bit1(f2)
VALUES (31);
```

查询数据：

```sql
SELECT BIN(f1),BIN(f2),HEX(f1), HEX(f2), f1+0, f2+0
FROM test_bit1;
```

查询结果：

<img src=".\images\image-20240311102637558.png" align="left">



在开发中，实际使用这种类型比较少。



# 六、日期时间类型

日期和时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。

MySQL有多种表示日期和时间的数据类型，不同的版本可能有差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。

* `YEAR`类型通常用来表示年
* `DATE`类型通常用来表示年、月、日
* `TIME`类型通常用来表示时、分、秒
* `DATETIME`类型通常用来表示年、月、日、时、分、秒
* `TIMESTAMP`类型通常用来表示带时区的年、月、日、时、分、秒

| 类型           | 名称     | 字节 | 日期格式            | 最小值                  | 最大值                  |
| -------------- | -------- | ---- | ------------------- | ----------------------- | ----------------------- |
| YEAR           | 年       | 1    | YYYY                | 1901                    | 2155                    |
| TIME           | 时间     | 3    | HH:MM:SS            | -839:59:59              | 839:59:59               |
| DATE           | 日期     | 3    | YYYY-MM-DD          | 1000-01-01              | 9999-12-03              |
| **`DATETIME`** | 日期时间 | 8    | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00     | 9999-12-31 23:59:59     |
| TIMESTAMP      | 日期时间 | 4    | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:00 UTC | 2038-01-19 03:14:07 UTC |

可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。

为什么时间类型的TIME取值范围不是-23:59:59~23:59:59呢？原因是MySQL设计的TIME类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过24小时。



## 1、YEAR类型

YEAR类型用来表示**年份**，在所有的日期时间类型中所占用的存储空间最小，只需要**`1个字节`**的存储空间，范围为**`1901~2155`**。

在MySQL中，YEAR有两种存储格式，分别是以四位字符串的形式和以两位字符串的形式。在开发中，不要使用两位字符串的形式存储：

* 以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。
* 以2位字符串格式表示YEAR类型，最小值为00，最大值为99.
  * 当取值为01到69时，表示2001到2069；
  * 当取值为70到99时，表示1970到1999；
  * 当取值整数的0或00添加的话，那么是0000年；
  * 当取值是日期/字符串的'0'添加的话，是2000年。

**`2位格式的YEAR不推荐使用`**。YEAR默认格式就是"`YYYY`"，没必要写成YEAR(4)。

使用案例：

```sql
CREATE TABLE test_year(
	f1 YEAR,
	f2 YEAR(4) #不推荐这种写法
);

DESC test_year;
```

执行结果：

![image-20240311105456130](.\images\image-20240311105456130.png)

往其中添加数据：

```sql
INSERT INTO test_year
VALUES('2020','2021'),('45','71'),(0,'0'); #后面两个2位格式的YEAR的写法不推荐
```

查询结果：

<img src=".\images\image-20240311105601068.png" align="left">



## 2、DATE类型

DATE类型表示日期，没有时间部分，格式为**`YYYY-MM-DD`**，其中，YYYY表示年份，MM表示月份，DD表示天数。需要`3个字节`的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。

* 以`YYYY-MM-DD`格式或者`YYYYMMDD`格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYDDMM格式会隐式地转化为YYYY-MM-DD格式。
* 以`YY-MM-DD`格式或者`YYMMDD`格式表示的字符串日期（不推荐使用），此格式中，年份两位数值或字符串满足YEAR类型的格式条件：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。

* 可以使用**`CURDATE()`**，**`CURRENT_DATE()`**或者**`NOW()`**函数，插入当前系统的日期。注意，NOW()是包含时间的，如果插入到DATE类型字段中，会把时间去掉，只插入日期。

举例：

创建数据表，表中只包含一个DATE类型的字段f1：

```sql
CREATE TABLE test_date1(
	f1 DATE
);
```

分别向其中插入三次数据，每次插入后的结果分别为：

```sql
INSERT INTO test_date1
VALUES('2020-10-01'),('20201001'),(20201001);
```

<img src=".\images\image-20240311111949113.png" align="left">

```sql
# 不推荐以下方式，以下方式会将YY转换成YYYY
INSERT INTO test_date1
VALUES ('00-01-01'), ('000101'), ('69-10-01'), ('691001'), ('70-01-01'), ('700101'),
('99-01-01'), ('990101');
```

<img src=".\images\image-20240311112209403.png" align="left">

```sql
INSERT INTO test_date1
VALUES (CURRENT_DATE()), (CURDATE()), (NOW());
```

<img src=".\images\image-20240311112151795.png" align="left">



## 3、TIME类型

TIME类型用来表示**时间**，不包括日期部分。在MySQL中，需要`3个字节`的存储空间来存储TIME类型的数据，可以使用"**`HH:MM:SS`**"格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。

在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式：

1. 可以使用带有冒号的字符串，比如'`D HH:MM:SS`'、'`HH:MM:SS`'、'`HH:MM`'、'`D HH:MM`'、'`D HH`'或'`SS`'格式，都能被正确地插入TIME类型的字段中。其中，D表示天，最小值为0，最大值为34。
   * 当使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。
   * 当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10，即此时认为的是小时和分钟。
2. 可以使用不带有冒号的字符串或者数字，格式为'`HHMMSS`'或`HHMMSS`。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00，即此时认为的是分钟和秒数。
3. 使用**`CURRENT_TIME()`**、**`CURTIME()`**或者**`NOW()`**，会插入当前系统的时间。NOW()则会将日期去除，只插入时间。

所以，在使用TIME字段时，尽量就使用'**`HH:MM:SS`**'或'**`D HH:MM:SS`**'的格式，简洁明了。

案例：

创建数据表test_time1，其中包含TIME字段f1：

```sql
CREATE TABLE test_time1(
	f1 TIME
);
```

向f1字段添加数据：

```sql
INSERT INTO test_time1
VALUES('2 12:30:29'), ('11:35:18'), ('18:45'), ('2 05:21'), ('45'), ('123256'), (194911), (1210), (NOW()), (CURRENT_TIME());
```

查询结果为：

<img src=".\images\image-20240311113947947.png" align="left">

从上例结果中，可以知道，当有:冒号时，会从左到右进行解析，不足的位置使用0补齐；当没有:冒号时，会从右到左解析，不在的位置使用0补齐。比如18:45，会解析成为18:45:00；1210，会解析成为00:12:10。



## 4、DATETIME类型

DATETIME表示**日期时间**。

DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要**`8个字节`**的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为**`YYYY-MM-DD HH:MM:SS`**，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。

在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。

* 以`YYYY-MM-DD HH:MM:SS`格式或者`YYYYMMDDHHMMSS`格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59
  * 以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。
* 以YY-MM-DD HH:MM:SS格式或者YYMMDDHHMMSS格式（不推荐使用）的字符串插入DATETIME类型字段时，两位数的年份规则符合YEAR类型规则，00到69表示2000到2069；70到99表示1970到1999。

* 使用函数**`SYSDATE()`**、**`CURRENT_TIMESTAMP()`**和**`NOW()`**，可以向DATETIME类型的字段插入系统当前日期和时间。

举例：

创建数据表test_datetime1，表中包含一个DATETIME类型的字段dt。

```sql
CREATE TABLE test_datetime1(
	dt DATETIME
);
```

插入数据：

```sql
INSERT INTO test_datetime1 VALUES ('2021-01-01 06:50:30'), ('20210101065030'), (SYSDATE()), (CURRENT_TIMESTAMP()), (NOW());
```

查询结果：

<img src=".\images\image-20240311121652722.png" align="left">



## 5、TIMESTAMP类型

TIMESTAMP**时间戳类型**。

TIMESTAMP类型也可以表示日期时间，需要**`4个字节`**的存储空间，其显示格式与DATETIME类型相同，都是**`YYYY-MM-DD HH:MM:SS`**。TIMESTAPM存储的时间范围比DATETME要小很多，只能存储**“1970-01-01 00:00:00 UTC”到“2038-01-19 03:14:07 UTC”**之间的时间，其中，UTC表示世界统一时间，也叫作世界标准时间。

* **`存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。`**

因为TIMESTAMP**底层存储的是毫秒值**，是距离1970-01-01 00:00:00 0毫秒的毫秒值，只不过显示的样式是YYYY-MM-DD HH:MM:SS，所以TIMESTAMP是**时间戳类型**。

向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。

如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。

TIMESTAMP时间戳类型一般用来存储当前的时间，如果需要对历史上某一事件的时间进行存储，就不方便了，因为TIMESTAMP表示的时间范围比较小。

案例：

创建数据表test_timestamp1，表中包含一个TIMESTAMP类型的字段ts：

```sql
CREATE TABLE test_timestamp1(
	ts TIMESTAMP
);
```

向其中插入数据：

```sql
INSERT INTO test_timestamp1
VALUES('1999-01-01 03:04:05'),('19990101030405'),('99-01-01 03:04:05'),(CURRENT_TIMESTAMP()),(NOW()),(SYSDATE());
```

查询结果：

<img src=".\images\image-20240311135223609.png" align="left">

如果向其中添加数据：

```sql
INSERT INTO test_timestamp1
VALUES('2038-01-20 03:14:55');
```

此时就会报错：

![image-20240311135351875](.\images\image-20240311135351875.png)原因在于TIMESTAMP只能存储1970-01-01 00:00:00到2038-01-19 03:14:07之间的数据，例中插入的数据超出了这个范围，所以报错。



## 6、TIMESTAMP vs DATETIME

* TIMESTAMP存储空间比较小，表示的日期时间范围也比较小。

* 底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-01-01 00:00:00 0毫秒的毫秒值。

* **`两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。`**

* TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差。

  案例：

  ```sql
  #创建表temp_time，第一个字段是DATETIME类型，第二个字段是TIMESTAMP类型
  CREATE TABLE temp_time(
  	d1 DATETIME,
  	d2 TIMESTAMP
  );
  
  #往其中插入两对相同的数据
  INSERT INTO temp_time VALUES('2021-09-02 14:45:52', '2021-09-02 14:45:52'),(NOW(), NOW());
  ```

  查询表中数据，结果为：

  <img src=".\images\image-20240311140434529.png" align="left">

  修改当前的时区，将其修改成东九区（中国是东八区）：

  ```sql
  SET time_zone = '+9:00';
  ```

  然后再去查看表中的数据，结果为：

  <img src=".\images\image-20240311140550025.png" align="left">

  发现，d2字段的时间比d1字段的时间大一个小时。

  这是因为TIMESTAMP类型会随着时区的变化而变化，根据其存储的时间和时区，在不同的时区显示不同的时间；但是DATETIME不会这样，字段存储的时间不会因为时区的变化而发生变化。

## 7、开发中的经验

用得最多的日期时间类型，就是**`DATETIME`**。虽然MySQL也支持YEAR、TIME、DATE以及TIMESTAMP类型，但是在实际项目中，尽量使用DATETIME。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间分散在好几个字段，很不容易记，而且查询的时候SQL也会更加复杂。

此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用`时间戳`，因为DATETIME虽然直观，但不便于计算。TIMESTAMP更方便进行计算与比较。

`UNIX_TIMESTAMP()`，获取当前时间的时间戳。

```sql
SELECT UNIX_TIMESTAMP();
```

<img src=".\images\image-20240311141426576.png" align="left">





# 七、文本字符串类型

在实际的项目中，我们还经常遇到一种数据，就是字符串数据。

在MySQL中，文本字符串总体上分为`CHAR`、`VARCHAR`、`TINYTEXT`、`TEXT`、`MEDIUMTEXT`、`LONGTEXT`、`ENUM`、`SET`等类型。

| 文本字符串类型 | 值的长度 | 长度范围         | 占用的存储空间   |
| -------------- | -------- | ---------------- | ---------------- |
| CHAR(M)        | M        | 0<=M<=255        | M个字节          |
| VARCHAR(M)     | M        | 0<=M<=65535      | M+1个字节        |
| TINYTEXT       | L        | 0<=L<=255        | L+2个字节        |
| TEXT           | L        | 0<=L<=65535      | L+2个字节        |
| MEDIUMTEXT     | L        | 0<=L<=16777215   | L+3个字节        |
| LONGTEXT       | L        | 0<=L<=4294967295 | L+4个字节        |
| ENUM           | L        | 1<=L<=65535      | 1或2个字节       |
| SET            | L        | 0<=L<=64         | 1,2,3,4或8个字节 |

## 1、CHAR与VARCHAR

CHAR与VARCHAR类型都可以**存储比较短的字符串**。

最大区别在于：**`CHAR是固定长度的，VARCHAR是可变长度的`**。

当存储的数据是固定长度时，推荐使用CHAR，因为CHAR的**`效率较高`**。

| **字符串（文本）类型** | **特点** | **长度** | **长度范围** | **占用的存储空间**   |
| ---------------------- | -------- | -------- | ------------ | -------------------- |
| **`CHAR(M)`**          | 固定长度 | M        | 0<=M<=255    | M个字节              |
| **`VARCHAR(M)`**       | 可变长度 | M        | 0<=M<=65525  | （实际长度+1）个字节 |

**注意：**

这里的M指的是该字段最多可容纳多少字符的数据，10字符就可以容纳10个汉字；并不是指容纳多少字节的数据。

#### CHAR类型：

* CHAR(M)类型一般需要先预定义字符串长度。如果不指定(M)，则表示**长度默认是`1`个字符**。
* 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在`右侧填充空格`以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去掉尾部的空格。
* 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的空间的字节数。

案例：

创建一个表test_char1，该表中有两个CHAR类型的字段：

```sql
CREATE TABLE test_char1(
c1 CHAR,
c2 CHAR(5)
);
```

查看一下这个表中的结构：

![image-20240311151132535](.\images\image-20240311151132535.png)

发现，当给字段声明成CHAR不指定长度(M)时，则长度默认是1个字符。

往其中添加数据：

```sql
INSERT INTO test_char1(c2)
VALUES('你好'),('nihao'),('你好啊我是');
```

查询结果：

<img src=".\images\image-20240311151623792.png" align="left">

若往其中添加数据：

```sql
INSERT INTO test_char1(c1)
VALUES('你好');
```

此时就会报错：Data too long for column，原因在于c1字段是CHAR(1)类型，最多只能容纳1个字符的数据。



**问题：**

在前面的介绍中，我们可以知道，在CHAR类型的字段中，如果数据实际的长度比CHAR类型声明的长度小，会在右侧填充空格，当MySQL去检索的时候，又会去去除尾部的空格。那假如，我们添加的数据中，右侧本身带有空格，MySQL检索的时候会去除吗？

测试一下：

```sql
INSERT INTO test_char1(c2) VALUES('a ');
```

查询结果：

<img src=".\images\image-20240311152357522.png" align="left">

结果发现：是的，如果往CHAR字段中插入的数据右侧带有空格，则检索的时候MySQL会去去除掉这些空格。



#### VARCHAR类型

* VARCHAR(M)定义时，**`必须指定长度M`**，否则报错。这里的长度M，相当于设置了一个最大字符数。

* 与CHAR不同的是，VARCHAR是可变长度的字符型数据，检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字符。

* **注意：**

  > **VARCHAR类型M的长度最大只能设置为`21845`，而不是65535**，因为这个65535指的是字节长度，不是字符的长度，要除以3得到21845。

测试案例：

```sql
CREATE TABLE test_varchar1(
	`name` VARCHAR #报错，要设置M长度
);
```

```sql
#报错，最大只能设置21845
CREATE TABLE test_varchar1(
	`name` VARCHAR(65535)
);
```

```sql
CREATE TABLE test_varchar3(
NAME VARCHAR(5)
);
INSERT INTO test_varchar3
VALUES('尚硅谷'),('尚硅谷教育');

#报错：Data too long for column 'NAME' at row 1
INSERT INTO test_varchar3
VALUES('尚硅谷IT教育');
```

<img src=".\images\image-20240311154237620.png" align="left">



**问题：**

不同于CHAR(M)，VARCHAR(M)是可变长度的，占用的存储空间也是根据实际长度的字符计算的。那么，VARCHAR(M)中这个M的意义是什么？可不可以去掉？

答案是不可的。设置M长度，实际上就是给该字段设置了一个最大值，所有的数据长度都不可以超过这个M长度。



#### 哪些情况使用CHAR或VARCHAR更好

| 类型       | 特点     | 空间上       | 时间上 | 适用场景             |
| ---------- | -------- | ------------ | ------ | -------------------- |
| CHAR(M)    | 固定长度 | 浪费存储空间 | 效率高 | 存储不大，速度要求高 |
| VARCHAR(M) | 可变长度 | 节省存储空间 | 效率低 | 非CHAR的情况         |

**`一般情况下，都建议使用VARCHAR。`**

**特殊情况：**

* 情况1：存储很短的信息。比如门派号码101，201，...这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度。
* 情况2：固定长度的。比如使用uuid作为主键，那应该使用char更合适。因为其固定长度，而varchar还要多占个长度信息。
* 情况3：十分频繁改变的字段。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多精力用于计算，而这些对于char来说是不需要的。
* 情况4：具体存储引擎中的情况：
  * `MyISAM`数据存储引擎和数据列：MyISAM数据表，最好使用固定长度（CHAR）的数据列代替可变长度（VARCHAR）的数据列。这样使得整个表静态化，从而使`数据检索更快`，用空间换时间。
  * `MEMORY`存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR都没有关系，两者都是作为CHAR类型处理的。
  * `InnoDB`存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且**`主要影响性能的因素是数据行使用的存储总量`**，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。



## 2、TEXT

在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT类型。

在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。

每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：

| 文本字符串类型 | 特点               | 长度 | 长度范围         | 占用的存储空间 |
| -------------- | ------------------ | ---- | ---------------- | -------------- |
| TINYTEXT       | 小文本、可变长度   | L    | 0<=L<=255        | L+2个字节      |
| TEXT           | 文本、可变长度     | L    | 0<=L<=65535      | L+2个字节      |
| MEDIUMTEXT     | 中等文本、可变长度 | L    | 0<=L<=16777215   | L+3个字节      |
| LONGTEXT       | 大文本、可变长度   | L    | 0<=L<=4294967295 | L+4个字节      |

**`由于实际存储的长度不确定，MySQL不允许TEXT类型的字段做主键`**。遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)。

举例：

创建数据表：

```sql
CREATE TABLE test_text(
	tx TEXT
);

INSERT INTO test_text
VALUES('nihao      ');
```

查询结果：

<img src=".\images\image-20240311164436141.png" align="left">

说明在保存和查询数据时，并没有不会像CHAR一样去删除TEXT类型的数据尾部的空格。

**`开发中的经验：`**

TEXT文本类型，可以存比较大的文本段，搜索速度较慢，因此如果不是特别大的内容，建议使用CHAR、VARCHAR来代替。还有TEXT类型不用加默认值。TEXT和BLOB类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。



# 八、ENUM类型

ENUM类型也叫作**枚举类型**，ENUM类型的取值范围需要在定义字段时进行指定。

**`在创建字段时，设置所有的枚举类型成员，插入数据时只允许从成员中选取单个值，不能一次选取多个值。`**

其所需要的存储空间由定义ENUM类型时指定的成员个数决定。

| 文本字符串类型 | 长度 | 长度范围    | 占用的存储空间 |
| -------------- | ---- | ----------- | -------------- |
| ENUM           | L    | 1<=L<=65535 | 1或2个字节     |

* 当ENUM类型包含1~255个成员时，需要1个字节的存储空间；
* 当ENUM类型包含256~65535个成员时，需要2个字节的存储空间。
* ENUM类型的成员个数上限为65535个。

举例：

创建表如下：

```sql
CREATE TABLE test_enum(
    #设置枚举成员，只能添加成员
	season ENUM('春','夏','秋','冬','unknow')
);
```

添加数据

```sql
INSERT INTO test_enum
VALUES('春'),('秋');

# 忽略大小写
INSERT INTO test_enum
VALUES('UNKNOW');

# 允许按照角标的方式获取指定索引位置的枚举值
INSERT INTO test_enum
VALUES('1'),(3);

# 报错：Data truncated for column 'season' at row 1
# 只能插入在创建字段时设置的成员
INSERT INTO test_enum
VALUES('ab');

# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
INSERT INTO test_enum
VALUES(NULL);
```

查询结果：

<img src=".\images\image-20240311170212979.png" align="left">



# 九、SET类型

SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为`64`。设置字段时，可以取取取值范围内的0个或多个值。

当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L表示实际成员个数） | 占用的存储空间 |
| --------------------------------- | -------------- |
| 1<=L<=8                           | 1个字节        |
| 9<=L<=16                          | 2个字节        |
| 17<=L<=24                         | 3个字节        |
| 25<=L<=32                         | 4个字节        |
| 33<=L<=64                         | 8个字节        |

SET类型在存储数据时成员个数越多，其占用的存储空间越大。

**注意：**

> 与ENUM类型不同的是，SET类型在选取成员时，可以一次选择多个成员，即一个数据可以插入多个成员，成员之间使用,逗号分隔。

案例1：

创建表

```sql
CREATE TABLE test_set(
	s SET('a','b','c')
);
```

向表中插入数据

```sql
# 忽略大小写
INSERT INTO test_set (s) VALUES ('A'), ('A,B');

#插入重复的SET类型成员时，MySQL会自动删除重复的成员，类似于Java中的Set集合筛选掉重复数据
INSERT INTO test_set (s) VALUES ('A,B,C,A');

#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
INSERT INTO test_set (s) VALUES ('A,B,C,D');
```

查询结果：

<img src=".\images\image-20240311171800476.png" align="left">

案例2：

```sql
CREATE TABLE temp_mul(
gender ENUM('男','女'),
hobby SET('吃饭','睡觉','打豆豆','写代码')
);
```

```sql
INSERT INTO temp_mul VALUES('男','睡觉,打豆豆'); #成功

# Data truncated for column 'gender' at row 1
INSERT INTO temp_mul VALUES('男,女','睡觉,写代码'); #失败

# Data truncated for column 'gender' at row 1
INSERT INTO temp_mul VALUES('人妖','睡觉,写代码');#失败

INSERT INTO temp_mul VALUES('男','睡觉,写代码,吃饭'); #成功
```





# 十、二进制字符串类型

MySQL中的二进制字符串主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。

MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB类型。

## 1、BINARY与VARBINARY类型（使用的少）

BINARY与VARBINARY的关系，可以看成是CHAR与VARCHAR的关系。只不过它们存储的是**`二进制字节型数据`**，底层使用的是字节的方式进行存储的，所以当插入的数据是中文字符时，会将其转换成二进制字节数据存储，

> **将BINARY和VARBINARY看作是使用二进制字节存储的CHAR和VARCHAR就行。**
>
> 当我们往其中添加字符时，需要将其转换成字节进行存储，然后检索时又将其转换回字符，所以我们需要注意因字符集不同而造成的乱码问题。如果是英文字符则不存在这样的问题。

**`BINARY(M)`**（可以将其看成是使用字节存储的CHAR）为固定长度的二进制字节串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储`1个字节`。例如BINARY(8)，表示最多能存储8个字节，如果字段值不足（M）个字节，将在右边填充'\0'以补齐指定长度。

**`VARBINARY(M)`**（可以将其看成是使用字节存储的VARCHAR）为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1个或2个字节来存储数据的字节数。VARBINARY类型`必须指定(M)`，否则报错。

| 二进制字符串类型 | 特点     | 值的长度       | 占用空间  |
| ---------------- | -------- | -------------- | --------- |
| BINARY(M)        | 固定长度 | M(0<=M<=255)   | M个字节   |
| VARBINARY(M)     | 可变长度 | M(0<=M<=65535) | M+1个字节 |

案例：

创建表

```sql
CREATE TABLE test_binary1(
	f1 BINARY,
	f2 BINARY(3),
	f3 VARBINARY(10)
);
```

查看数据表的结构：

![image-20240311181656511](.\images\image-20240311181656511.png)

插入数据

```sql
INSERT INTO test_binary1(f1, f2)
VALUES('a', 'a');

# 报错：原因在于'你'这个中文字符在MySQL底层若使用utf8字符集，使用三个字节存储
INSERT INTO test_binary1(f1)
VALUES('你');

INSERT INTO test_binary1(f2)
VALUES('你');

INSERT INTO test_binary1(f2,f3)
VALUES('ab','ab');
```

查询结果：

<img src=".\images\image-20240311182018759.png" align="left">

上述就出现了乱码问题，原因就是检索时使用的字符集与存储的字符集不一致导致的。

## 2、BLOB类型

BLOB是一个`二进制大对象`，可以容纳可变数量的数据。

MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同，可以存储一个二进制的大对象，比如`图片`、`音频`和`视频`等。

需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到`服务器的磁盘上`，并将图片、音频和视频的访问路径存储到MySQL中。

| 二进制字符串类型 | 值的长度 | 长度范围         | 占用空间  |
| ---------------- | -------- | ---------------- | --------- |
| TINYBLOB         | L        | 0<=L<=255        | L+1个字节 |
| BLOB             | L        | 0<=L<=65535      | L+2个字节 |
| MEDIUMBLOB       | L        | 0<=L<=16777215   | L+3个字节 |
| LONGBLOB         | L        | 0<=L<=4294967295 | L+4个字节 |



**`TEXT和BLOB的使用注意事项`**：

在使用TEXT和BLOB字段类型时要注意以下几点，以便更好的发挥数据库的性能。

* 1、BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的“`空洞`”，以后填入这些“空洞”的记录可能长度不同。为了提高性能，建议定期使用OPTIMIZE TABLE供对这类表进行`碎片整理`。
* 2、如果需要对大文本字段进行模糊查询，MySQL提供`前缀索引`。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的数据。
* 3、把BLOB或TEXT列`分离到单独的表`中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会`减少主表中的碎片`，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行SELECT *查询的时候不会通过网络传输大量的BLOB或TEXT值。





# 十一、JSON类型

JSON（JavaScript Object Notation）是一种轻量级的`数据交换格式`。简洁和清晰的层次结构使得JSON成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。**`JSON可以将JavaScript对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。`**

在MySQL5.7中，就已经支持JSON数据类型。在MySQL8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。创建数据表，表中包含与一个JSON类型的字段js：

```sql
CREATE TABLE test_json(
	js json
);
```

向表中插入JSON数据：

```sql
INSERT INTO test_json (js)
VALUES ('{"name":"songhk", "age":18, "address":{"province":"beijing",
"city":"beijing"}}');
```

查看表中的数据：

![image-20240311221311364](.\images\image-20240311221311364.png)

可以去检索JSON类型的字段中数据的某个具体值时，可以使用"->"和"->>"符号

例如：

```sql
SELECT js -> '$.name' AS `name`, js -> '$.age' AS age, js -> '$.address.province' AS province, js -> '$.address.city' AS city
FROM test_json;
```

查询结果：

![image-20240311221934324](.\images\image-20240311221934324.png)

通过"->"和"->>"符号，从JSON字段中正确查询出了指定的JSON数据的值。



# 十二、空间类型（了解）

![image-20240311222158996](.\images\image-20240311222158996.png)![image-20240311222218298](.\images\image-20240311222218298.png)

![image-20240311222326330](.\images\image-20240311222326330.png)



# 十三、小结及选择建议

在定义数据类型时，如果确定是`整数`，就用`INT`；如果是`小数`，一定用定点数类型`DECIMAL(M,D)`；如果是日期与时间，就用`DATETIME`。

这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡是都是有两面性的，可靠性好，并不意味着高效。比如，TEXT虽然使用方便，但是效率不如CHAR(M)和VARCHAR(M)。

关于字符串的选择，建议参考阿里巴巴的《Java开发手册》规范：

**`阿里巴巴《Java开发手册》之MySQL数据库：`**

* 任何字段如果为非负数，必须是UNSIGNED
* 【`强制`】小数类型为DECIMAL，禁止使用FLOAT和DOUBLE。
  * 说明：在存储的时候，FLOAT和DOUBLE都存在精度损失的问题，很可能在比较值的时候，得不到不正确的结果。如果存储的数据范围超过DECIMAL的范围，建议将数据拆成整数和小数并分开存储。
* 【`强制`】如果存储的字符串长度几乎相等，使用CHAR定长字符串类型。
* 【`强制`】VARCHAR是可变长字符串，不预先分配存储空间，长度不要超过5000。如果存储长度大于此值，定义字段类型为TEXT，独立出来一张表，用主键来对应，避免影响其他字段索引效率。





# 选择推荐

改进表的设计时，可以考虑优化字段的数据类型。当数据量越来越多的似乎，不能只从系统稳定性的角度思考问题，还要考虑系统整体的稳定性和效率。此时，**`优先考虑符合存储需要的最小的数据类型。`**

列的`字段越大`，建立索引时所需要的`空间也就越大`，这样一页中所能存储的`索引节点的数量也就越少`，在遍历时所需要的`IO次数也就越多`，`索引的性能也就越差`。

具体来说：

**情况1：对正数类型数据进行优化**

遇到正数类型的字段可以用**`INT型`**。这样做的理由是，INT型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。

对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符合整形**`UNSIGNED`**来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128~127，无符号为0~255，多出一倍的存储空间。

**情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型**

跟文本类型相比，大整数往往`占用更少的存储空间`，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。

**情况3：避免使用TEXT、BLOB数据类型**

MySQL`内存临时表`不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用`磁盘临时表`进行。并且对于这种数据，MySQL还是要进行`二次查询`，会使SQL性能变得很差，但是不是说一定不能使用这样的数据类型。

如果一定要使用，建议把BLOB或是TEXT列`分离到单独的扩展表`中，查询时一定不要使用select *，而只需要取出必要的列，不需要把TEXT列的数据时不要对该列进行查询。

**情况4：避免使用ENUM类型**

修改ENUM值需要使用ALTER语句。

ENUM类型的ORDER BY操作效率低，需要额外操作。使用TINYINT类型代替ENUM类型。

**情况5：使用TIMESTAMP存储时间**

TIMESTAMP存储的时间范围1970-01-01 00:00:01 至 2038-01-19 03:14:07。TIMESTAMP使用4个字节，DATETIME使用8个字节。并且TIMESTAMP具有自动赋值以及自动更新的特性，对于create_time和update_time来说，再好不过。

**情况6：使用DECIMAL代替FLOAT和DOUBLE存储精确浮点数**

1）非精确浮点数：float、double

2）精确浮点数：decimal

DECIMAL类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。

**`总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优。`**