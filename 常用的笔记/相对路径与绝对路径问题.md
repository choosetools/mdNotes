## 路径问题（:star:）

### 文件准备

在项目中，创建如下结构：

<img src=".\images\image-20240603132623667.png" alt="image-20240603132623667" style="zoom:80%;" />  



### 相对路径与绝对路径问题

#### 相对路径情况分析

**相对路径：`以当前资源的所在路径为出发点，去找目标资源。`**

**相对路径语法：**

* 不以/开头
* ./表示当前资源路径，./可以省略
* ../表示上一层资源路径

> **`相对路径的规则就是当前资源的所在路径后，拼接目标资源的路径，然后发送请求找目标资源。`**



请查看具体的案例解释。



##### 情况1

假设，我们要在index.html中使用img标签引入webapp/static/img目录中的图片人物.jpg。

<img src=".\images\image-20240603130052150.png" alt="image-20240603130052150" style="zoom: 80%;" /> 

那么index.html是在webapp下的，而人物.jpg是在webapp下的static目录下的img目录中，所以在index.html中，使用img引入图片的写法是：

```html
<img src="./static/img/人物.jpg">
```

那么，此时去访问index.html页面，页面的呈现：

![image-20240603122817245](.\images\image-20240603122817245.png) 

就能够将图片显示出来。



**那具体访问该图片的过程是怎么样的呢？**

首先，我们去访问这个index.html，假设该index.html在demo05项目下，并且部署在Tomcat服务器中，那么这个资源的url就是http://localhost:8080/domo05/index.html。

通过这个url去访问index.html，服务端将index.html文件的数据响应给客户端，客户端就会去解析html文件数据。在解析代码过程中，客户端解析到了`<img src="./static/img/人物.jpg">`这段代码，然后客户端就会根据img中的路径去发送请求给服务端，获取图片。

也就是说，解析的请求是客户端发送的，客户端是不知道服务端中的目录结构，只会根据响应得到的路径信息发送请求。

客户端不知道服务端的目录结构，但是知道当前资源的路径：http://localhost:8080/domo05/index.html，客户端会根据当前资源路径与相对路径路径的关系得到要请求资源的路径。

**当前资源的请求路径**：http://localhost:8080/demo05/index.html

**当前资源是**：`index.html`

**当前资源的所在路径**：http://localhost:8080/demo05

**目标路径**：`./static/img/人物.jpg`

> **`相对路径的规则就是当前资源的所在路径后，拼接目标资源的路径，然后发送请求找目标资源。`**

那么，当解析index.html响应数据后，要去查找指定的图片数据，就会在当前资源的所在路径后，拼接图片目标资源的路径，得到的路径是：`http://localhost:8080/demo05/static/img/人物.jpg`，此时，浏览器就根据这个路径去发送请求访问资源，如果该路径能够正确地匹配上对应的文件时，此时服务端就会将对应的文件数据响应回来，此时客户端就能够拿到数据。





##### 情况2

假设在webapp中的a/b/c目录下的test.html中，也想使用img标签引入webapp中的static/img目录下的人物.jpg图片：

<img src=".\images\image-20240603130220342.png" alt="image-20240603130220342" style="zoom:67%;" /> 

此时，在test.html中，该如何使用相对路径去引入该图片呢？

**分析：**

test.html资源的访问路径应该是http://localhost:8080/a/b/c/test.html，浏览器访问该文件，服务端响应数据给浏览器，浏览器解析响应体数据时发现其中有一个img标签，是使用相对路径的方式引入人物.jpg。

然后浏览器就会发送第二次请求给服务器，第二次请求的目的就是去访问图片资源。

由于在src中使用的是相对路径，相对路径是根据当前资源的所在路径，拼接相对路径的方式获取完整的路径。

**当前资源（也就是test.html）的所在路径是**：http://localhost:8080/demo05/a/b/c/

而我们**要去获取目前资源（也就是图片）的路径是**：http://localhost:8080/demo05/static/img/人物.jpg

我们可以看到，当前资源所在的路径和目标资源路径前面相同的路径是：http://localhost:8080/demo05/，所以我们若想要让相对路径拼接上当前资源路径，就需要在相对路径中，将/a/b/c/这三个目录抵消，也就是往目录前面移动。

在相对路径中，使用../的方式，将目录抵消，那么我们需要抵消三个目录，就是使用`../../../`的方式，然后再往当前资源的所在路径后面拼接/static/img/人物.jpg，所以最终在test.html中，引入图片的路径是：`../../../static/img/人物.jpg`

```html
<img src="../../../static/img/人物.jpg">
```

当开test.html的显示结果：

<img src=".\images\image-20240603131715258.png" alt="image-20240603131715258" style="zoom: 80%;" /> 





##### 情况3

以上两种情况，磁盘结构与url结构是一致的，所以可以直接通过磁盘结构使用相对路径来进行访问。但是有一些情况下，url的路径结构和磁盘结构实际上是不一致的，此时就不能通过磁盘结构，来对项目中的资源进行访问。

假如：要在webapp/WEB-INF/views/view1.html中，获取webapp/static/img/人物.jpg：

<img src=".\images\image-20240603175833195.png" alt="image-20240603175833195" style="zoom: 80%;" /> 

那么，此时我们使用相对路径在view1.html中对图片进行访问：

```html
<img src="../../static/img/人物.jpg">
```

那此时，是否可以通过使用请求转发的方式，跳转到view1.html，然后在view1.html中访问到该图片呢？

答案是不行的。

我们来测试一下：
首先，由于view1.html文件放在WEB-INF中，所以我们使用请求转发来进行访问。

在View1Servlet中，使用请求转发的方式来访问该view1.html：

```java
@WebServlet("/view1Servlet")
public class View1Servlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取RequestDispatcher对象
        // 由于当前Servlet的路径是http://localhost:8080/demo05/view1Servlet
        //所以当前资源的当前路径是http://localhost:8080/demo05/
        //使用相对路径，那么实际访问的路径是http://localhost:8080/demo05/WEB-INF/views/view1.html
        //由于使用的是请求转发，所以可以访问到WEB-INF中的资源
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("./WEB-INF/views/view1.html");
        requestDispatcher.forward(req, resp);
    }
}
```

那么，此时就使用了请求转发的方式访问到了webapp/WEB-INF/views/view1.html文件，但是在view1.html却无法对图片进行访问。显示结果： 

![image-20240603134425600](.\images\image-20240603134425600.png) 

![image-20240603134445929](.\images\image-20240603134445929.png) 

<img src=".\images\image-20240603134456485.png" alt="image-20240603134456485" style="zoom:50%;" /> 

**为什么会出现这种情况呢？**

这就和请求转发有关了。

当我们使用http://localhost:8080/demo05/view1Servlet去访问Servlet，Servlet给我们请求转发了，将去访问WEB-INF/view/view1.html文件，然后将view1.html中的数据响应给了客户端，客户端在拿到数据后解析响应体数据，其中的：

```xml
<img src="../../static/img/人物.jpg">
```

是根据当前资源所在路径，使用其相对路径来引入图片文件。

在view1.html中，所设置的是相对于view1.html的路径。

但是我们知道，请求转发时，url地址是不变的。

我们通过Servlet的请求转发来访问的view1.html，所以实际的url地址是：http://localhost:8080/demo05/view1Servlet

浏览器所认为的**当前资源是**：`viewServlet`，而不是view1.html

此时的**资源的当前路径是**：http://localhost:8080/demo05

那么将该路径拼接上相对路径../../static/img/人物.jpg，得到的**实际访问路径是**：http://localhost:8080/static/img/人物.jpg（相对路径中的../不会将前面的ip地址和端口号也去除）

![image-20240603140231448](.\images\image-20240603140231448.png) 

而我们在view1.html中，实际上是根据view1.html所在的当前路径，来考虑拼接相对路径。

**实际图片的路径是**：http://localhost:8080/demo05/static/img/人物.jpg

所以，此时无法去引入图片资源。

此时，我们可以将相对路径修改成绝对路径的方式：

```xml
<img src="/demo05/static/img/人物.jpg">
```

此时，去访问图片的路径就绝对是：http://localhost:8080/demo05/static/img/人物.jpg





##### 相对路径存在的问题及解决方案

**缺点**：目标资源路径受到当前资源路径的影响，不同的位置相对路径写法不同。

**解决方案：**使用绝对路径。

当使用相对路径时，只考虑文件和文件之间的目录结构是不靠谱的，我们要站在客户端的角度，以url结构基础来分析相对路径和绝对路径。



---

#### 绝对路径情况分析

**绝对路径：`始终以固定的路径作为出发点去找目标资源，和当前资源的所在路径没有关系。`**

**语法格式**：

* **以`/`开头**。不同的项目中，固定的路径出现点可能不一致。可以测试一下。

例如，在html中，使用绝对路径去访问资源：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

</head>
<body>
<a href="/a/b/c">跳转</a>
</body>
</html>
```

访问index.html，点击超链接访问资源，可以看到超链接的路径为：

![image-20240603152059060](.\images\image-20240603152059060.png) 

所以，我们可以知道，在绝对路径中，开头的/所表示路径是：

http://localhost:8080

那我们要使用绝对路径的访问访问目标资源，还需要在该路径后面添加上项目的上下文路径Application Context，以及目标资源在当前项目下的路径信息。

即，使用**绝对路径的格式应该为**：

**`/项目路径上下文/目标资源所在项目下的路径`**

绝对路径与当前资源所在的路径无关，只与目标资源所在路径有关。不会因为当前资源路径的改变而影响目标资源的路径。



##### 案例

将相对路径中的情况三，我们使用绝对路径来实现。

在Servlet中，使用请求转发的方式访问WEB-INF/views/view.html文件，在该view.html中，使用绝对路径去访问/static/img/人物.jpg图片。

<img src=".\images\image-20240603152855511.png" alt="image-20240603152855511" style="zoom:67%;" /> 

Servlet

```java
@WebServlet("/view1Servlet")
public class View1Servlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("./WEB-INF/views/view1.html");
        requestDispatcher.forward(req, resp);
    }
}
```

view.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<img src="/demo05/static/img/人物.jpg">
</body>
</html>
```

此时，去访问Servlet，就能够因请求转发跳转到view.html中，并且在view.html中，就不会因为相对路径的缘故，请求转发时url不变而获取不到图片。绝对路径不会受到当前资源的路径的影响。

此时访问图片的路径：

![image-20240603153902043](.\images\image-20240603153902043.png) 





##### 绝对路径存在的问题及解决方案

**绝对路径的优点**：目标资源路径的写法不会受到当前资源路径的影响，不同的位置绝对路径写法一致。

**绝对路径的缺点**：绝对路径要补充项目的上下文路径，项目的上下文路径是可以改变的。此时，设定的绝对路径都要改变。



**解决方案：使用base标签**

在head标签中，定义一个base标签，用于定义当前页面中相对路径的公共前缀。

该base标签，是给当前页面中所有不加任何修饰的相对前缀前，自动补充href中的内容。

如：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!--定义相对路径的公共前缀,将相对路径转化成了绝对路径-->
    <base href="/web03_war_exploded/">
</head>
<body>
    <img src="static/img/logo.png">
</body>
</html>
```

则在访问img路径时，就会自动给该相对路径前添加href的内容，得到/web03_war_exploded/static/img/log.png。无论该html中有多少个相对路径访问，都会在前面添加/web03_war_exploded/。

这样一来，当项目的上下文路径发生改变后，我们只需要该文件中的base标签内容即可，不需要去改文件中所有的绝对路径地址信息。

注意：base标签定义的公共前缀只在相对路径上生效，绝对路径中无效。如果相对路径开头有./或者../修饰，则base标签对该路径同样无效。即若需要使用该标签，不能使用./开头以及../开头，也不能以/开头。







> #### 总结
>
> * **`相对路径`**
>   * 相对路径的规则是：`以当前资源所在的路径为出发点去寻找目标资源`。
>   * 相对路径不以 / 开头
>   * 在file协议下，使用的是磁盘路径
>   * 在http协议下，使用的是url路径
>   * 相对路径中可以使用./表示当前资源所在路径，可以省略不写
>   * 相对路径中可以使用../表示当前资源所在路径的上一层路径，需要时手动添加。
>
> **缺点**：目标资源路径受到当前资源路径的影响，不同的位置相对路径写法不同。
>
> * **`绝对路径`**
>   * 绝对路径的规则是：`使用以一个固定的路径去做出发点去寻找目标资源，和当前资源所在的路径没有关系`
>   * 绝对路径要以 / 开头
>   * 绝对路径的写法中，不以当前资源的所在路径为出发点，所以不会出现 ./ 和 ../
>   * 不同的项目和不同的协议下，绝对路径的基础位置可能不同，要通过测试确定
>   * 绝对路径的好处就是：无论当前资源在哪，寻找目标资源路径的写法都一样。
>
> **优点**：目标资源路径的写法不会受到当前资源路径的影响，不同的位置绝对路径写法一致。
>
> **缺点**：绝对路径要补充项目的上下文路径，项目的上下文路径是可以改变的。此时，设定的绝对路径都要改变。
>
> * 应用场景：
>   1. 前端代码中，href、src、action等属性
>   2. 请求转发和重定向中的路径







---

### 请求转发与响应重定向中的路径问题

对于响应重定向来说：其跳转路径中，相对路径与就绝对路径的写法与前端是一样的。

但是，**对于请求转发而言：跳转路径若使用相对路径来实现，与去前端的写法是一样的；但是若使用的是绝对路径，则绝对路径中不需要在/斜杆后面添加项目的上下文路径，/默认已经包含了上下文路径了。即/就等于http://localhost:8080/demo05，我们就只需要考虑项目上下文路径之后的路径。**

我们直接根据案例来具体地考虑。



**目的**

在ServletA中，使用响应重定向与请求转发跳转到ServletB。

**ServletA**

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //使用重定向跳转到ServletB
    }
}
```

**ServletB**

```java
@WebServlet("/x/y/servletB")
public class ServletB extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html;charset=UTF-8");
        resp.getWriter().write("我是ServletB");
    }
}
```





#### 案例1：使用相对路径实现

**响应重定向**

我们来看看ServletA，ServletA的映射地址是/a/b/c/ServletA，那么访问ServletA的url为：http://localhost:8080/demo05/a/b/c/ServletA

ServletA的当前资源路径是：http://localhost:8080/demo05/a/b/c

要去跳转的ServletB目标资源为：http://localhost:8080/demo05/x/y/servletB

那么此时，若想要去使用相对路径的方式跳转，则相对路径应该为：`../../../x/y/servletB`。

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //使用重定向跳转到ServletB
        resp.sendRedirect("../../../x/y/servletB");
    }
}
```

此时，去访问http://localhost:8080/demo05/a/b/c/servletA，此时服务端响应的信息：

<img src=".\images\image-20240603171749123.png" alt="image-20240603171749123" style="zoom: 80%;" /> 

响应码为302，此时客户端就知道要重新发送请求跳转。

Location为../../../x/y/servletB，该信息为相对路径，那么客户单就会将该值拼接到当前资源的所在路径中，也就是往http://localhost:8080/demo05/a/b/c/。

../抵消一层目录，一共有三层../，就抵消了三层路径，然后将/x/y/servletB进行拼接，获得最终要重新发送请求的url：

http://localhost:8080/demo05/x/y/servletB。

<img src=".\images\image-20240603172119804.png" alt="image-20240603172119804" style="zoom:80%;" /> 





**请求转发**

请求转发的相对路径使用方式与前端一致：

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //使用请求转发的方式访问ServletB
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("../../../x/y/servletB");
        requestDispatcher.forward(req, resp);
    }
}
```









---

#### 案例2：使用绝对路径实现

**响应重定向**

响应重定向使用绝对路径考虑的方式与前端路径考虑方式一样。

绝对路径与当前资源所在的路径无关，只与目标资源的路径有关。

目标资源ServletB的url为：http://localhost:8080/demo05/x/y/servletB。

绝对路径以/开头，/表示的是项目上下文路径前面的部分：http://localhost:8080/。

所以，若使用绝对路径的方式，则在servletA中所设置的重定向地址应该为：**`/demo05/x/y/servletB`**

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //使用重定向跳转到ServletB
        resp.sendRedirect("/demo05/x/y/servletB");
    }
}
```

此时，去访问ServletA，就会跳转到http://localhost:8080/demo05/x/y/servletB

<img src=".\images\image-20240603173122620.png" alt="image-20240603173122620" style="zoom:67%;" /> 

访问ServletA，响应信息：

![image-20240603173220357](.\images\image-20240603173220357.png) 

响应码是302，浏览器会重新发送请求访问Location地址。

Location地址以/开头表示该地址是一个绝对地址，将Location中的信息拼接上http://lcoalhost:8080就是请求的地址。

我们也可以使用ServletContext对象中的getContextPath()方法，获取项目的上下文路径，然后将获得的值拼接到跳转路径中，如：

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = req.getServletContext();
        String contextPath = servletContext.getContextPath();

        resp.sendRedirect(contextPath + "/x/y/servletB");
    }
}

```

这样就能够实现动态获取项目的上下文路径，防止因上下文路径的改变而导致需要手动更改路径。





**请求转发**

请求转发的跳转路径，若使用的是绝对路径的方式，与前端绝对路径有些不一样，**/斜杆表示的内容不仅仅是http://localhost:8080，还包含了项目的上下文路径**，即：`http://localhost:8080/项目上下文路径`。

这是唯一不同的地方。

实现ServletB的跳转：

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //使用请求转发的方式访问ServletB
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("/x/y/servletB");
        
        requestDispatcher.forward(req, resp);
    }
}
```

此时，使用的是绝对路径，并且因使用的方式是请求转发，/能够将项目的上下文路径都包含，所以在后续不再填写上下文路径。





---

#### 请求转发目标资源内相对路径处理

假如：要在webapp/WEB-INF/views/view1.html中，获取webapp/static/img/人物.jpg：

<img src=".\images\i11111" alt="image-20240603175833195" style="zoom: 80%;" /> 

那么，此时我们使用相对路径在view1.html中对图片进行访问：

```html
<img src="../../static/img/人物.jpg">
```

那此时，是否可以通过使用请求转发的方式，跳转到view1.html，然后在view1.html中访问到该图片呢？

答案是不行的。

我们来测试一下：
首先，由于view1.html文件放在WEB-INF中，所以我们使用请求转发来进行访问。

在View1Servlet中，使用请求转发的方式来访问该view1.html：

```java
@WebServlet("/view1Servlet")
public class View1Servlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取RequestDispatcher对象
        // 由于当前Servlet的路径是http://localhost:8080/demo05/view1Servlet
        //所以当前资源的当前路径是http://localhost:8080/demo05/
        //使用相对路径，那么实际访问的路径是http://localhost:8080/demo05/WEB-INF/views/view1.html
        //由于使用的是请求转发，所以可以访问到WEB-INF中的资源
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("./WEB-INF/views/view1.html");
        requestDispatcher.forward(req, resp);
    }
}
```

那么，此时就使用了请求转发的方式访问到了webapp/WEB-INF/views/view1.html文件，但是在view1.html却无法对图片进行访问。显示结果： 

![image-20240603134425600](.\images\222321313) 

![image-20240603134445929](.\images\12312312312) 

<img src=".\images\image-2024060313412312312312.png" alt="image-20240603134456485" style="zoom:50%;" /> 

**为什么会出现这种情况呢？**

这就和请求转发有关了。

当我们使用http://localhost:8080/demo05/view1Servlet去访问Servlet，Servlet给我们请求转发了，将去访问WEB-INF/view/view1.html文件，然后将view1.html中的数据响应给了客户端，客户端在拿到数据后解析响应体数据，其中的：

```xml
<img src="../../static/img/人物.jpg">
```

是根据当前资源所在路径，使用其相对路径来引入图片文件。

在view1.html中，所设置的是相对于view1.html的路径。

但是我们知道，请求转发时，url地址是不变的。

我们通过Servlet的请求转发来访问的view1.html，所以实际的url地址是：http://localhost:8080/demo05/view1Servlet

浏览器所认为的**当前资源是**：`viewServlet`，而不是view1.html

此时的**资源的当前路径是**：http://localhost:8080/demo05

那么将该路径拼接上相对路径../../static/img/人物.jpg，得到的**实际访问路径是**：http://localhost:8080/static/img/人物.jpg（相对路径中的../不会将前面的ip地址和端口号也去除）

![image-20240603140231448](.\images\image-20240603141231230231448.png) 

而我们在view1.html中，实际上是根据view1.html所在的当前路径，来考虑拼接相对路径。

**实际图片的路径是**：http://localhost:8080/demo05/static/img/人物.jpg

所以，此时无法去引入图片资源。

此时，我们可以将相对路径修改成绝对路径的方式：

```xml
<img src="/demo05/static/img/人物.jpg">
```

此时，去访问图片的路径就绝对是：http://localhost:8080/demo05/static/img/人物.jpg





> #### 总结
>
> * 若使用相对路径的方式实现请求转发与响应重定向，
>   * 使用的方式与前端一致，即./表示当前路径下，../表示上一层路径下。
> * 若使用绝对路径的方式实现请求转发与响应重定向，
>   * 响应重定向使用方式与前端一致，即/开头，/表示的含义是http://ip:port/，不包含项目上下文路径。
>   * 请求转发与前端有些不同，使用/开头，/表示的含义是http://ip:port/项目上下文路径，是包含项目上下文路径的。
>
> **注意：**
>
> 请求转发到目标资源后，若目标资源使用的`相对路径`的方式去获取其他资源，此时`相对的路径是请求转发跳转之前的路径`，因为`请求转发不会改变url地址`。所以，在请求转发的目标资源中，若要引入其他资源，则一般使用绝对路径的方式。



---

### 解决路径问题的方案：不设置项目上下文路径

在之前的学习中，我们可以发现路径存在几个问题：

1. 使用相对路径，url路径可能与项目目录结构不同：请求转发跳转的目标资源中，若使用相对路径去访问了其他资源，则相对的是当前的资源路径。
2. 若项目的上下文路径改变，使用的绝对路径也需要去改变项目的上下文路径。
3. 若请求转发使用的是绝对路径，则该绝对路径特殊，/中包含了项目的上下文路径。

对于上述这些问题，有没有什么解决方案能够全部解决？

有。

**解决方案**：

将项目的上下文路径缺省，设置为/，我们将所有需要使用路径的位置全部都使用绝对路径，所有绝对路径中都不必填写项目的上下文了，开头都使用/即可。

<img src=".\images\image-202406031942408225.png" alt="image-20240603194408225" style="zoom:50%;" /> 

例如：

当我们将项目的上下文路径设置为/，此时使用绝对路径的方式，无论使用响应重定向还是请求转发的方式，实际上跳转到的路径都是一样的：

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //使用请求转发的方式访问ServletB
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("/x/y/servletB");
        
        requestDispatcher.forward(req, resp);
    }
}
```

```java
@WebServlet("/a/b/c/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //使用重定向跳转到ServletB
        resp.sendRedirect("/x/y/servletB");
    }
}
```

在上面请求转发与响应重定向跳转的地址都是一样的：

http://localhost:8080/x/y/servletB



在实际的开发中，我们就是将项目的上下文设置成/，只需要根据ip地址和端口号，就能够找到对应的项目，没有必要给项目设置上下文路径。